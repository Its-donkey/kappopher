
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>helix: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Its-donkey/kappopher/helix/ads.go (0.0%)</option>
				
				<option value="file1">github.com/Its-donkey/kappopher/helix/analytics.go (0.0%)</option>
				
				<option value="file2">github.com/Its-donkey/kappopher/helix/auth.go (0.0%)</option>
				
				<option value="file3">github.com/Its-donkey/kappopher/helix/badges.go (0.0%)</option>
				
				<option value="file4">github.com/Its-donkey/kappopher/helix/batch.go (0.0%)</option>
				
				<option value="file5">github.com/Its-donkey/kappopher/helix/bits.go (0.0%)</option>
				
				<option value="file6">github.com/Its-donkey/kappopher/helix/cache.go (0.0%)</option>
				
				<option value="file7">github.com/Its-donkey/kappopher/helix/ccl.go (0.0%)</option>
				
				<option value="file8">github.com/Its-donkey/kappopher/helix/channel_points.go (0.0%)</option>
				
				<option value="file9">github.com/Its-donkey/kappopher/helix/channels.go (0.0%)</option>
				
				<option value="file10">github.com/Its-donkey/kappopher/helix/charity.go (0.0%)</option>
				
				<option value="file11">github.com/Its-donkey/kappopher/helix/chat.go (0.0%)</option>
				
				<option value="file12">github.com/Its-donkey/kappopher/helix/chat_client.go (0.0%)</option>
				
				<option value="file13">github.com/Its-donkey/kappopher/helix/client.go (0.0%)</option>
				
				<option value="file14">github.com/Its-donkey/kappopher/helix/clips.go (0.0%)</option>
				
				<option value="file15">github.com/Its-donkey/kappopher/helix/conduits.go (0.0%)</option>
				
				<option value="file16">github.com/Its-donkey/kappopher/helix/entitlements.go (0.0%)</option>
				
				<option value="file17">github.com/Its-donkey/kappopher/helix/eventsub.go (0.0%)</option>
				
				<option value="file18">github.com/Its-donkey/kappopher/helix/eventsub_webhook.go (0.0%)</option>
				
				<option value="file19">github.com/Its-donkey/kappopher/helix/eventsub_websocket.go (0.0%)</option>
				
				<option value="file20">github.com/Its-donkey/kappopher/helix/extension_jwt.go (0.0%)</option>
				
				<option value="file21">github.com/Its-donkey/kappopher/helix/extensions.go (0.0%)</option>
				
				<option value="file22">github.com/Its-donkey/kappopher/helix/games.go (0.0%)</option>
				
				<option value="file23">github.com/Its-donkey/kappopher/helix/goals.go (0.0%)</option>
				
				<option value="file24">github.com/Its-donkey/kappopher/helix/guest_star.go (0.0%)</option>
				
				<option value="file25">github.com/Its-donkey/kappopher/helix/ingest.go (0.0%)</option>
				
				<option value="file26">github.com/Its-donkey/kappopher/helix/irc.go (96.8%)</option>
				
				<option value="file27">github.com/Its-donkey/kappopher/helix/irc_parser.go (74.6%)</option>
				
				<option value="file28">github.com/Its-donkey/kappopher/helix/middleware.go (0.0%)</option>
				
				<option value="file29">github.com/Its-donkey/kappopher/helix/moderation.go (0.0%)</option>
				
				<option value="file30">github.com/Its-donkey/kappopher/helix/polls.go (0.0%)</option>
				
				<option value="file31">github.com/Its-donkey/kappopher/helix/predictions.go (0.0%)</option>
				
				<option value="file32">github.com/Its-donkey/kappopher/helix/raids.go (0.0%)</option>
				
				<option value="file33">github.com/Its-donkey/kappopher/helix/schedule.go (0.0%)</option>
				
				<option value="file34">github.com/Its-donkey/kappopher/helix/search.go (0.0%)</option>
				
				<option value="file35">github.com/Its-donkey/kappopher/helix/streams.go (0.0%)</option>
				
				<option value="file36">github.com/Its-donkey/kappopher/helix/subscriptions.go (0.0%)</option>
				
				<option value="file37">github.com/Its-donkey/kappopher/helix/teams.go (0.0%)</option>
				
				<option value="file38">github.com/Its-donkey/kappopher/helix/users.go (0.0%)</option>
				
				<option value="file39">github.com/Its-donkey/kappopher/helix/videos.go (0.0%)</option>
				
				<option value="file40">github.com/Its-donkey/kappopher/helix/whispers.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// Commercial represents a started commercial.
type Commercial struct {
        Length     int    `json:"length"`
        Message    string `json:"message"`
        RetryAfter int    `json:"retry_after"`
}

// StartCommercialParams contains parameters for StartCommercial.
type StartCommercialParams struct {
        BroadcasterID string `json:"broadcaster_id"`
        Length        int    `json:"length"` // 30, 60, 90, 120, 150, or 180 seconds
}

// StartCommercial starts a commercial on a channel.
// Requires: channel:edit:commercial scope.
func (c *Client) StartCommercial(ctx context.Context, params *StartCommercialParams) (*Commercial, error) <span class="cov0" title="0">{
        var resp Response[Commercial]
        if err := c.post(ctx, "/channels/commercial", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// AdSchedule represents the ad schedule for a channel.
type AdSchedule struct {
        NextAdAt        time.Time `json:"next_ad_at,omitempty"`
        LastAdAt        time.Time `json:"last_ad_at,omitempty"`
        Duration        int       `json:"duration"`
        PrerollFreeTime int       `json:"preroll_free_time"`
        SnoozeCount     int       `json:"snooze_count"`
        SnoozeRefreshAt time.Time `json:"snooze_refresh_at,omitempty"`
}

// GetAdSchedule gets the ad schedule for a channel.
// Requires: channel:read:ads scope.
func (c *Client) GetAdSchedule(ctx context.Context, broadcasterID string) (*AdSchedule, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[AdSchedule]
        if err := c.get(ctx, "/channels/ads", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// SnoozeNextAdResponse represents the response from SnoozeNextAd.
type SnoozeNextAdResponse struct {
        SnoozeCount     int       `json:"snooze_count"`
        SnoozeRefreshAt time.Time `json:"snooze_refresh_at"`
        NextAdAt        time.Time `json:"next_ad_at"`
}

// SnoozeNextAd snoozes the next scheduled ad.
// Requires: channel:manage:ads scope.
func (c *Client) SnoozeNextAd(ctx context.Context, broadcasterID string) (*SnoozeNextAdResponse, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[SnoozeNextAdResponse]
        if err := c.post(ctx, "/channels/ads/schedule/snooze", q, nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// ExtensionAnalytics represents extension analytics data.
type ExtensionAnalytics struct {
        ExtensionID string    `json:"extension_id"`
        URL         string    `json:"url"`
        Type        string    `json:"type"`
        DateRange   DateRange `json:"date_range"`
}

// GetExtensionAnalyticsParams contains parameters for GetExtensionAnalytics.
type GetExtensionAnalyticsParams struct {
        ExtensionID string
        Type        string // overview_v2
        StartedAt   time.Time
        EndedAt     time.Time
        *PaginationParams
}

// GetExtensionAnalytics gets analytics for extensions.
// Requires: analytics:read:extensions scope.
func (c *Client) GetExtensionAnalytics(ctx context.Context, params *GetExtensionAnalyticsParams) (*Response[ExtensionAnalytics], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil </span><span class="cov0" title="0">{
                if params.ExtensionID != "" </span><span class="cov0" title="0">{
                        q.Set("extension_id", params.ExtensionID)
                }</span>
                <span class="cov0" title="0">if params.Type != "" </span><span class="cov0" title="0">{
                        q.Set("type", params.Type)
                }</span>
                <span class="cov0" title="0">if !params.StartedAt.IsZero() </span><span class="cov0" title="0">{
                        q.Set("started_at", params.StartedAt.Format(time.RFC3339))
                }</span>
                <span class="cov0" title="0">if !params.EndedAt.IsZero() </span><span class="cov0" title="0">{
                        q.Set("ended_at", params.EndedAt.Format(time.RFC3339))
                }</span>
                <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)</span>
        }

        <span class="cov0" title="0">var resp Response[ExtensionAnalytics]
        if err := c.get(ctx, "/analytics/extensions", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GameAnalytics represents game analytics data.
type GameAnalytics struct {
        GameID    string    `json:"game_id"`
        URL       string    `json:"url"`
        Type      string    `json:"type"`
        DateRange DateRange `json:"date_range"`
}

// GetGameAnalyticsParams contains parameters for GetGameAnalytics.
type GetGameAnalyticsParams struct {
        GameID    string
        Type      string // overview_v2
        StartedAt time.Time
        EndedAt   time.Time
        *PaginationParams
}

// GetGameAnalytics gets analytics for games.
// Requires: analytics:read:games scope.
func (c *Client) GetGameAnalytics(ctx context.Context, params *GetGameAnalyticsParams) (*Response[GameAnalytics], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil </span><span class="cov0" title="0">{
                if params.GameID != "" </span><span class="cov0" title="0">{
                        q.Set("game_id", params.GameID)
                }</span>
                <span class="cov0" title="0">if params.Type != "" </span><span class="cov0" title="0">{
                        q.Set("type", params.Type)
                }</span>
                <span class="cov0" title="0">if !params.StartedAt.IsZero() </span><span class="cov0" title="0">{
                        q.Set("started_at", params.StartedAt.Format(time.RFC3339))
                }</span>
                <span class="cov0" title="0">if !params.EndedAt.IsZero() </span><span class="cov0" title="0">{
                        q.Set("ended_at", params.EndedAt.Format(time.RFC3339))
                }</span>
                <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)</span>
        }

        <span class="cov0" title="0">var resp Response[GameAnalytics]
        if err := c.get(ctx, "/analytics/games", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package helix

import (
        "context"
        "crypto"
        "crypto/rsa"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "math/big"
        "net/http"
        "net/url"
        "strings"
        "sync"
        "time"
)

// Auth URL constants
const (
        // TwitchAuthURL is the base URL for Twitch OAuth endpoints.
        TwitchAuthURL = "https://id.twitch.tv/oauth2"

        // AuthorizeEndpoint is the authorization endpoint.
        AuthorizeEndpoint = TwitchAuthURL + "/authorize"

        // TokenEndpoint is the token endpoint.
        TokenEndpoint = TwitchAuthURL + "/token"

        // ValidateEndpoint is the token validation endpoint.
        ValidateEndpoint = TwitchAuthURL + "/validate"

        // RevokeEndpoint is the token revocation endpoint.
        RevokeEndpoint = TwitchAuthURL + "/revoke"

        // DeviceEndpoint is the device authorization endpoint.
        DeviceEndpoint = TwitchAuthURL + "/device"

        // OpenIDConfigurationEndpoint is the OIDC discovery endpoint.
        OpenIDConfigurationEndpoint = TwitchAuthURL + "/.well-known/openid-configuration"

        // UserInfoEndpoint is the OIDC userinfo endpoint.
        UserInfoEndpoint = TwitchAuthURL + "/userinfo"

        // JWKSEndpoint is the JSON Web Key Set endpoint.
        JWKSEndpoint = TwitchAuthURL + "/keys"
)

// Auth errors
var (
        ErrInvalidToken         = errors.New("invalid access token")
        ErrTokenExpired         = errors.New("token has expired")
        ErrAuthorizationPending = errors.New("authorization pending")
        ErrInvalidDeviceCode    = errors.New("invalid device code")
        ErrInvalidRefreshToken  = errors.New("invalid refresh token")
        ErrMissingClientID      = errors.New("client ID is required")
        ErrMissingClientSecret  = errors.New("client secret is required")
        ErrMissingRedirectURI   = errors.New("redirect URI is required")
        ErrMissingCode          = errors.New("authorization code is required")
)

// Token represents an OAuth token from Twitch.
type Token struct {
        AccessToken  string    `json:"access_token"`
        RefreshToken string    `json:"refresh_token,omitempty"`
        TokenType    string    `json:"token_type"`
        ExpiresIn    int       `json:"expires_in"`
        Scope        []string  `json:"scope,omitempty"`
        ExpiresAt    time.Time `json:"-"`
}

// IsExpired returns true if the token has expired.
func (t *Token) IsExpired() bool <span class="cov0" title="0">{
        if t.ExpiresAt.IsZero() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return time.Now().After(t.ExpiresAt)</span>
}

// Valid returns true if the token is non-empty and not expired.
func (t *Token) Valid() bool <span class="cov0" title="0">{
        return t.AccessToken != "" &amp;&amp; !t.IsExpired()
}</span>

// setExpiry calculates and sets the ExpiresAt field based on ExpiresIn.
func (t *Token) setExpiry() <span class="cov0" title="0">{
        if t.ExpiresIn &gt; 0 </span><span class="cov0" title="0">{
                t.ExpiresAt = time.Now().Add(time.Duration(t.ExpiresIn) * time.Second)
        }</span>
}

// ValidationResponse represents the response from the /validate endpoint.
type ValidationResponse struct {
        ClientID  string   `json:"client_id"`
        Login     string   `json:"login"`
        Scopes    []string `json:"scopes"`
        UserID    string   `json:"user_id"`
        ExpiresIn int      `json:"expires_in"`
}

// DeviceCodeResponse represents the response from the device authorization endpoint.
type DeviceCodeResponse struct {
        DeviceCode      string `json:"device_code"`
        ExpiresIn       int    `json:"expires_in"`
        Interval        int    `json:"interval"`
        UserCode        string `json:"user_code"`
        VerificationURI string `json:"verification_uri"`
}

// AuthErrorResponse represents an error response from Twitch auth endpoints.
type AuthErrorResponse struct {
        Status  int    `json:"status"`
        Message string `json:"message"`
        Error   string `json:"error,omitempty"`
}

// AuthConfig holds the configuration for OAuth.
type AuthConfig struct {
        ClientID     string
        ClientSecret string
        RedirectURI  string
        Scopes       []string
        ForceVerify  bool
        State        string
}

// AuthClient is an OAuth client for Twitch authentication.
type AuthClient struct {
        config     AuthConfig
        httpClient *http.Client
        token      *Token
        mu         sync.RWMutex

        // Configurable endpoints (for testing). These default to the Twitch constants.
        tokenEndpoint    string
        validateEndpoint string
        revokeEndpoint   string
        deviceEndpoint   string
        openIDConfigURL  string
        userInfoEndpoint string
        jwksEndpoint     string
}

// NewAuthClient creates a new OAuth client with the given configuration.
func NewAuthClient(config AuthConfig) *AuthClient <span class="cov0" title="0">{
        return &amp;AuthClient{
                config:           config,
                httpClient:       &amp;http.Client{Timeout: 30 * time.Second},
                tokenEndpoint:    TokenEndpoint,
                validateEndpoint: ValidateEndpoint,
                revokeEndpoint:   RevokeEndpoint,
                deviceEndpoint:   DeviceEndpoint,
                openIDConfigURL:  OpenIDConfigurationEndpoint,
                userInfoEndpoint: UserInfoEndpoint,
                jwksEndpoint:     JWKSEndpoint,
        }
}</span>

// SetEndpoints sets custom endpoints (primarily for testing).
func (c *AuthClient) SetEndpoints(token, validate, revoke, device, openIDConfig, userInfo, jwks string) <span class="cov0" title="0">{
        if token != "" </span><span class="cov0" title="0">{
                c.tokenEndpoint = token
        }</span>
        <span class="cov0" title="0">if validate != "" </span><span class="cov0" title="0">{
                c.validateEndpoint = validate
        }</span>
        <span class="cov0" title="0">if revoke != "" </span><span class="cov0" title="0">{
                c.revokeEndpoint = revoke
        }</span>
        <span class="cov0" title="0">if device != "" </span><span class="cov0" title="0">{
                c.deviceEndpoint = device
        }</span>
        <span class="cov0" title="0">if openIDConfig != "" </span><span class="cov0" title="0">{
                c.openIDConfigURL = openIDConfig
        }</span>
        <span class="cov0" title="0">if userInfo != "" </span><span class="cov0" title="0">{
                c.userInfoEndpoint = userInfo
        }</span>
        <span class="cov0" title="0">if jwks != "" </span><span class="cov0" title="0">{
                c.jwksEndpoint = jwks
        }</span>
}

// SetHTTPClient sets a custom HTTP client.
func (c *AuthClient) SetHTTPClient(client *http.Client) <span class="cov0" title="0">{
        c.httpClient = client
}</span>

// SetToken sets the current token.
func (c *AuthClient) SetToken(token *Token) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.token = token
}</span>

// GetToken returns the current token.
func (c *AuthClient) GetToken() *Token <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.token
}</span>

// GetAuthorizationURL returns the URL to redirect users to for authorization.
func (c *AuthClient) GetAuthorizationURL(responseType string) (string, error) <span class="cov0" title="0">{
        if c.config.ClientID == "" </span><span class="cov0" title="0">{
                return "", ErrMissingClientID
        }</span>
        <span class="cov0" title="0">if c.config.RedirectURI == "" </span><span class="cov0" title="0">{
                return "", ErrMissingRedirectURI
        }</span>

        <span class="cov0" title="0">params := url.Values{
                "client_id":     {c.config.ClientID},
                "redirect_uri":  {c.config.RedirectURI},
                "response_type": {responseType},
                "scope":         {strings.Join(c.config.Scopes, " ")},
        }

        if c.config.State != "" </span><span class="cov0" title="0">{
                params.Set("state", c.config.State)
        }</span>
        <span class="cov0" title="0">if c.config.ForceVerify </span><span class="cov0" title="0">{
                params.Set("force_verify", "true")
        }</span>

        <span class="cov0" title="0">return AuthorizeEndpoint + "?" + params.Encode(), nil</span>
}

// GetImplicitAuthURL returns the authorization URL for the Implicit Grant flow.
func (c *AuthClient) GetImplicitAuthURL() (string, error) <span class="cov0" title="0">{
        return c.GetAuthorizationURL("token")
}</span>

// GetCodeAuthURL returns the authorization URL for the Authorization Code Grant flow.
func (c *AuthClient) GetCodeAuthURL() (string, error) <span class="cov0" title="0">{
        return c.GetAuthorizationURL("code")
}</span>

// ExchangeCode exchanges an authorization code for an access token.
func (c *AuthClient) ExchangeCode(ctx context.Context, code string) (*Token, error) <span class="cov0" title="0">{
        if c.config.ClientID == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingClientID
        }</span>
        <span class="cov0" title="0">if c.config.ClientSecret == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingClientSecret
        }</span>
        <span class="cov0" title="0">if code == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingCode
        }</span>

        <span class="cov0" title="0">data := url.Values{
                "client_id":     {c.config.ClientID},
                "client_secret": {c.config.ClientSecret},
                "code":          {code},
                "grant_type":    {"authorization_code"},
                "redirect_uri":  {c.config.RedirectURI},
        }

        return c.requestToken(ctx, data)</span>
}

// GetAppAccessToken obtains an app access token using the Client Credentials flow.
func (c *AuthClient) GetAppAccessToken(ctx context.Context) (*Token, error) <span class="cov0" title="0">{
        if c.config.ClientID == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingClientID
        }</span>
        <span class="cov0" title="0">if c.config.ClientSecret == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingClientSecret
        }</span>

        <span class="cov0" title="0">data := url.Values{
                "client_id":     {c.config.ClientID},
                "client_secret": {c.config.ClientSecret},
                "grant_type":    {"client_credentials"},
        }

        return c.requestToken(ctx, data)</span>
}

// GetDeviceCode initiates the Device Code flow.
func (c *AuthClient) GetDeviceCode(ctx context.Context) (*DeviceCodeResponse, error) <span class="cov0" title="0">{
        if c.config.ClientID == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingClientID
        }</span>

        <span class="cov0" title="0">data := url.Values{
                "client_id": {c.config.ClientID},
                "scopes":    {strings.Join(c.config.Scopes, " ")},
        }

        req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.deviceEndpoint, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating device code request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("executing device code request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading device code response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                var errResp AuthErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("device code request failed with status %d: %s", resp.StatusCode, string(body))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("device code request failed: %s", errResp.Message)</span>
        }

        <span class="cov0" title="0">var dcResp DeviceCodeResponse
        if err := json.Unmarshal(body, &amp;dcResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing device code response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;dcResp, nil</span>
}

// PollDeviceToken polls for the device token after the user has authorized.
func (c *AuthClient) PollDeviceToken(ctx context.Context, deviceCode string) (*Token, error) <span class="cov0" title="0">{
        if c.config.ClientID == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingClientID
        }</span>

        <span class="cov0" title="0">data := url.Values{
                "client_id":   {c.config.ClientID},
                "device_code": {deviceCode},
                "grant_type":  {"urn:ietf:params:oauth:grant-type:device_code"},
                "scopes":      {strings.Join(c.config.Scopes, " ")},
        }

        if c.config.ClientSecret != "" </span><span class="cov0" title="0">{
                data.Set("client_secret", c.config.ClientSecret)
        }</span>

        <span class="cov0" title="0">token, err := c.requestToken(ctx, data)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "authorization_pending") </span><span class="cov0" title="0">{
                        return nil, ErrAuthorizationPending
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "invalid device code") </span><span class="cov0" title="0">{
                        return nil, ErrInvalidDeviceCode
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return token, nil</span>
}

// WaitForDeviceToken polls for the device token until it's available or the context is cancelled.
func (c *AuthClient) WaitForDeviceToken(ctx context.Context, deviceCode *DeviceCodeResponse) (*Token, error) <span class="cov0" title="0">{
        ticker := time.NewTicker(time.Duration(deviceCode.Interval) * time.Second)
        defer ticker.Stop()

        expiresAt := time.Now().Add(time.Duration(deviceCode.ExpiresIn) * time.Second)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if time.Now().After(expiresAt) </span><span class="cov0" title="0">{
                                return nil, errors.New("device code expired")
                        }</span>

                        <span class="cov0" title="0">token, err := c.PollDeviceToken(ctx, deviceCode.DeviceCode)
                        if err == ErrAuthorizationPending </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return token, nil</span>
                }
        }
}

// RefreshToken refreshes an access token using a refresh token.
func (c *AuthClient) RefreshToken(ctx context.Context, refreshToken string) (*Token, error) <span class="cov0" title="0">{
        if c.config.ClientID == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingClientID
        }</span>
        <span class="cov0" title="0">if c.config.ClientSecret == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingClientSecret
        }</span>
        <span class="cov0" title="0">if refreshToken == "" </span><span class="cov0" title="0">{
                return nil, ErrInvalidRefreshToken
        }</span>

        <span class="cov0" title="0">data := url.Values{
                "client_id":     {c.config.ClientID},
                "client_secret": {c.config.ClientSecret},
                "grant_type":    {"refresh_token"},
                "refresh_token": {refreshToken},
        }

        token, err := c.requestToken(ctx, data)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "Invalid refresh token") </span><span class="cov0" title="0">{
                        return nil, ErrInvalidRefreshToken
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return token, nil</span>
}

// RefreshCurrentToken refreshes the current token if it has a refresh token.
func (c *AuthClient) RefreshCurrentToken(ctx context.Context) (*Token, error) <span class="cov0" title="0">{
        c.mu.RLock()
        if c.token == nil || c.token.RefreshToken == "" </span><span class="cov0" title="0">{
                c.mu.RUnlock()
                return nil, ErrInvalidRefreshToken
        }</span>
        <span class="cov0" title="0">refreshToken := c.token.RefreshToken
        c.mu.RUnlock()

        token, err := c.RefreshToken(ctx, refreshToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.SetToken(token)
        return token, nil</span>
}

// ValidateToken validates an access token.
func (c *AuthClient) ValidateToken(ctx context.Context, accessToken string) (*ValidationResponse, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, c.validateEndpoint, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating validate request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "OAuth "+accessToken)

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("executing validate request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading validate response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                var errResp AuthErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("validate request failed with status %d: %s", resp.StatusCode, string(body))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("validate request failed: %s", errResp.Message)</span>
        }

        <span class="cov0" title="0">var valResp ValidationResponse
        if err := json.Unmarshal(body, &amp;valResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing validate response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;valResp, nil</span>
}

// ValidateCurrentToken validates the current token.
func (c *AuthClient) ValidateCurrentToken(ctx context.Context) (*ValidationResponse, error) <span class="cov0" title="0">{
        c.mu.RLock()
        if c.token == nil </span><span class="cov0" title="0">{
                c.mu.RUnlock()
                return nil, ErrInvalidToken
        }</span>
        <span class="cov0" title="0">accessToken := c.token.AccessToken
        c.mu.RUnlock()

        return c.ValidateToken(ctx, accessToken)</span>
}

// RevokeToken revokes an access token.
func (c *AuthClient) RevokeToken(ctx context.Context, accessToken string) error <span class="cov0" title="0">{
        if c.config.ClientID == "" </span><span class="cov0" title="0">{
                return ErrMissingClientID
        }</span>

        <span class="cov0" title="0">data := url.Values{
                "client_id": {c.config.ClientID},
                "token":     {accessToken},
        }

        req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.revokeEndpoint, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("creating revoke request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("executing revoke request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reading revoke response: %w", err)
        }</span>

        <span class="cov0" title="0">var errResp AuthErrorResponse
        if err := json.Unmarshal(body, &amp;errResp); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("revoke request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("revoke request failed: %s", errResp.Message)</span>
}

// RevokeCurrentToken revokes the current token.
func (c *AuthClient) RevokeCurrentToken(ctx context.Context) error <span class="cov0" title="0">{
        c.mu.RLock()
        if c.token == nil </span><span class="cov0" title="0">{
                c.mu.RUnlock()
                return ErrInvalidToken
        }</span>
        <span class="cov0" title="0">accessToken := c.token.AccessToken
        c.mu.RUnlock()

        if err := c.RevokeToken(ctx, accessToken); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        c.token = nil
        c.mu.Unlock()

        return nil</span>
}

// requestToken makes a token request to the Twitch token endpoint.
func (c *AuthClient) requestToken(ctx context.Context, data url.Values) (*Token, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.tokenEndpoint, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating token request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("executing token request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading token response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                var errResp AuthErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("token request failed with status %d: %s", resp.StatusCode, string(body))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("token request failed: %s", errResp.Message)</span>
        }

        <span class="cov0" title="0">var token Token
        if err := json.Unmarshal(body, &amp;token); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing token response: %w", err)
        }</span>

        <span class="cov0" title="0">token.setExpiry()
        c.SetToken(&amp;token)

        return &amp;token, nil</span>
}

// AutoRefresh starts a goroutine that automatically refreshes the token before it expires.
// If the token has no expiry set (ExpiresAt is zero), it will not attempt automatic refresh
// until a token with a valid expiry is set.
//
// IMPORTANT: The caller MUST call the returned cancel function to stop the goroutine
// when it's no longer needed, or ensure the parent context is eventually cancelled.
// Failure to do so will result in a goroutine leak.
func (c *AuthClient) AutoRefresh(ctx context.Context) (cancel func()) <span class="cov0" title="0">{
        ctx, cancelFunc := context.WithCancel(ctx)

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        c.mu.RLock()
                        token := c.token
                        c.mu.RUnlock()

                        // No token or no refresh token - wait and check again
                        if token == nil || token.RefreshToken == "" </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case &lt;-time.After(time.Minute):<span class="cov0" title="0">
                                        continue</span>
                                }
                        }

                        // If ExpiresAt is zero (not set), we can't determine when to refresh.
                        // Wait and check again - token may be updated with proper expiry later.
                        <span class="cov0" title="0">if token.ExpiresAt.IsZero() </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                case &lt;-time.After(time.Minute):<span class="cov0" title="0">
                                        continue</span>
                                }
                        }

                        <span class="cov0" title="0">refreshAt := token.ExpiresAt.Add(-5 * time.Minute)
                        waitDuration := time.Until(refreshAt)

                        if waitDuration &lt;= 0 </span><span class="cov0" title="0">{
                                // Token is expired or about to expire - refresh now
                                if _, err := c.RefreshCurrentToken(ctx); err != nil </span><span class="cov0" title="0">{
                                        select </span>{
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        case &lt;-time.After(30 * time.Second):<span class="cov0" title="0">
                                                continue</span>
                                        }
                                }
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-time.After(waitDuration):<span class="cov0" title="0">
                                if _, err := c.RefreshCurrentToken(ctx); err != nil </span><span class="cov0" title="0">{
                                        select </span>{
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        case &lt;-time.After(30 * time.Second):<span class="cov0" title="0">
                                                continue</span>
                                        }
                                }
                        }
                }
        }()

        <span class="cov0" title="0">return cancelFunc</span>
}

// ============================================================================
// OIDC Types and Functions
// ============================================================================

// OpenIDConfiguration represents the OIDC discovery document.
type OpenIDConfiguration struct {
        Issuer                            string   `json:"issuer"`
        AuthorizationEndpoint             string   `json:"authorization_endpoint"`
        TokenEndpoint                     string   `json:"token_endpoint"`
        UserInfoEndpoint                  string   `json:"userinfo_endpoint"`
        JWKSUri                           string   `json:"jwks_uri"`
        ResponseTypesSupported            []string `json:"response_types_supported"`
        SubjectTypesSupported             []string `json:"subject_types_supported"`
        IDTokenSigningAlgValuesSupported  []string `json:"id_token_signing_alg_values_supported"`
        ScopesSupported                   []string `json:"scopes_supported"`
        TokenEndpointAuthMethodsSupported []string `json:"token_endpoint_auth_methods_supported"`
        ClaimsSupported                   []string `json:"claims_supported"`
}

// OIDCUserInfo represents the response from the OIDC UserInfo endpoint.
type OIDCUserInfo struct {
        Sub               string `json:"sub"`
        PreferredUsername string `json:"preferred_username"`
        Email             string `json:"email,omitempty"`
        EmailVerified     bool   `json:"email_verified,omitempty"`
        Picture           string `json:"picture,omitempty"`
        UpdatedAt         int64  `json:"updated_at,omitempty"`
}

// JWKS represents a JSON Web Key Set.
type JWKS struct {
        Keys []JWK `json:"keys"`
}

// JWK represents a JSON Web Key.
type JWK struct {
        Kty string `json:"kty"` // Key type (RSA)
        E   string `json:"e"`   // Exponent
        N   string `json:"n"`   // Modulus
        Kid string `json:"kid"` // Key ID
        Alg string `json:"alg"` // Algorithm
        Use string `json:"use"` // Usage (sig)
}

// OIDCToken extends Token with OIDC-specific fields.
type OIDCToken struct {
        Token
        IDToken string `json:"id_token,omitempty"`
}

// IDTokenClaims represents the claims in an OIDC ID token.
type IDTokenClaims struct {
        Iss               string `json:"iss"`
        Sub               string `json:"sub"`
        Aud               string `json:"aud"`
        Exp               int64  `json:"exp"`
        Iat               int64  `json:"iat"`
        Nonce             string `json:"nonce,omitempty"`
        PreferredUsername string `json:"preferred_username,omitempty"`
        Email             string `json:"email,omitempty"`
        EmailVerified     bool   `json:"email_verified,omitempty"`
        Picture           string `json:"picture,omitempty"`
        UpdatedAt         int64  `json:"updated_at,omitempty"`
}

// OIDCResponseType represents OIDC response types.
type OIDCResponseType string

const (
        ResponseTypeCode         OIDCResponseType = "code"
        ResponseTypeToken        OIDCResponseType = "token"
        ResponseTypeIDToken      OIDCResponseType = "id_token"
        ResponseTypeTokenIDToken OIDCResponseType = "token id_token"
        ResponseTypeCodeIDToken  OIDCResponseType = "code id_token"
)

// GetOpenIDConfiguration fetches the OIDC discovery document.
func (c *AuthClient) GetOpenIDConfiguration(ctx context.Context) (*OpenIDConfiguration, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, c.openIDConfigURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating OIDC config request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("executing OIDC config request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading OIDC config response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("OIDC config request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var config OpenIDConfiguration
        if err := json.Unmarshal(body, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing OIDC config response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

// GetOIDCAuthorizationURL returns the authorization URL for OIDC flows.
func (c *AuthClient) GetOIDCAuthorizationURL(responseType OIDCResponseType, nonce string, claims map[string]interface{}) (string, error) <span class="cov0" title="0">{
        if c.config.ClientID == "" </span><span class="cov0" title="0">{
                return "", ErrMissingClientID
        }</span>
        <span class="cov0" title="0">if c.config.RedirectURI == "" </span><span class="cov0" title="0">{
                return "", ErrMissingRedirectURI
        }</span>

        <span class="cov0" title="0">scopes := c.config.Scopes
        hasOpenID := false
        for _, s := range scopes </span><span class="cov0" title="0">{
                if s == "openid" </span><span class="cov0" title="0">{
                        hasOpenID = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !hasOpenID </span><span class="cov0" title="0">{
                scopes = append([]string{"openid"}, scopes...)
        }</span>

        <span class="cov0" title="0">params := url.Values{
                "client_id":     {c.config.ClientID},
                "redirect_uri":  {c.config.RedirectURI},
                "response_type": {string(responseType)},
                "scope":         {strings.Join(scopes, " ")},
        }

        if c.config.State != "" </span><span class="cov0" title="0">{
                params.Set("state", c.config.State)
        }</span>
        <span class="cov0" title="0">if c.config.ForceVerify </span><span class="cov0" title="0">{
                params.Set("force_verify", "true")
        }</span>
        <span class="cov0" title="0">if nonce != "" </span><span class="cov0" title="0">{
                params.Set("nonce", nonce)
        }</span>
        <span class="cov0" title="0">if claims != nil </span><span class="cov0" title="0">{
                claimsJSON, err := json.Marshal(claims)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("marshaling claims: %w", err)
                }</span>
                <span class="cov0" title="0">params.Set("claims", string(claimsJSON))</span>
        }

        <span class="cov0" title="0">return AuthorizeEndpoint + "?" + params.Encode(), nil</span>
}

// ExchangeCodeForOIDCToken exchanges an authorization code for an OIDC token.
func (c *AuthClient) ExchangeCodeForOIDCToken(ctx context.Context, code string) (*OIDCToken, error) <span class="cov0" title="0">{
        if c.config.ClientID == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingClientID
        }</span>
        <span class="cov0" title="0">if c.config.ClientSecret == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingClientSecret
        }</span>
        <span class="cov0" title="0">if code == "" </span><span class="cov0" title="0">{
                return nil, ErrMissingCode
        }</span>

        <span class="cov0" title="0">data := url.Values{
                "client_id":     {c.config.ClientID},
                "client_secret": {c.config.ClientSecret},
                "code":          {code},
                "grant_type":    {"authorization_code"},
                "redirect_uri":  {c.config.RedirectURI},
        }

        req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.tokenEndpoint, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating token request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("executing token request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading token response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                var errResp AuthErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("token request failed with status %d: %s", resp.StatusCode, string(body))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("token request failed: %s", errResp.Message)</span>
        }

        <span class="cov0" title="0">var token OIDCToken
        if err := json.Unmarshal(body, &amp;token); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing token response: %w", err)
        }</span>

        <span class="cov0" title="0">token.setExpiry()
        c.SetToken(&amp;token.Token)

        return &amp;token, nil</span>
}

// GetOIDCUserInfo fetches user information from the OIDC UserInfo endpoint.
func (c *AuthClient) GetOIDCUserInfo(ctx context.Context, accessToken string) (*OIDCUserInfo, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, c.userInfoEndpoint, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating userinfo request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+accessToken)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("executing userinfo request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading userinfo response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode == http.StatusUnauthorized </span><span class="cov0" title="0">{
                return nil, ErrInvalidToken
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                var errResp AuthErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("userinfo request failed with status %d: %s", resp.StatusCode, string(body))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("userinfo request failed: %s", errResp.Message)</span>
        }

        <span class="cov0" title="0">var userInfo OIDCUserInfo
        if err := json.Unmarshal(body, &amp;userInfo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing userinfo response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;userInfo, nil</span>
}

// GetCurrentOIDCUserInfo fetches user information using the current access token.
func (c *AuthClient) GetCurrentOIDCUserInfo(ctx context.Context) (*OIDCUserInfo, error) <span class="cov0" title="0">{
        c.mu.RLock()
        if c.token == nil </span><span class="cov0" title="0">{
                c.mu.RUnlock()
                return nil, ErrInvalidToken
        }</span>
        <span class="cov0" title="0">accessToken := c.token.AccessToken
        c.mu.RUnlock()

        return c.GetOIDCUserInfo(ctx, accessToken)</span>
}

// GetJWKS fetches the JSON Web Key Set for validating ID tokens.
func (c *AuthClient) GetJWKS(ctx context.Context) (*JWKS, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, c.jwksEndpoint, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating JWKS request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("executing JWKS request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading JWKS response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("JWKS request failed with status %d: %s", resp.StatusCode, string(body))
        }</span>

        <span class="cov0" title="0">var jwks JWKS
        if err := json.Unmarshal(body, &amp;jwks); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing JWKS response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;jwks, nil</span>
}

// GetKeyByID returns the JWK with the specified key ID.
func (j *JWKS) GetKeyByID(kid string) *JWK <span class="cov0" title="0">{
        for i := range j.Keys </span><span class="cov0" title="0">{
                if j.Keys[i].Kid == kid </span><span class="cov0" title="0">{
                        return &amp;j.Keys[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// RSAPublicKey converts the JWK to an RSA public key.
func (k *JWK) RSAPublicKey() (*rsa.PublicKey, error) <span class="cov0" title="0">{
        if k.Kty != "RSA" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported key type: %s", k.Kty)
        }</span>

        <span class="cov0" title="0">nBytes, err := base64.RawURLEncoding.DecodeString(k.N)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decoding modulus: %w", err)
        }</span>
        <span class="cov0" title="0">n := new(big.Int).SetBytes(nBytes)

        eBytes, err := base64.RawURLEncoding.DecodeString(k.E)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decoding exponent: %w", err)
        }</span>
        <span class="cov0" title="0">e := new(big.Int).SetBytes(eBytes)

        return &amp;rsa.PublicKey{
                N: n,
                E: int(e.Int64()),
        }, nil</span>
}

// IDTokenHeader represents the header of a JWT ID token.
type IDTokenHeader struct {
        Alg string `json:"alg"`
        Typ string `json:"typ"`
        Kid string `json:"kid"`
}

// ParseIDTokenHeader parses the header of an ID token.
func ParseIDTokenHeader(idToken string) (*IDTokenHeader, error) <span class="cov0" title="0">{
        parts := strings.Split(idToken, ".")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid ID token format")
        }</span>

        <span class="cov0" title="0">headerBytes, err := base64.RawURLEncoding.DecodeString(parts[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decoding ID token header: %w", err)
        }</span>

        <span class="cov0" title="0">var header IDTokenHeader
        if err := json.Unmarshal(headerBytes, &amp;header); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing ID token header: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;header, nil</span>
}

// ParseIDToken parses an ID token without validating the signature.
// WARNING: This function does NOT verify the JWT signature. For secure validation,
// use VerifyAndParseIDToken instead.
func ParseIDToken(idToken string) (*IDTokenClaims, error) <span class="cov0" title="0">{
        parts := strings.Split(idToken, ".")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid ID token format")
        }</span>

        <span class="cov0" title="0">payload, err := base64.RawURLEncoding.DecodeString(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decoding ID token payload: %w", err)
        }</span>

        <span class="cov0" title="0">var claims IDTokenClaims
        if err := json.Unmarshal(payload, &amp;claims); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing ID token claims: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;claims, nil</span>
}

// VerifyIDTokenSignature verifies the JWT signature of an ID token using the provided JWKS.
// This is the recommended way to validate ID tokens for security.
func VerifyIDTokenSignature(idToken string, jwks *JWKS) error <span class="cov0" title="0">{
        parts := strings.Split(idToken, ".")
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid ID token format")
        }</span>

        // Parse header to get key ID
        <span class="cov0" title="0">header, err := ParseIDTokenHeader(idToken)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("parsing token header: %w", err)
        }</span>

        // Only RS256 is supported by Twitch
        <span class="cov0" title="0">if header.Alg != "RS256" </span><span class="cov0" title="0">{
                return fmt.Errorf("unsupported signing algorithm: %s", header.Alg)
        }</span>

        // Find the key in JWKS
        <span class="cov0" title="0">jwk := jwks.GetKeyByID(header.Kid)
        if jwk == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("key not found in JWKS: %s", header.Kid)
        }</span>

        // Convert JWK to RSA public key
        <span class="cov0" title="0">pubKey, err := jwk.RSAPublicKey()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("converting JWK to RSA key: %w", err)
        }</span>

        // Decode signature
        <span class="cov0" title="0">signature, err := base64.RawURLEncoding.DecodeString(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("decoding signature: %w", err)
        }</span>

        // Compute hash of header.payload
        <span class="cov0" title="0">signedContent := parts[0] + "." + parts[1]
        hash := sha256.Sum256([]byte(signedContent))

        // Verify signature
        if err := rsa.VerifyPKCS1v15(pubKey, crypto.SHA256, hash[:], signature); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("signature verification failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// VerifyAndParseIDToken verifies the signature and parses an ID token.
// This is the secure way to validate ID tokens - it fetches the JWKS, verifies
// the signature, and then parses the claims.
func (c *AuthClient) VerifyAndParseIDToken(ctx context.Context, idToken string) (*IDTokenClaims, error) <span class="cov0" title="0">{
        // Fetch JWKS
        jwks, err := c.GetJWKS(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("fetching JWKS: %w", err)
        }</span>

        // Verify signature
        <span class="cov0" title="0">if err := VerifyIDTokenSignature(idToken, jwks); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Parse claims (signature already verified)
        <span class="cov0" title="0">claims, err := ParseIDToken(idToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}

// ValidateIDToken performs full validation of an ID token: signature verification,
// issuer, audience, expiry, and optional nonce check.
// This is the recommended method for securely validating OIDC ID tokens.
func (c *AuthClient) ValidateIDToken(ctx context.Context, idToken string, nonce string) (*IDTokenClaims, error) <span class="cov0" title="0">{
        // Verify signature and parse claims
        claims, err := c.VerifyAndParseIDToken(ctx, idToken)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate claims
        <span class="cov0" title="0">if err := c.ValidateIDTokenClaims(claims, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return claims, nil</span>
}

// ValidateIDTokenClaims validates the claims in an ID token.
// WARNING: This only validates claims, not the JWT signature. For secure validation,
// use ValidateIDToken instead which verifies the signature first.
func (c *AuthClient) ValidateIDTokenClaims(claims *IDTokenClaims, nonce string) error <span class="cov0" title="0">{
        if claims.Iss != "https://id.twitch.tv/oauth2" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid issuer: %s", claims.Iss)
        }</span>

        <span class="cov0" title="0">if claims.Aud != c.config.ClientID </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid audience: %s", claims.Aud)
        }</span>

        <span class="cov0" title="0">if time.Now().Unix() &gt; claims.Exp </span><span class="cov0" title="0">{
                return fmt.Errorf("ID token has expired")
        }</span>

        <span class="cov0" title="0">if nonce != "" &amp;&amp; claims.Nonce != nonce </span><span class="cov0" title="0">{
                return fmt.Errorf("nonce mismatch")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ============================================================================
// Scope Constants
// ============================================================================

// Scope constants for Twitch API permissions.
const (
        // Analytics scopes
        ScopeAnalyticsReadExtensions = "analytics:read:extensions"
        ScopeAnalyticsReadGames      = "analytics:read:games"

        // Bits scopes
        ScopeBitsRead = "bits:read"

        // Channel scopes
        ScopeChannelBot               = "channel:bot"
        ScopeChannelEditCommercial    = "channel:edit:commercial"
        ScopeChannelManageAds         = "channel:manage:ads"
        ScopeChannelManageBroadcast   = "channel:manage:broadcast"
        ScopeChannelManageClips       = "channel:manage:clips"
        ScopeChannelManageExtensions  = "channel:manage:extensions"
        ScopeChannelManageModerators  = "channel:manage:moderators"
        ScopeChannelManagePolls       = "channel:manage:polls"
        ScopeChannelManagePredictions = "channel:manage:predictions"
        ScopeChannelManageRaids       = "channel:manage:raids"
        ScopeChannelManageRedemptions = "channel:manage:redemptions"
        ScopeChannelManageSchedule    = "channel:manage:schedule"
        ScopeChannelManageVideos      = "channel:manage:videos"
        ScopeChannelManageVIPs        = "channel:manage:vips"
        ScopeChannelManageGuestStar   = "channel:manage:guest_star"
        ScopeChannelModerate          = "channel:moderate"
        ScopeChannelReadAds           = "channel:read:ads"
        ScopeChannelReadCharity       = "channel:read:charity"
        ScopeChannelReadEditors       = "channel:read:editors"
        ScopeChannelReadGoals         = "channel:read:goals"
        ScopeChannelReadGuestStar     = "channel:read:guest_star"
        ScopeChannelReadHypeTrain     = "channel:read:hype_train"
        ScopeChannelReadPolls         = "channel:read:polls"
        ScopeChannelReadPredictions   = "channel:read:predictions"
        ScopeChannelReadRedemptions   = "channel:read:redemptions"
        ScopeChannelReadStreamKey     = "channel:read:stream_key"
        ScopeChannelReadSubscriptions = "channel:read:subscriptions"
        ScopeChannelReadVIPs          = "channel:read:vips"

        // Chat scopes
        ScopeChatEdit = "chat:edit"
        ScopeChatRead = "chat:read"

        // Clips scopes
        ScopeClipsEdit = "clips:edit"

        // Editor scopes
        ScopeEditorManageClips = "editor:manage:clips"

        // Moderation scopes
        ScopeModerationRead                 = "moderation:read"
        ScopeModeratorManageAnnouncements   = "moderator:manage:announcements"
        ScopeModeratorManageAutomod         = "moderator:manage:automod"
        ScopeModeratorManageAutomodSettings = "moderator:manage:automod_settings"
        ScopeModeratorManageBannedUsers     = "moderator:manage:banned_users"
        ScopeModeratorManageBlockedTerms    = "moderator:manage:blocked_terms"
        ScopeModeratorManageChatMessages    = "moderator:manage:chat_messages"
        ScopeModeratorManageChatSettings    = "moderator:manage:chat_settings"
        ScopeModeratorManageGuestStar       = "moderator:manage:guest_star"
        ScopeModeratorManageShieldMode      = "moderator:manage:shield_mode"
        ScopeModeratorManageShoutouts       = "moderator:manage:shoutouts"
        ScopeModeratorManageWarnings        = "moderator:manage:warnings"
        ScopeModeratorManageUnbanRequests   = "moderator:manage:unban_requests"
        ScopeModeratorReadAutomodSettings   = "moderator:read:automod_settings"
        ScopeModeratorReadBannedUsers       = "moderator:read:banned_users"
        ScopeModeratorReadBlockedTerms      = "moderator:read:blocked_terms"
        ScopeModeratorReadChatMessages      = "moderator:read:chat_messages"
        ScopeModeratorReadChatSettings      = "moderator:read:chat_settings"
        ScopeModeratorReadChatters          = "moderator:read:chatters"
        ScopeModeratorReadFollowers         = "moderator:read:followers"
        ScopeModeratorReadGuestStar         = "moderator:read:guest_star"
        ScopeModeratorReadShieldMode        = "moderator:read:shield_mode"
        ScopeModeratorReadShoutouts         = "moderator:read:shoutouts"
        ScopeModeratorReadSuspiciousUsers   = "moderator:read:suspicious_users"
        ScopeModeratorReadUnbanRequests     = "moderator:read:unban_requests"
        ScopeModeratorReadVIPs              = "moderator:read:vips"
        ScopeModeratorReadWarnings          = "moderator:read:warnings"

        // User scopes
        ScopeUserBot                   = "user:bot"
        ScopeUserEdit                  = "user:edit"
        ScopeUserEditBroadcast         = "user:edit:broadcast"
        ScopeUserManageBlockedUsers    = "user:manage:blocked_users"
        ScopeUserManageChatColor       = "user:manage:chat_color"
        ScopeUserManageWhispers        = "user:manage:whispers"
        ScopeUserReadBlockedUsers      = "user:read:blocked_users"
        ScopeUserReadBroadcast         = "user:read:broadcast"
        ScopeUserReadChat              = "user:read:chat"
        ScopeUserReadEmail             = "user:read:email"
        ScopeUserReadEmotes            = "user:read:emotes"
        ScopeUserReadFollows           = "user:read:follows"
        ScopeUserReadModeratedChannels = "user:read:moderated_channels"
        ScopeUserReadSubscriptions     = "user:read:subscriptions"
        ScopeUserReadWhispers          = "user:read:whispers"
        ScopeUserWriteChat             = "user:write:chat"

        // Whispers scope
        ScopeWhispersRead = "whispers:read"
)

// CommonScopes provides commonly used scope combinations.
var CommonScopes = struct {
        Chat        []string
        Moderation  []string
        Channel     []string
        Bot         []string
        Analytics   []string
        Broadcaster []string
}{
        Chat: []string{
                ScopeChatRead,
                ScopeChatEdit,
                ScopeUserWriteChat,
                ScopeUserReadChat,
        },
        Moderation: []string{
                ScopeModerationRead,
                ScopeModeratorManageBannedUsers,
                ScopeModeratorManageChatMessages,
                ScopeModeratorReadChatters,
                ScopeModeratorManageAnnouncements,
        },
        Channel: []string{
                ScopeChannelManageBroadcast,
                ScopeChannelReadEditors,
                ScopeChannelReadSubscriptions,
                ScopeChannelManagePolls,
                ScopeChannelManagePredictions,
        },
        Bot: []string{
                ScopeChatRead,
                ScopeChatEdit,
                ScopeChannelBot,
                ScopeUserBot,
                ScopeUserWriteChat,
                ScopeUserReadChat,
                ScopeModeratorReadChatters,
        },
        Analytics: []string{
                ScopeAnalyticsReadExtensions,
                ScopeAnalyticsReadGames,
        },
        Broadcaster: []string{
                ScopeChannelManageBroadcast,
                ScopeChannelManagePolls,
                ScopeChannelManagePredictions,
                ScopeChannelManageRaids,
                ScopeChannelManageSchedule,
                ScopeChannelManageVideos,
                ScopeChannelReadEditors,
                ScopeChannelReadGoals,
                ScopeChannelReadHypeTrain,
                ScopeChannelReadPolls,
                ScopeChannelReadPredictions,
                ScopeChannelReadSubscriptions,
                ScopeChannelEditCommercial,
                ScopeModerationRead,
                ScopeModeratorManageBannedUsers,
                ScopeModeratorManageChatMessages,
                ScopeModeratorManageChatSettings,
                ScopeModeratorManageAnnouncements,
                ScopeModeratorReadChatters,
                ScopeClipsEdit,
        },
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package helix

// Badge SetID constants for common Twitch chat badges.
// These constants represent the SetID field in ChatEventBadge and ChatBadge types.
const (
        // BadgeBroadcaster is the badge for the channel owner.
        BadgeBroadcaster = "broadcaster"

        // BadgeModerator is the badge for channel moderators.
        // Note: Users with the Lead Moderator role may display either
        // BadgeModerator or BadgeLeadModerator depending on their preference.
        BadgeModerator = "moderator"

        // BadgeLeadModerator is the badge for Lead Moderators.
        // Lead Moderators have additional privileges to help streamers manage
        // their mod teams. They can choose to display either this badge or
        // the regular moderator badge.
        BadgeLeadModerator = "lead_moderator"

        // BadgeVIP is the badge for channel VIPs.
        BadgeVIP = "vip"

        // BadgeSubscriber is the badge for channel subscribers.
        BadgeSubscriber = "subscriber"

        // BadgeFounder is the badge for channel founders (first subscribers).
        BadgeFounder = "founder"

        // BadgeSubGifter is the badge for users who have gifted subscriptions.
        BadgeSubGifter = "sub-gifter"

        // BadgeBitsLeader is the badge for bits leaderboard leaders.
        BadgeBitsLeader = "bits-leader"

        // BadgeBits is the badge showing bits tier.
        BadgeBits = "bits"

        // BadgePremium is the badge for Twitch Prime/Turbo users.
        BadgePremium = "premium"

        // BadgePartner is the badge for Twitch Partners.
        BadgePartner = "partner"

        // BadgeStaff is the badge for Twitch Staff.
        BadgeStaff = "staff"

        // BadgeAdmin is the badge for Twitch Admins.
        BadgeAdmin = "admin"

        // BadgeGlobalMod is the badge for Twitch Global Moderators.
        BadgeGlobalMod = "global_mod"

        // BadgeArtist is the badge for channel artists.
        BadgeArtist = "artist"

        // BadgeNoAudio is the badge indicating the user has no audio.
        BadgeNoAudio = "no_audio"

        // BadgeNoVideo is the badge indicating the user has no video.
        BadgeNoVideo = "no_video"

        // BadgePredictions is the badge for prediction participation.
        BadgePredictions = "predictions"

        // BadgeHypeTrain is the badge for Hype Train participation.
        BadgeHypeTrain = "hype-train"
)

// ChatEventBadges is a slice of ChatEventBadge with helper methods.
type ChatEventBadges []ChatEventBadge

// HasBadge checks if the badges contain a specific badge SetID.
func (badges ChatEventBadges) HasBadge(setID string) bool <span class="cov0" title="0">{
        for _, badge := range badges </span><span class="cov0" title="0">{
                if badge.SetID == setID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// HasAnyBadge checks if the badges contain any of the specified badge SetIDs.
func (badges ChatEventBadges) HasAnyBadge(setIDs ...string) bool <span class="cov0" title="0">{
        setIDMap := make(map[string]struct{}, len(setIDs))
        for _, id := range setIDs </span><span class="cov0" title="0">{
                setIDMap[id] = struct{}{}
        }</span>
        <span class="cov0" title="0">for _, badge := range badges </span><span class="cov0" title="0">{
                if _, ok := setIDMap[badge.SetID]; ok </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// HasModeratorPrivileges checks if the user has moderator privileges.
// This returns true if the user has either the "moderator" or "lead_moderator" badge.
// Use this method instead of checking only for BadgeModerator to properly support
// Lead Moderators who may display either badge.
func (badges ChatEventBadges) HasModeratorPrivileges() bool <span class="cov0" title="0">{
        return badges.HasAnyBadge(BadgeModerator, BadgeLeadModerator)
}</span>

// HasBroadcasterPrivileges checks if the user is the broadcaster.
func (badges ChatEventBadges) HasBroadcasterPrivileges() bool <span class="cov0" title="0">{
        return badges.HasBadge(BadgeBroadcaster)
}</span>

// HasVIPStatus checks if the user is a VIP.
func (badges ChatEventBadges) HasVIPStatus() bool <span class="cov0" title="0">{
        return badges.HasBadge(BadgeVIP)
}</span>

// IsSubscriber checks if the user is a subscriber.
func (badges ChatEventBadges) IsSubscriber() bool <span class="cov0" title="0">{
        return badges.HasAnyBadge(BadgeSubscriber, BadgeFounder)
}</span>

// IsStaff checks if the user is Twitch staff (staff, admin, or global mod).
func (badges ChatEventBadges) IsStaff() bool <span class="cov0" title="0">{
        return badges.HasAnyBadge(BadgeStaff, BadgeAdmin, BadgeGlobalMod)
}</span>

// GetBadge returns the badge with the specified SetID, or nil if not found.
func (badges ChatEventBadges) GetBadge(setID string) *ChatEventBadge <span class="cov0" title="0">{
        for i := range badges </span><span class="cov0" title="0">{
                if badges[i].SetID == setID </span><span class="cov0" title="0">{
                        return &amp;badges[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ToChatEventBadges converts a []ChatEventBadge to ChatEventBadges for use with helper methods.
func ToChatEventBadges(badges []ChatEventBadge) ChatEventBadges <span class="cov0" title="0">{
        return ChatEventBadges(badges)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package helix

import (
        "context"
        "net/url"
        "sync"
)

// BatchRequest represents a single request in a batch.
type BatchRequest struct {
        Request *Request
        Result  interface{}
}

// BatchResult contains the result of a batch request.
type BatchResult struct {
        Index int
        Error error
}

// BatchOptions configures batch execution behavior.
type BatchOptions struct {
        // MaxConcurrent limits concurrent requests (0 = unlimited)
        MaxConcurrent int
        // StopOnError stops processing remaining requests on first error
        StopOnError bool
}

// DefaultBatchOptions returns default batch options.
func DefaultBatchOptions() BatchOptions <span class="cov0" title="0">{
        return BatchOptions{
                MaxConcurrent: 10,
                StopOnError:   false,
        }
}</span>

// Batch executes multiple requests concurrently with configurable parallelism.
// Results are returned in the same order as the input requests.
func (c *Client) Batch(ctx context.Context, requests []BatchRequest, opts *BatchOptions) []BatchResult <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                defaultOpts := DefaultBatchOptions()
                opts = &amp;defaultOpts
        }</span>

        <span class="cov0" title="0">results := make([]BatchResult, len(requests))

        if len(requests) == 0 </span><span class="cov0" title="0">{
                return results
        }</span>

        // Create semaphore for concurrency control
        <span class="cov0" title="0">var sem chan struct{}
        if opts.MaxConcurrent &gt; 0 </span><span class="cov0" title="0">{
                sem = make(chan struct{}, opts.MaxConcurrent)
        }</span>

        <span class="cov0" title="0">var wg sync.WaitGroup
        var stopMu sync.Mutex
        var resultsMu sync.Mutex
        stopped := false

        for i, req := range requests </span><span class="cov0" title="0">{
                // Check if we should stop
                if opts.StopOnError </span><span class="cov0" title="0">{
                        stopMu.Lock()
                        if stopped </span><span class="cov0" title="0">{
                                stopMu.Unlock()
                                resultsMu.Lock()
                                results[i] = BatchResult{Index: i, Error: context.Canceled}
                                resultsMu.Unlock()
                                continue</span>
                        }
                        <span class="cov0" title="0">stopMu.Unlock()</span>
                }

                // Check context
                <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                        resultsMu.Lock()
                        results[i] = BatchResult{Index: i, Error: ctx.Err()}
                        resultsMu.Unlock()
                        continue</span>
                }

                // Acquire semaphore
                <span class="cov0" title="0">if sem != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                resultsMu.Lock()
                                results[i] = BatchResult{Index: i, Error: ctx.Err()}
                                resultsMu.Unlock()
                                continue</span>
                        }
                }

                <span class="cov0" title="0">wg.Add(1)
                go func(idx int, batchReq BatchRequest) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if sem != nil </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{ &lt;-sem }</span>()
                        }

                        <span class="cov0" title="0">err := c.Do(ctx, batchReq.Request, batchReq.Result)

                        resultsMu.Lock()
                        results[idx] = BatchResult{Index: idx, Error: err}
                        resultsMu.Unlock()

                        if err != nil &amp;&amp; opts.StopOnError </span><span class="cov0" title="0">{
                                stopMu.Lock()
                                stopped = true
                                stopMu.Unlock()
                        }</span>
                }(i, req)
        }

        <span class="cov0" title="0">wg.Wait()
        return results</span>
}

// BatchGet executes multiple GET requests concurrently.
func (c *Client) BatchGet(ctx context.Context, requests []GetRequest, opts *BatchOptions) []BatchResult <span class="cov0" title="0">{
        batchRequests := make([]BatchRequest, len(requests))
        for i, req := range requests </span><span class="cov0" title="0">{
                batchRequests[i] = BatchRequest{
                        Request: &amp;Request{
                                Method:   "GET",
                                Endpoint: req.Endpoint,
                                Query:    req.Query,
                        },
                        Result: req.Result,
                }
        }</span>
        <span class="cov0" title="0">return c.Batch(ctx, batchRequests, opts)</span>
}

// GetRequest represents a GET request for batch operations.
type GetRequest struct {
        Endpoint string
        Query    url.Values
        Result   interface{}
}

// BatchSequential executes requests sequentially, useful when order matters
// or when you want to stop on first error without race conditions.
func (c *Client) BatchSequential(ctx context.Context, requests []BatchRequest) []BatchResult <span class="cov0" title="0">{
        results := make([]BatchResult, len(requests))

        for i, req := range requests </span><span class="cov0" title="0">{
                if ctx.Err() != nil </span><span class="cov0" title="0">{
                        results[i] = BatchResult{Index: i, Error: ctx.Err()}
                        continue</span>
                }

                <span class="cov0" title="0">err := c.Do(ctx, req.Request, req.Result)
                results[i] = BatchResult{Index: i, Error: err}</span>
        }

        <span class="cov0" title="0">return results</span>
}

// BatchWithCallback executes requests and calls the callback for each result.
// This is useful for processing results as they complete.
// Note: The callback is serialized with a mutex to prevent concurrent calls.
// If the callback panics, the panic is recovered and the goroutine continues.
func (c *Client) BatchWithCallback(ctx context.Context, requests []BatchRequest, opts *BatchOptions, callback func(BatchResult)) <span class="cov0" title="0">{
        if opts == nil </span><span class="cov0" title="0">{
                defaultOpts := DefaultBatchOptions()
                opts = &amp;defaultOpts
        }</span>

        <span class="cov0" title="0">if len(requests) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var sem chan struct{}
        if opts.MaxConcurrent &gt; 0 </span><span class="cov0" title="0">{
                sem = make(chan struct{}, opts.MaxConcurrent)
        }</span>

        <span class="cov0" title="0">var wg sync.WaitGroup
        var stopMu sync.Mutex
        stopped := false
        var callbackMu sync.Mutex

        // safeCallback calls the callback with panic recovery to prevent deadlock
        safeCallback := func(result BatchResult) </span><span class="cov0" title="0">{
                callbackMu.Lock()
                defer callbackMu.Unlock()
                defer func() </span><span class="cov0" title="0">{ _ = recover() }</span>()
                <span class="cov0" title="0">callback(result)</span>
        }

        <span class="cov0" title="0">for i, req := range requests </span><span class="cov0" title="0">{
                if opts.StopOnError </span><span class="cov0" title="0">{
                        stopMu.Lock()
                        shouldStop := stopped
                        stopMu.Unlock()
                        if shouldStop </span><span class="cov0" title="0">{
                                safeCallback(BatchResult{Index: i, Error: context.Canceled})
                                continue</span>
                        }
                }

                <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                        safeCallback(BatchResult{Index: i, Error: ctx.Err()})
                        continue</span>
                }

                <span class="cov0" title="0">if sem != nil </span><span class="cov0" title="0">{
                        select </span>{
                        case sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                safeCallback(BatchResult{Index: i, Error: ctx.Err()})
                                continue</span>
                        }
                }

                <span class="cov0" title="0">wg.Add(1)
                go func(idx int, batchReq BatchRequest) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if sem != nil </span><span class="cov0" title="0">{
                                defer func() </span><span class="cov0" title="0">{ &lt;-sem }</span>()
                        }

                        <span class="cov0" title="0">err := c.Do(ctx, batchReq.Request, batchReq.Result)
                        result := BatchResult{Index: idx, Error: err}

                        safeCallback(result)

                        if err != nil &amp;&amp; opts.StopOnError </span><span class="cov0" title="0">{
                                stopMu.Lock()
                                stopped = true
                                stopMu.Unlock()
                        }</span>
                }(i, req)
        }

        <span class="cov0" title="0">wg.Wait()</span>
}

// HasErrors returns true if any batch result contains an error.
func HasErrors(results []BatchResult) bool <span class="cov0" title="0">{
        for _, r := range results </span><span class="cov0" title="0">{
                if r.Error != nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// FirstError returns the first error from batch results, or nil if none.
func FirstError(results []BatchResult) error <span class="cov0" title="0">{
        for _, r := range results </span><span class="cov0" title="0">{
                if r.Error != nil </span><span class="cov0" title="0">{
                        return r.Error
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Errors returns all errors from batch results.
func Errors(results []BatchResult) []error <span class="cov0" title="0">{
        var errs []error
        for _, r := range results </span><span class="cov0" title="0">{
                if r.Error != nil </span><span class="cov0" title="0">{
                        errs = append(errs, r.Error)
                }</span>
        }
        <span class="cov0" title="0">return errs</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// BitsLeaderboard represents a bits leaderboard entry.
type BitsLeaderboard struct {
        UserID    string `json:"user_id"`
        UserLogin string `json:"user_login"`
        UserName  string `json:"user_name"`
        Rank      int    `json:"rank"`
        Score     int    `json:"score"`
}

// BitsLeaderboardResponse represents the response from GetBitsLeaderboard.
type BitsLeaderboardResponse struct {
        Data      []BitsLeaderboard `json:"data"`
        DateRange DateRange         `json:"date_range"`
        Total     int               `json:"total"`
}

// DateRange represents a date range.
type DateRange struct {
        StartedAt time.Time `json:"started_at"`
        EndedAt   time.Time `json:"ended_at"`
}

// GetBitsLeaderboardParams contains parameters for GetBitsLeaderboard.
type GetBitsLeaderboardParams struct {
        Count     int       // Max entries (1-100)
        Period    string    // day, week, month, year, all
        StartedAt time.Time // Start of the date range
        UserID    string    // Filter to specific user
}

// GetBitsLeaderboard gets the bits leaderboard for a channel.
// Requires: bits:read scope.
func (c *Client) GetBitsLeaderboard(ctx context.Context, params *GetBitsLeaderboardParams) (*BitsLeaderboardResponse, error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil </span><span class="cov0" title="0">{
                if params.Count &gt; 0 </span><span class="cov0" title="0">{
                        q.Set("count", url.QueryEscape(string(rune(params.Count))))
                }</span>
                <span class="cov0" title="0">if params.Period != "" </span><span class="cov0" title="0">{
                        q.Set("period", params.Period)
                }</span>
                <span class="cov0" title="0">if !params.StartedAt.IsZero() </span><span class="cov0" title="0">{
                        q.Set("started_at", params.StartedAt.Format(time.RFC3339))
                }</span>
                <span class="cov0" title="0">if params.UserID != "" </span><span class="cov0" title="0">{
                        q.Set("user_id", params.UserID)
                }</span>
        }

        <span class="cov0" title="0">var resp BitsLeaderboardResponse
        if err := c.get(ctx, "/bits/leaderboard", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// Cheermote represents a cheermote.
type Cheermote struct {
        Prefix       string          `json:"prefix"`
        Tiers        []CheermoteTier `json:"tiers"`
        Type         string          `json:"type"`
        Order        int             `json:"order"`
        LastUpdated  time.Time       `json:"last_updated"`
        IsCharitable bool            `json:"is_charitable"`
}

// CheermoteTier represents a tier of a cheermote.
type CheermoteTier struct {
        MinBits        int             `json:"min_bits"`
        ID             string          `json:"id"`
        Color          string          `json:"color"`
        Images         CheermoteImages `json:"images"`
        CanCheer       bool            `json:"can_cheer"`
        ShowInBitsCard bool            `json:"show_in_bits_card"`
}

// CheermoteImages contains the images for a cheermote tier.
type CheermoteImages struct {
        Dark  CheermoteTheme `json:"dark"`
        Light CheermoteTheme `json:"light"`
}

// CheermoteTheme contains themed cheermote images.
type CheermoteTheme struct {
        Animated map[string]string `json:"animated"`
        Static   map[string]string `json:"static"`
}

// GetCheermotes gets the cheermotes available to a broadcaster.
func (c *Client) GetCheermotes(ctx context.Context, broadcasterID string) (*Response[Cheermote], error) <span class="cov0" title="0">{
        q := url.Values{}
        if broadcasterID != "" </span><span class="cov0" title="0">{
                q.Set("broadcaster_id", broadcasterID)
        }</span>

        <span class="cov0" title="0">var resp Response[Cheermote]
        if err := c.get(ctx, "/bits/cheermotes", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package helix

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "sync"
        "time"
)

// Cache is an interface for caching API responses.
type Cache interface {
        // Get retrieves a cached response. Returns nil if not found or expired.
        Get(ctx context.Context, key string) []byte
        // Set stores a response in the cache with the given TTL.
        Set(ctx context.Context, key string, value []byte, ttl time.Duration)
        // Delete removes a cached response.
        Delete(ctx context.Context, key string)
        // Clear removes all cached responses.
        Clear(ctx context.Context)
}

// MemoryCache is an in-memory cache implementation.
type MemoryCache struct {
        mu      sync.RWMutex
        entries map[string]*cacheEntry
        maxSize int // Maximum number of entries (0 = unlimited)
}

type cacheEntry struct {
        value     []byte
        expiresAt time.Time
}

// NewMemoryCache creates a new in-memory cache.
func NewMemoryCache(maxSize int) *MemoryCache <span class="cov0" title="0">{
        return &amp;MemoryCache{
                entries: make(map[string]*cacheEntry),
                maxSize: maxSize,
        }
}</span>

// Get retrieves a cached response.
func (c *MemoryCache) Get(ctx context.Context, key string) []byte <span class="cov0" title="0">{
        c.mu.RLock()
        entry, ok := c.entries[key]
        c.mu.RUnlock()

        if !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if time.Now().After(entry.expiresAt) </span><span class="cov0" title="0">{
                c.Delete(ctx, key)
                return nil
        }</span>

        <span class="cov0" title="0">return entry.value</span>
}

// Set stores a response in the cache.
func (c *MemoryCache) Set(ctx context.Context, key string, value []byte, ttl time.Duration) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Evict expired entries if at max size
        if c.maxSize &gt; 0 &amp;&amp; len(c.entries) &gt;= c.maxSize </span><span class="cov0" title="0">{
                c.evictExpired()
                // If still at max, evict oldest
                if len(c.entries) &gt;= c.maxSize </span><span class="cov0" title="0">{
                        c.evictOldest()
                }</span>
        }

        <span class="cov0" title="0">c.entries[key] = &amp;cacheEntry{
                value:     value,
                expiresAt: time.Now().Add(ttl),
        }</span>
}

// Delete removes a cached response.
func (c *MemoryCache) Delete(ctx context.Context, key string) <span class="cov0" title="0">{
        c.mu.Lock()
        delete(c.entries, key)
        c.mu.Unlock()
}</span>

// Clear removes all cached responses.
func (c *MemoryCache) Clear(ctx context.Context) <span class="cov0" title="0">{
        c.mu.Lock()
        c.entries = make(map[string]*cacheEntry)
        c.mu.Unlock()
}</span>

// evictExpired removes all expired entries (must be called with lock held).
// Note: Deleting from a map during iteration is safe in Go when done in the same goroutine.
func (c *MemoryCache) evictExpired() <span class="cov0" title="0">{
        now := time.Now()
        for key, entry := range c.entries </span><span class="cov0" title="0">{
                if now.After(entry.expiresAt) </span><span class="cov0" title="0">{
                        delete(c.entries, key)
                }</span>
        }
}

// evictOldest removes the oldest entry (must be called with lock held).
func (c *MemoryCache) evictOldest() <span class="cov0" title="0">{
        var oldestKey string
        var oldestTime time.Time

        for key, entry := range c.entries </span><span class="cov0" title="0">{
                if oldestKey == "" || entry.expiresAt.Before(oldestTime) </span><span class="cov0" title="0">{
                        oldestKey = key
                        oldestTime = entry.expiresAt
                }</span>
        }

        <span class="cov0" title="0">if oldestKey != "" </span><span class="cov0" title="0">{
                delete(c.entries, oldestKey)
        }</span>
}

// Size returns the number of entries in the cache.
func (c *MemoryCache) Size() int <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return len(c.entries)
}</span>

// CacheKey generates a cache key from a request.
func CacheKey(endpoint string, query string) string <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(endpoint + "?" + query))
        return hex.EncodeToString(hash[:])
}</span>

// WithCache sets a cache for the client.
func WithCache(cache Cache, ttl time.Duration) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.cache = cache
                c.cacheTTL = ttl
                c.cacheEnabled = true
        }</span>
}

// WithCacheEnabled enables or disables caching.
func WithCacheEnabled(enabled bool) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.cacheEnabled = enabled
        }</span>
}

// ClearCache clears all cached responses.
func (c *Client) ClearCache(ctx context.Context) <span class="cov0" title="0">{
        if c.cache != nil </span><span class="cov0" title="0">{
                c.cache.Clear(ctx)
        }</span>
}

// InvalidateCache removes a specific cached response.
func (c *Client) InvalidateCache(ctx context.Context, endpoint string, query string) <span class="cov0" title="0">{
        if c.cache != nil </span><span class="cov0" title="0">{
                c.cache.Delete(ctx, CacheKey(endpoint, query))
        }</span>
}

// NoCacheContext returns a context that bypasses the cache for a single request.
func NoCacheContext(ctx context.Context) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, noCacheKey{}, true)
}</span>

type noCacheKey struct{}

func shouldSkipCache(ctx context.Context) bool <span class="cov0" title="0">{
        if v, ok := ctx.Value(noCacheKey{}).(bool); ok </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package helix

import (
        "context"
        "net/url"
)

// ContentClassificationLabel represents a content classification label.
type ContentClassificationLabel struct {
        ID          string `json:"id"`
        Description string `json:"description"`
        Name        string `json:"name"`
}

// GetContentClassificationLabelsParams contains parameters for GetContentClassificationLabels.
type GetContentClassificationLabelsParams struct {
        Locale string // Locale for the labels (e.g., "en-US")
}

// GetContentClassificationLabels gets the list of content classification labels.
func (c *Client) GetContentClassificationLabels(ctx context.Context, params *GetContentClassificationLabelsParams) (*Response[ContentClassificationLabel], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil &amp;&amp; params.Locale != "" </span><span class="cov0" title="0">{
                q.Set("locale", params.Locale)
        }</span>

        <span class="cov0" title="0">var resp Response[ContentClassificationLabel]
        if err := c.get(ctx, "/content_classification_labels", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// CustomReward represents a channel points custom reward.
type CustomReward struct {
        BroadcasterID                     string              `json:"broadcaster_id"`
        BroadcasterLogin                  string              `json:"broadcaster_login"`
        BroadcasterName                   string              `json:"broadcaster_name"`
        ID                                string              `json:"id"`
        Title                             string              `json:"title"`
        Prompt                            string              `json:"prompt"`
        Cost                              int                 `json:"cost"`
        Image                             *RewardImage        `json:"image,omitempty"`
        DefaultImage                      RewardImage         `json:"default_image"`
        BackgroundColor                   string              `json:"background_color"`
        IsEnabled                         bool                `json:"is_enabled"`
        IsUserInputRequired               bool                `json:"is_user_input_required"`
        MaxPerStreamSetting               MaxPerStream        `json:"max_per_stream_setting"`
        MaxPerUserPerStreamSetting        MaxPerUserPerStream `json:"max_per_user_per_stream_setting"`
        GlobalCooldownSetting             GlobalCooldown      `json:"global_cooldown_setting"`
        IsPaused                          bool                `json:"is_paused"`
        IsInStock                         bool                `json:"is_in_stock"`
        ShouldRedemptionsSkipRequestQueue bool                `json:"should_redemptions_skip_request_queue"`
        RedemptionsRedeemedCurrentStream  int                 `json:"redemptions_redeemed_current_stream,omitempty"`
        CooldownExpiresAt                 *time.Time          `json:"cooldown_expires_at,omitempty"`
}

// RewardImage represents images for a reward.
type RewardImage struct {
        URL1x string `json:"url_1x"`
        URL2x string `json:"url_2x"`
        URL4x string `json:"url_4x"`
}

// MaxPerStream represents max per stream settings.
type MaxPerStream struct {
        IsEnabled    bool `json:"is_enabled"`
        MaxPerStream int  `json:"max_per_stream"`
}

// MaxPerUserPerStream represents max per user per stream settings.
type MaxPerUserPerStream struct {
        IsEnabled           bool `json:"is_enabled"`
        MaxPerUserPerStream int  `json:"max_per_user_per_stream"`
}

// GlobalCooldown represents global cooldown settings.
type GlobalCooldown struct {
        IsEnabled             bool `json:"is_enabled"`
        GlobalCooldownSeconds int  `json:"global_cooldown_seconds"`
}

// GetCustomRewardsParams contains parameters for GetCustomRewards.
type GetCustomRewardsParams struct {
        BroadcasterID         string
        IDs                   []string // Reward IDs (max 50)
        OnlyManageableRewards bool
}

// GetCustomRewards gets custom rewards for a channel.
// Requires: channel:read:redemptions or channel:manage:redemptions scope.
func (c *Client) GetCustomRewards(ctx context.Context, params *GetCustomRewardsParams) (*Response[CustomReward], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        for _, id := range params.IDs </span><span class="cov0" title="0">{
                q.Add("id", id)
        }</span>
        <span class="cov0" title="0">if params.OnlyManageableRewards </span><span class="cov0" title="0">{
                q.Set("only_manageable_rewards", "true")
        }</span>

        <span class="cov0" title="0">var resp Response[CustomReward]
        if err := c.get(ctx, "/channel_points/custom_rewards", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// CreateCustomRewardParams contains parameters for CreateCustomReward.
type CreateCustomRewardParams struct {
        BroadcasterID                     string `json:"-"`
        Title                             string `json:"title"`
        Cost                              int    `json:"cost"`
        Prompt                            string `json:"prompt,omitempty"`
        IsEnabled                         *bool  `json:"is_enabled,omitempty"`
        BackgroundColor                   string `json:"background_color,omitempty"`
        IsUserInputRequired               *bool  `json:"is_user_input_required,omitempty"`
        IsMaxPerStreamEnabled             *bool  `json:"is_max_per_stream_enabled,omitempty"`
        MaxPerStream                      *int   `json:"max_per_stream,omitempty"`
        IsMaxPerUserPerStreamEnabled      *bool  `json:"is_max_per_user_per_stream_enabled,omitempty"`
        MaxPerUserPerStream               *int   `json:"max_per_user_per_stream,omitempty"`
        IsGlobalCooldownEnabled           *bool  `json:"is_global_cooldown_enabled,omitempty"`
        GlobalCooldownSeconds             *int   `json:"global_cooldown_seconds,omitempty"`
        ShouldRedemptionsSkipRequestQueue *bool  `json:"should_redemptions_skip_request_queue,omitempty"`
}

// CreateCustomReward creates a custom reward.
// Requires: channel:manage:redemptions scope.
func (c *Client) CreateCustomReward(ctx context.Context, params *CreateCustomRewardParams) (*CustomReward, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)

        var resp Response[CustomReward]
        if err := c.post(ctx, "/channel_points/custom_rewards", q, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// UpdateCustomRewardParams contains parameters for UpdateCustomReward.
type UpdateCustomRewardParams struct {
        BroadcasterID                     string `json:"-"`
        ID                                string `json:"-"`
        Title                             string `json:"title,omitempty"`
        Cost                              *int   `json:"cost,omitempty"`
        Prompt                            string `json:"prompt,omitempty"`
        IsEnabled                         *bool  `json:"is_enabled,omitempty"`
        BackgroundColor                   string `json:"background_color,omitempty"`
        IsUserInputRequired               *bool  `json:"is_user_input_required,omitempty"`
        IsMaxPerStreamEnabled             *bool  `json:"is_max_per_stream_enabled,omitempty"`
        MaxPerStream                      *int   `json:"max_per_stream,omitempty"`
        IsMaxPerUserPerStreamEnabled      *bool  `json:"is_max_per_user_per_stream_enabled,omitempty"`
        MaxPerUserPerStream               *int   `json:"max_per_user_per_stream,omitempty"`
        IsGlobalCooldownEnabled           *bool  `json:"is_global_cooldown_enabled,omitempty"`
        GlobalCooldownSeconds             *int   `json:"global_cooldown_seconds,omitempty"`
        ShouldRedemptionsSkipRequestQueue *bool  `json:"should_redemptions_skip_request_queue,omitempty"`
        IsPaused                          *bool  `json:"is_paused,omitempty"`
}

// UpdateCustomReward updates a custom reward.
// Requires: channel:manage:redemptions scope.
func (c *Client) UpdateCustomReward(ctx context.Context, params *UpdateCustomRewardParams) (*CustomReward, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("id", params.ID)

        var resp Response[CustomReward]
        if err := c.patch(ctx, "/channel_points/custom_rewards", q, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// DeleteCustomReward deletes a custom reward.
// Requires: channel:manage:redemptions scope.
func (c *Client) DeleteCustomReward(ctx context.Context, broadcasterID, rewardID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("id", rewardID)

        return c.delete(ctx, "/channel_points/custom_rewards", q, nil)
}</span>

// CustomRewardRedemption represents a redemption of a custom reward.
type CustomRewardRedemption struct {
        BroadcasterID    string    `json:"broadcaster_id"`
        BroadcasterLogin string    `json:"broadcaster_login"`
        BroadcasterName  string    `json:"broadcaster_name"`
        ID               string    `json:"id"`
        UserID           string    `json:"user_id"`
        UserLogin        string    `json:"user_login"`
        UserName         string    `json:"user_name"`
        UserInput        string    `json:"user_input"`
        Status           string    `json:"status"` // CANCELED, FULFILLED, UNFULFILLED
        RedeemedAt       time.Time `json:"redeemed_at"`
        Reward           struct {
                ID     string `json:"id"`
                Title  string `json:"title"`
                Prompt string `json:"prompt"`
                Cost   int    `json:"cost"`
        } `json:"reward"`
}

// GetCustomRewardRedemptionsParams contains parameters for GetCustomRewardRedemptions.
type GetCustomRewardRedemptionsParams struct {
        BroadcasterID string
        RewardID      string
        Status        string // CANCELED, FULFILLED, UNFULFILLED
        IDs           []string
        Sort          string // OLDEST, NEWEST
        *PaginationParams
}

// GetCustomRewardRedemptions gets redemptions for a custom reward.
// Requires: channel:read:redemptions or channel:manage:redemptions scope.
func (c *Client) GetCustomRewardRedemptions(ctx context.Context, params *GetCustomRewardRedemptionsParams) (*Response[CustomRewardRedemption], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("reward_id", params.RewardID)
        if params.Status != "" </span><span class="cov0" title="0">{
                q.Set("status", params.Status)
        }</span>
        <span class="cov0" title="0">for _, id := range params.IDs </span><span class="cov0" title="0">{
                q.Add("id", id)
        }</span>
        <span class="cov0" title="0">if params.Sort != "" </span><span class="cov0" title="0">{
                q.Set("sort", params.Sort)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[CustomRewardRedemption]
        if err := c.get(ctx, "/channel_points/custom_rewards/redemptions", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// UpdateRedemptionStatusParams contains parameters for UpdateRedemptionStatus.
type UpdateRedemptionStatusParams struct {
        BroadcasterID string   `json:"-"`
        RewardID      string   `json:"-"`
        IDs           []string `json:"-"`      // Redemption IDs (max 50)
        Status        string   `json:"status"` // CANCELED or FULFILLED
}

// UpdateRedemptionStatus updates the status of custom reward redemptions.
// Requires: channel:manage:redemptions scope.
func (c *Client) UpdateRedemptionStatus(ctx context.Context, params *UpdateRedemptionStatusParams) (*Response[CustomRewardRedemption], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("reward_id", params.RewardID)
        for _, id := range params.IDs </span><span class="cov0" title="0">{
                q.Add("id", id)
        }</span>

        <span class="cov0" title="0">var resp Response[CustomRewardRedemption]
        if err := c.patch(ctx, "/channel_points/custom_rewards/redemptions", q, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// Channel represents a Twitch channel.
type Channel struct {
        BroadcasterID               string   `json:"broadcaster_id"`
        BroadcasterLogin            string   `json:"broadcaster_login"`
        BroadcasterName             string   `json:"broadcaster_name"`
        BroadcasterLanguage         string   `json:"broadcaster_language"`
        GameID                      string   `json:"game_id"`
        GameName                    string   `json:"game_name"`
        Title                       string   `json:"title"`
        Delay                       int      `json:"delay"`
        Tags                        []string `json:"tags"`
        ContentClassificationLabels []string `json:"content_classification_labels"`
        IsBrandedContent            bool     `json:"is_branded_content"`
}

// GetChannelInformationParams contains parameters for GetChannelInformation.
type GetChannelInformationParams struct {
        BroadcasterIDs []string // Up to 100 broadcaster IDs
}

// GetChannelInformation gets channel information for one or more users.
func (c *Client) GetChannelInformation(ctx context.Context, params *GetChannelInformationParams) (*Response[Channel], error) <span class="cov0" title="0">{
        q := url.Values{}
        for _, id := range params.BroadcasterIDs </span><span class="cov0" title="0">{
                q.Add("broadcaster_id", id)
        }</span>

        <span class="cov0" title="0">var resp Response[Channel]
        if err := c.get(ctx, "/channels", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ModifyChannelInformationParams contains parameters for ModifyChannelInformation.
type ModifyChannelInformationParams struct {
        BroadcasterID               string                              `json:"-"`
        GameID                      string                              `json:"game_id,omitempty"`
        BroadcasterLanguage         string                              `json:"broadcaster_language,omitempty"`
        Title                       string                              `json:"title,omitempty"`
        Delay                       *int                                `json:"delay,omitempty"`
        Tags                        []string                            `json:"tags,omitempty"`
        ContentClassificationLabels []ContentClassificationLabelSetting `json:"content_classification_labels,omitempty"`
        IsBrandedContent            *bool                               `json:"is_branded_content,omitempty"`
}

// ContentClassificationLabelSetting represents a content classification label setting for modifying a channel.
type ContentClassificationLabelSetting struct {
        ID        string `json:"id"`
        IsEnabled bool   `json:"is_enabled"`
}

// ModifyChannelInformation modifies channel information.
// Requires: channel:manage:broadcast scope.
func (c *Client) ModifyChannelInformation(ctx context.Context, params *ModifyChannelInformationParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)

        return c.patch(ctx, "/channels", q, params, nil)
}</span>

// ChannelEditor represents a channel editor.
type ChannelEditor struct {
        UserID    string    `json:"user_id"`
        UserName  string    `json:"user_name"`
        CreatedAt time.Time `json:"created_at"`
}

// GetChannelEditors gets the list of channel editors.
// Requires: channel:read:editors scope.
func (c *Client) GetChannelEditors(ctx context.Context, broadcasterID string) (*Response[ChannelEditor], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[ChannelEditor]
        if err := c.get(ctx, "/channels/editors", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// FollowedChannel represents a channel that a user follows.
type FollowedChannel struct {
        BroadcasterID    string    `json:"broadcaster_id"`
        BroadcasterLogin string    `json:"broadcaster_login"`
        BroadcasterName  string    `json:"broadcaster_name"`
        FollowedAt       time.Time `json:"followed_at"`
}

// GetFollowedChannelsParams contains parameters for GetFollowedChannels.
type GetFollowedChannelsParams struct {
        UserID        string // Required: The user's ID
        BroadcasterID string // Optional: Filter by broadcaster ID
        *PaginationParams
}

// GetFollowedChannels gets the list of channels that a user follows.
// Requires: user:read:follows scope.
func (c *Client) GetFollowedChannels(ctx context.Context, params *GetFollowedChannelsParams) (*Response[FollowedChannel], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("user_id", params.UserID)
        if params.BroadcasterID != "" </span><span class="cov0" title="0">{
                q.Set("broadcaster_id", params.BroadcasterID)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[FollowedChannel]
        if err := c.get(ctx, "/channels/followed", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ChannelFollower represents a user who follows a channel.
type ChannelFollower struct {
        UserID     string    `json:"user_id"`
        UserLogin  string    `json:"user_login"`
        UserName   string    `json:"user_name"`
        FollowedAt time.Time `json:"followed_at"`
}

// GetChannelFollowersParams contains parameters for GetChannelFollowers.
type GetChannelFollowersParams struct {
        BroadcasterID string // Required: The broadcaster's ID
        UserID        string // Optional: Filter by user ID
        *PaginationParams
}

// GetChannelFollowers gets the list of users that follow a channel.
// Requires: moderator:read:followers scope.
func (c *Client) GetChannelFollowers(ctx context.Context, params *GetChannelFollowersParams) (*Response[ChannelFollower], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        if params.UserID != "" </span><span class="cov0" title="0">{
                q.Set("user_id", params.UserID)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[ChannelFollower]
        if err := c.get(ctx, "/channels/followers", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// VIP represents a VIP user in a channel.
type VIP struct {
        UserID    string `json:"user_id"`
        UserLogin string `json:"user_login"`
        UserName  string `json:"user_name"`
}

// GetVIPsParams contains parameters for GetVIPs.
type GetVIPsParams struct {
        BroadcasterID string
        UserIDs       []string // Filter by user IDs (max 100)
        *PaginationParams
}

// GetVIPs gets the list of VIPs for a channel.
// Requires: channel:read:vips scope.
func (c *Client) GetVIPs(ctx context.Context, params *GetVIPsParams) (*Response[VIP], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        for _, id := range params.UserIDs </span><span class="cov0" title="0">{
                q.Add("user_id", id)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[VIP]
        if err := c.get(ctx, "/channels/vips", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// AddChannelVIP adds a VIP to the channel.
// Requires: channel:manage:vips scope.
func (c *Client) AddChannelVIP(ctx context.Context, broadcasterID, userID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("user_id", userID)

        return c.post(ctx, "/channels/vips", q, nil, nil)
}</span>

// RemoveChannelVIP removes a VIP from the channel.
// Requires: channel:manage:vips scope.
func (c *Client) RemoveChannelVIP(ctx context.Context, broadcasterID, userID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("user_id", userID)

        return c.delete(ctx, "/channels/vips", q, nil)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package helix

import (
        "context"
        "net/url"
)

// CharityCampaign represents a charity campaign.
type CharityCampaign struct {
        ID                 string        `json:"id"`
        BroadcasterID      string        `json:"broadcaster_id"`
        BroadcasterLogin   string        `json:"broadcaster_login"`
        BroadcasterName    string        `json:"broadcaster_name"`
        CharityName        string        `json:"charity_name"`
        CharityDescription string        `json:"charity_description"`
        CharityLogo        string        `json:"charity_logo"`
        CharityWebsite     string        `json:"charity_website"`
        CurrentAmount      CharityAmount `json:"current_amount"`
        TargetAmount       CharityAmount `json:"target_amount"`
}

// CharityAmount represents a monetary amount for charity.
type CharityAmount struct {
        Value         int    `json:"value"`
        DecimalPlaces int    `json:"decimal_places"`
        Currency      string `json:"currency"`
}

// GetCharityCampaign gets the active charity campaign for a channel.
// Requires: channel:read:charity scope.
func (c *Client) GetCharityCampaign(ctx context.Context, broadcasterID string) (*CharityCampaign, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[CharityCampaign]
        if err := c.get(ctx, "/charity/campaigns", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// CharityDonation represents a donation to a charity campaign.
type CharityDonation struct {
        ID         string        `json:"id"`
        CampaignID string        `json:"campaign_id"`
        UserID     string        `json:"user_id"`
        UserLogin  string        `json:"user_login"`
        UserName   string        `json:"user_name"`
        Amount     CharityAmount `json:"amount"`
}

// GetCharityDonationsParams contains parameters for GetCharityDonations.
type GetCharityDonationsParams struct {
        BroadcasterID string
        *PaginationParams
}

// GetCharityDonations gets the donations for a charity campaign.
// Requires: channel:read:charity scope.
func (c *Client) GetCharityDonations(ctx context.Context, params *GetCharityDonationsParams) (*Response[CharityDonation], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        addPaginationParams(q, params.PaginationParams)

        var resp Response[CharityDonation]
        if err := c.get(ctx, "/charity/donations", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package helix

import (
        "context"
        "net/url"
)

// Chatter represents a user in a channel's chat.
type Chatter struct {
        UserID    string `json:"user_id"`
        UserLogin string `json:"user_login"`
        UserName  string `json:"user_name"`
}

// GetChattersParams contains parameters for GetChatters.
type GetChattersParams struct {
        BroadcasterID string
        ModeratorID   string
        *PaginationParams
}

// GetChatters gets the list of users in a channel's chat.
// Requires: moderator:read:chatters scope.
func (c *Client) GetChatters(ctx context.Context, params *GetChattersParams) (*Response[Chatter], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)
        addPaginationParams(q, params.PaginationParams)

        var resp Response[Chatter]
        if err := c.get(ctx, "/chat/chatters", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// Emote represents a Twitch emote.
type Emote struct {
        ID         string      `json:"id"`
        Name       string      `json:"name"`
        Images     EmoteImages `json:"images"`
        Tier       string      `json:"tier,omitempty"`
        EmoteType  string      `json:"emote_type,omitempty"`
        EmoteSetID string      `json:"emote_set_id,omitempty"`
        Format     []string    `json:"format"`
        Scale      []string    `json:"scale"`
        ThemeMode  []string    `json:"theme_mode"`
}

// EmoteImages contains emote image URLs.
type EmoteImages struct {
        URL1x string `json:"url_1x"`
        URL2x string `json:"url_2x"`
        URL4x string `json:"url_4x"`
}

// GetChannelEmotes gets the emotes for a channel.
func (c *Client) GetChannelEmotes(ctx context.Context, broadcasterID string) (*Response[Emote], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[Emote]
        if err := c.get(ctx, "/chat/emotes", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetGlobalEmotes gets all global emotes.
func (c *Client) GetGlobalEmotes(ctx context.Context) (*Response[Emote], error) <span class="cov0" title="0">{
        var resp Response[Emote]
        if err := c.get(ctx, "/chat/emotes/global", nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetEmoteSets gets emotes from specific emote sets.
func (c *Client) GetEmoteSets(ctx context.Context, emoteSetIDs []string) (*Response[Emote], error) <span class="cov0" title="0">{
        q := url.Values{}
        for _, id := range emoteSetIDs </span><span class="cov0" title="0">{
                q.Add("emote_set_id", id)
        }</span>

        <span class="cov0" title="0">var resp Response[Emote]
        if err := c.get(ctx, "/chat/emotes/set", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ChatBadge represents a chat badge.
type ChatBadge struct {
        SetID    string         `json:"set_id"`
        Versions []BadgeVersion `json:"versions"`
}

// BadgeVersion represents a version of a chat badge.
type BadgeVersion struct {
        ID          string `json:"id"`
        ImageURL1x  string `json:"image_url_1x"`
        ImageURL2x  string `json:"image_url_2x"`
        ImageURL4x  string `json:"image_url_4x"`
        Title       string `json:"title"`
        Description string `json:"description"`
        ClickAction string `json:"click_action,omitempty"`
        ClickURL    string `json:"click_url,omitempty"`
}

// GetChannelChatBadges gets the chat badges for a channel.
func (c *Client) GetChannelChatBadges(ctx context.Context, broadcasterID string) (*Response[ChatBadge], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[ChatBadge]
        if err := c.get(ctx, "/chat/badges", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetGlobalChatBadges gets all global chat badges.
func (c *Client) GetGlobalChatBadges(ctx context.Context) (*Response[ChatBadge], error) <span class="cov0" title="0">{
        var resp Response[ChatBadge]
        if err := c.get(ctx, "/chat/badges/global", nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ChatSettings represents chat room settings.
type ChatSettings struct {
        BroadcasterID                 string `json:"broadcaster_id"`
        SlowMode                      bool   `json:"slow_mode"`
        SlowModeWaitTime              int    `json:"slow_mode_wait_time,omitempty"`
        FollowerMode                  bool   `json:"follower_mode"`
        FollowerModeDuration          int    `json:"follower_mode_duration,omitempty"`
        SubscriberMode                bool   `json:"subscriber_mode"`
        EmoteMode                     bool   `json:"emote_mode"`
        UniqueChatMode                bool   `json:"unique_chat_mode"`
        NonModeratorChatDelay         bool   `json:"non_moderator_chat_delay"`
        NonModeratorChatDelayDuration int    `json:"non_moderator_chat_delay_duration,omitempty"`
}

// GetChatSettings gets the chat settings for a channel.
func (c *Client) GetChatSettings(ctx context.Context, broadcasterID, moderatorID string) (*Response[ChatSettings], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        if moderatorID != "" </span><span class="cov0" title="0">{
                q.Set("moderator_id", moderatorID)
        }</span>

        <span class="cov0" title="0">var resp Response[ChatSettings]
        if err := c.get(ctx, "/chat/settings", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// UpdateChatSettingsParams contains parameters for UpdateChatSettings.
type UpdateChatSettingsParams struct {
        BroadcasterID                 string `json:"-"`
        ModeratorID                   string `json:"-"`
        EmoteMode                     *bool  `json:"emote_mode,omitempty"`
        FollowerMode                  *bool  `json:"follower_mode,omitempty"`
        FollowerModeDuration          *int   `json:"follower_mode_duration,omitempty"`
        NonModeratorChatDelay         *bool  `json:"non_moderator_chat_delay,omitempty"`
        NonModeratorChatDelayDuration *int   `json:"non_moderator_chat_delay_duration,omitempty"`
        SlowMode                      *bool  `json:"slow_mode,omitempty"`
        SlowModeWaitTime              *int   `json:"slow_mode_wait_time,omitempty"`
        SubscriberMode                *bool  `json:"subscriber_mode,omitempty"`
        UniqueChatMode                *bool  `json:"unique_chat_mode,omitempty"`
}

// UpdateChatSettings updates the chat settings for a channel.
// Requires: moderator:manage:chat_settings scope.
func (c *Client) UpdateChatSettings(ctx context.Context, params *UpdateChatSettingsParams) (*Response[ChatSettings], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)

        var resp Response[ChatSettings]
        if err := c.patch(ctx, "/chat/settings", q, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// SendChatAnnouncementParams contains parameters for SendChatAnnouncement.
type SendChatAnnouncementParams struct {
        BroadcasterID string `json:"-"`
        ModeratorID   string `json:"-"`
        Message       string `json:"message"`
        Color         string `json:"color,omitempty"` // blue, green, orange, purple, primary
}

// SendChatAnnouncement sends an announcement to a channel's chat.
// Requires: moderator:manage:announcements scope.
func (c *Client) SendChatAnnouncement(ctx context.Context, params *SendChatAnnouncementParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)

        return c.post(ctx, "/chat/announcements", q, params, nil)
}</span>

// SendShoutoutParams contains parameters for SendShoutout.
type SendShoutoutParams struct {
        FromBroadcasterID string
        ToBroadcasterID   string
        ModeratorID       string
}

// SendShoutout sends a shoutout to another channel.
// Requires: moderator:manage:shoutouts scope.
func (c *Client) SendShoutout(ctx context.Context, params *SendShoutoutParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("from_broadcaster_id", params.FromBroadcasterID)
        q.Set("to_broadcaster_id", params.ToBroadcasterID)
        q.Set("moderator_id", params.ModeratorID)

        return c.post(ctx, "/chat/shoutouts", q, nil, nil)
}</span>

// UserChatColor represents a user's chat color.
type UserChatColor struct {
        UserID    string `json:"user_id"`
        UserLogin string `json:"user_login"`
        UserName  string `json:"user_name"`
        Color     string `json:"color"`
}

// GetUserChatColor gets the chat color for one or more users.
func (c *Client) GetUserChatColor(ctx context.Context, userIDs []string) (*Response[UserChatColor], error) <span class="cov0" title="0">{
        q := url.Values{}
        for _, id := range userIDs </span><span class="cov0" title="0">{
                q.Add("user_id", id)
        }</span>

        <span class="cov0" title="0">var resp Response[UserChatColor]
        if err := c.get(ctx, "/chat/color", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// UpdateUserChatColor updates the authenticated user's chat color.
// Requires: user:manage:chat_color scope.
func (c *Client) UpdateUserChatColor(ctx context.Context, userID, color string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("user_id", userID)
        q.Set("color", color)

        return c.put(ctx, "/chat/color", q, nil, nil)
}</span>

// SendChatMessageParams contains parameters for SendChatMessage.
type SendChatMessageParams struct {
        BroadcasterID        string `json:"broadcaster_id"`
        SenderID             string `json:"sender_id"`
        Message              string `json:"message"`
        ReplyParentMessageID string `json:"reply_parent_message_id,omitempty"`
}

// SendChatMessageResponse represents the response from SendChatMessage.
type SendChatMessageResponse struct {
        MessageID  string `json:"message_id"`
        IsSent     bool   `json:"is_sent"`
        DropReason *struct {
                Code    string `json:"code"`
                Message string `json:"message"`
        } `json:"drop_reason,omitempty"`
}

// SendChatMessage sends a chat message to a channel.
// Requires: user:write:chat scope.
func (c *Client) SendChatMessage(ctx context.Context, params *SendChatMessageParams) (*SendChatMessageResponse, error) <span class="cov0" title="0">{
        var resp Response[SendChatMessageResponse]
        if err := c.post(ctx, "/chat/messages", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// SharedChatSession represents a shared chat session.
type SharedChatSession struct {
        SessionID         string                  `json:"session_id"`
        HostBroadcasterID string                  `json:"host_broadcaster_id"`
        Participants      []SharedChatParticipant `json:"participants"`
        CreatedAt         string                  `json:"created_at"`
        UpdatedAt         string                  `json:"updated_at"`
}

// SharedChatParticipant represents a participant in a shared chat session.
type SharedChatParticipant struct {
        BroadcasterID string `json:"broadcaster_id"`
}

// GetSharedChatSession gets the active shared chat session for a channel.
// Requires: No authentication required.
func (c *Client) GetSharedChatSession(ctx context.Context, broadcasterID string) (*SharedChatSession, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[SharedChatSession]
        if err := c.get(ctx, "/shared_chat/session", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// UserEmote represents a user's emote.
type UserEmote struct {
        ID         string   `json:"id"`
        Name       string   `json:"name"`
        EmoteType  string   `json:"emote_type"`
        EmoteSetID string   `json:"emote_set_id"`
        OwnerID    string   `json:"owner_id"`
        Format     []string `json:"format"`
        Scale      []string `json:"scale"`
        ThemeMode  []string `json:"theme_mode"`
}

// GetUserEmotesParams contains parameters for GetUserEmotes.
type GetUserEmotesParams struct {
        UserID        string
        BroadcasterID string // Optional: filter to specific channel
        *PaginationParams
}

// UserEmotesResponse represents the response from GetUserEmotes.
type UserEmotesResponse struct {
        Data       []UserEmote `json:"data"`
        Template   string      `json:"template"`
        Pagination *Pagination `json:"pagination,omitempty"`
}

// GetUserEmotes gets emotes available to a user.
// Requires: user:read:emotes scope.
func (c *Client) GetUserEmotes(ctx context.Context, params *GetUserEmotesParams) (*UserEmotesResponse, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("user_id", params.UserID)
        if params.BroadcasterID != "" </span><span class="cov0" title="0">{
                q.Set("broadcaster_id", params.BroadcasterID)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp UserEmotesResponse
        if err := c.get(ctx, "/chat/emotes/user", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package helix

import (
        "context"
        "sync"
)

// ChatBotClient provides a high-level interface for Twitch chat bots.
// It wraps IRCClient with convenience methods and automatic token handling.
type ChatBotClient struct {
        irc        *IRCClient
        authClient *AuthClient
        nick       string

        // Event handlers
        onMessage    func(*ChatMessage)
        onSub        func(*UserNotice)
        onResub      func(*UserNotice)
        onSubGift    func(*UserNotice)
        onRaid       func(*UserNotice)
        onCheer      func(*ChatMessage)
        onJoin       func(channel, user string)
        onPart       func(channel, user string)
        onRoomState  func(*RoomState)
        onNotice     func(*Notice)
        onClearChat  func(*ClearChat)
        onWhisper    func(*Whisper)
        onConnect    func()
        onDisconnect func()
        onError      func(error)

        mu sync.RWMutex
}

// ChatBotOption configures the ChatBotClient.
type ChatBotOption func(*ChatBotClient)

// NewChatBotClient creates a new high-level chat bot client.
// The nick should be the bot's username, and authClient should have a valid user access token.
func NewChatBotClient(nick string, authClient *AuthClient, opts ...ChatBotOption) *ChatBotClient <span class="cov0" title="0">{
        c := &amp;ChatBotClient{
                authClient: authClient,
                nick:       nick,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(c)
        }</span>

        <span class="cov0" title="0">return c</span>
}

// OnMessage sets the handler for all chat messages.
func (c *ChatBotClient) OnMessage(fn func(*ChatMessage)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onMessage = fn
}</span>

// OnSub sets the handler for new subscription events.
func (c *ChatBotClient) OnSub(fn func(*UserNotice)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onSub = fn
}</span>

// OnResub sets the handler for resubscription events.
func (c *ChatBotClient) OnResub(fn func(*UserNotice)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onResub = fn
}</span>

// OnSubGift sets the handler for gift subscription events.
func (c *ChatBotClient) OnSubGift(fn func(*UserNotice)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onSubGift = fn
}</span>

// OnRaid sets the handler for raid events.
func (c *ChatBotClient) OnRaid(fn func(*UserNotice)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onRaid = fn
}</span>

// OnCheer sets the handler for cheer (bits) messages.
func (c *ChatBotClient) OnCheer(fn func(*ChatMessage)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onCheer = fn
}</span>

// OnJoin sets the handler for user join events.
func (c *ChatBotClient) OnJoin(fn func(channel, user string)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onJoin = fn
}</span>

// OnPart sets the handler for user part events.
func (c *ChatBotClient) OnPart(fn func(channel, user string)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onPart = fn
}</span>

// OnRoomState sets the handler for room state changes.
func (c *ChatBotClient) OnRoomState(fn func(*RoomState)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onRoomState = fn
}</span>

// OnNotice sets the handler for server notices.
func (c *ChatBotClient) OnNotice(fn func(*Notice)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onNotice = fn
}</span>

// OnClearChat sets the handler for chat clear/timeout/ban events.
func (c *ChatBotClient) OnClearChat(fn func(*ClearChat)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onClearChat = fn
}</span>

// OnWhisper sets the handler for whisper messages.
func (c *ChatBotClient) OnWhisper(fn func(*Whisper)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onWhisper = fn
}</span>

// OnConnect sets the handler for successful connections.
func (c *ChatBotClient) OnConnect(fn func()) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onConnect = fn
}</span>

// OnDisconnect sets the handler for disconnections.
func (c *ChatBotClient) OnDisconnect(fn func()) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onDisconnect = fn
}</span>

// OnError sets the handler for errors.
func (c *ChatBotClient) OnError(fn func(error)) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.onError = fn
}</span>

// Connect establishes a connection to Twitch chat.
func (c *ChatBotClient) Connect(ctx context.Context) error <span class="cov0" title="0">{
        token := ""
        if c.authClient != nil </span><span class="cov0" title="0">{
                if t := c.authClient.GetToken(); t != nil </span><span class="cov0" title="0">{
                        token = t.AccessToken
                }</span>
        }

        <span class="cov0" title="0">c.irc = NewIRCClient(c.nick, token,
                WithMessageHandler(c.handleMessage),
                WithUserNoticeHandler(c.handleUserNotice),
                WithJoinHandler(c.handleJoin),
                WithPartHandler(c.handlePart),
                WithRoomStateHandler(c.handleRoomState),
                WithNoticeHandler(c.handleNotice),
                WithClearChatHandler(c.handleClearChat),
                WithWhisperHandler(c.handleWhisper),
                WithConnectHandler(c.handleConnect),
                WithDisconnectHandler(c.handleDisconnect),
                WithIRCErrorHandler(c.handleError),
        )

        return c.irc.Connect(ctx)</span>
}

// Close closes the chat connection.
func (c *ChatBotClient) Close() error <span class="cov0" title="0">{
        if c.irc != nil </span><span class="cov0" title="0">{
                return c.irc.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsConnected returns whether the client is connected.
func (c *ChatBotClient) IsConnected() bool <span class="cov0" title="0">{
        if c.irc == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return c.irc.IsConnected()</span>
}

// Join joins one or more channels.
func (c *ChatBotClient) Join(channels ...string) error <span class="cov0" title="0">{
        if c.irc == nil </span><span class="cov0" title="0">{
                return ErrIRCNotConnected
        }</span>
        <span class="cov0" title="0">return c.irc.Join(channels...)</span>
}

// Part leaves one or more channels.
func (c *ChatBotClient) Part(channels ...string) error <span class="cov0" title="0">{
        if c.irc == nil </span><span class="cov0" title="0">{
                return ErrIRCNotConnected
        }</span>
        <span class="cov0" title="0">return c.irc.Part(channels...)</span>
}

// Say sends a message to a channel.
func (c *ChatBotClient) Say(channel, message string) error <span class="cov0" title="0">{
        if c.irc == nil </span><span class="cov0" title="0">{
                return ErrIRCNotConnected
        }</span>
        <span class="cov0" title="0">return c.irc.Say(channel, message)</span>
}

// Reply sends a reply to a specific message.
func (c *ChatBotClient) Reply(channel, parentMsgID, message string) error <span class="cov0" title="0">{
        if c.irc == nil </span><span class="cov0" title="0">{
                return ErrIRCNotConnected
        }</span>
        <span class="cov0" title="0">return c.irc.Reply(channel, parentMsgID, message)</span>
}

// Whisper sends a whisper to a user.
func (c *ChatBotClient) Whisper(user, message string) error <span class="cov0" title="0">{
        if c.irc == nil </span><span class="cov0" title="0">{
                return ErrIRCNotConnected
        }</span>
        <span class="cov0" title="0">return c.irc.Whisper(user, message)</span>
}

// GetJoinedChannels returns the list of joined channels.
func (c *ChatBotClient) GetJoinedChannels() []string <span class="cov0" title="0">{
        if c.irc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.irc.GetJoinedChannels()</span>
}

// IRC returns the underlying IRC client for advanced usage.
func (c *ChatBotClient) IRC() *IRCClient <span class="cov0" title="0">{
        return c.irc
}</span>

// Internal handlers

func (c *ChatBotClient) handleMessage(msg *ChatMessage) <span class="cov0" title="0">{
        c.mu.RLock()
        onMessage := c.onMessage
        onCheer := c.onCheer
        c.mu.RUnlock()

        // Check for cheers
        if msg.Bits &gt; 0 &amp;&amp; onCheer != nil </span><span class="cov0" title="0">{
                onCheer(msg)
        }</span>

        <span class="cov0" title="0">if onMessage != nil </span><span class="cov0" title="0">{
                onMessage(msg)
        }</span>
}

func (c *ChatBotClient) handleUserNotice(notice *UserNotice) <span class="cov0" title="0">{
        c.mu.RLock()
        onSub := c.onSub
        onResub := c.onResub
        onSubGift := c.onSubGift
        onRaid := c.onRaid
        c.mu.RUnlock()

        switch notice.Type </span>{
        case UserNoticeTypeSub:<span class="cov0" title="0">
                if onSub != nil </span><span class="cov0" title="0">{
                        onSub(notice)
                }</span>
        case UserNoticeTypeResub:<span class="cov0" title="0">
                if onResub != nil </span><span class="cov0" title="0">{
                        onResub(notice)
                }</span>
        case UserNoticeTypeSubGift, UserNoticeTypeAnonSubGift, UserNoticeTypeSubMysteryGift:<span class="cov0" title="0">
                if onSubGift != nil </span><span class="cov0" title="0">{
                        onSubGift(notice)
                }</span>
        case UserNoticeTypeRaid:<span class="cov0" title="0">
                if onRaid != nil </span><span class="cov0" title="0">{
                        onRaid(notice)
                }</span>
        }
}

func (c *ChatBotClient) handleJoin(channel, user string) <span class="cov0" title="0">{
        c.mu.RLock()
        fn := c.onJoin
        c.mu.RUnlock()

        if fn != nil </span><span class="cov0" title="0">{
                fn(channel, user)
        }</span>
}

func (c *ChatBotClient) handlePart(channel, user string) <span class="cov0" title="0">{
        c.mu.RLock()
        fn := c.onPart
        c.mu.RUnlock()

        if fn != nil </span><span class="cov0" title="0">{
                fn(channel, user)
        }</span>
}

func (c *ChatBotClient) handleRoomState(state *RoomState) <span class="cov0" title="0">{
        c.mu.RLock()
        fn := c.onRoomState
        c.mu.RUnlock()

        if fn != nil </span><span class="cov0" title="0">{
                fn(state)
        }</span>
}

func (c *ChatBotClient) handleNotice(notice *Notice) <span class="cov0" title="0">{
        c.mu.RLock()
        fn := c.onNotice
        c.mu.RUnlock()

        if fn != nil </span><span class="cov0" title="0">{
                fn(notice)
        }</span>
}

func (c *ChatBotClient) handleClearChat(clear *ClearChat) <span class="cov0" title="0">{
        c.mu.RLock()
        fn := c.onClearChat
        c.mu.RUnlock()

        if fn != nil </span><span class="cov0" title="0">{
                fn(clear)
        }</span>
}

func (c *ChatBotClient) handleWhisper(whisper *Whisper) <span class="cov0" title="0">{
        c.mu.RLock()
        fn := c.onWhisper
        c.mu.RUnlock()

        if fn != nil </span><span class="cov0" title="0">{
                fn(whisper)
        }</span>
}

func (c *ChatBotClient) handleConnect() <span class="cov0" title="0">{
        c.mu.RLock()
        fn := c.onConnect
        c.mu.RUnlock()

        if fn != nil </span><span class="cov0" title="0">{
                fn()
        }</span>
}

func (c *ChatBotClient) handleDisconnect() <span class="cov0" title="0">{
        c.mu.RLock()
        fn := c.onDisconnect
        c.mu.RUnlock()

        if fn != nil </span><span class="cov0" title="0">{
                fn()
        }</span>
}

func (c *ChatBotClient) handleError(err error) <span class="cov0" title="0">{
        c.mu.RLock()
        fn := c.onError
        c.mu.RUnlock()

        if fn != nil </span><span class="cov0" title="0">{
                fn(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package helix provides a client for the Twitch Helix API.
package helix

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "sync"
        "time"
)

const (
        // HelixBaseURL is the base URL for the Twitch Helix API.
        HelixBaseURL = "https://api.twitch.tv/helix"

        // DefaultRateLimit is the default rate limit for the API.
        DefaultRateLimit = 800 // requests per minute
)

// TokenProvider is an interface for providing access tokens.
type TokenProvider interface {
        GetToken() *Token
}

// Client is a Twitch Helix API client.
type Client struct {
        clientID      string
        authClient    *AuthClient   // For full auth client functionality
        tokenProvider TokenProvider // For token-only providers (e.g., extension JWT)
        httpClient    *http.Client

        // Rate limiting
        rateLimitLimit     int       // Points added per minute (bucket size)
        rateLimitRemaining int       // Points remaining in bucket
        rateLimitReset     time.Time // When bucket resets
        rateMu             sync.Mutex

        // Retry configuration
        maxRetries     int           // Maximum retries on 429 (default: 3)
        retryEnabled   bool          // Whether to auto-retry on 429 (default: true)
        maxRetryWait   time.Duration // Maximum wait time for retry (default: 60s)
        baseRetryDelay time.Duration // Base delay for exponential backoff (default: 1s)
        useExpBackoff  bool          // Use exponential backoff instead of reset time (default: false)

        // Middleware
        middleware []Middleware

        // Cache
        cache        Cache
        cacheTTL     time.Duration
        cacheEnabled bool

        // Base URL (can be overridden for testing)
        baseURL string

        // Ingest base URL (can be overridden for testing)
        ingestBaseURL string
}

// Option is a function that configures the client.
type Option func(*Client)

// WithHTTPClient sets a custom HTTP client.
func WithHTTPClient(client *http.Client) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.httpClient = client
        }</span>
}

// WithBaseURL sets a custom base URL (useful for testing).
func WithBaseURL(url string) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.baseURL = url
        }</span>
}

// WithIngestBaseURL sets a custom ingest base URL (useful for testing).
func WithIngestBaseURL(url string) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.ingestBaseURL = url
        }</span>
}

// WithRetry configures retry behavior for rate-limited requests.
func WithRetry(enabled bool, maxRetries int) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.retryEnabled = enabled
                c.maxRetries = maxRetries
        }</span>
}

// WithMaxRetryWait sets the maximum time to wait for a retry.
func WithMaxRetryWait(d time.Duration) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.maxRetryWait = d
        }</span>
}

// WithExponentialBackoff enables exponential backoff for retries.
// baseDelay is the initial delay, which doubles with each retry attempt.
func WithExponentialBackoff(baseDelay time.Duration) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.useExpBackoff = true
                c.baseRetryDelay = baseDelay
        }</span>
}

// WithMiddleware adds middleware to the client.
func WithMiddleware(mw ...Middleware) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.middleware = append(c.middleware, mw...)
        }</span>
}

// NewClient creates a new Helix API client.
func NewClient(clientID string, authClient *AuthClient, opts ...Option) *Client <span class="cov0" title="0">{
        c := &amp;Client{
                clientID:           clientID,
                authClient:         authClient,
                httpClient:         &amp;http.Client{Timeout: 30 * time.Second},
                baseURL:            HelixBaseURL,
                ingestBaseURL:      IngestBaseURL,
                rateLimitLimit:     DefaultRateLimit,
                rateLimitRemaining: DefaultRateLimit,
                retryEnabled:       true,
                maxRetries:         3,
                maxRetryWait:       60 * time.Second,
                baseRetryDelay:     time.Second,
                cacheTTL:           5 * time.Minute,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(c)
        }</span>

        <span class="cov0" title="0">return c</span>
}

// Request represents an API request.
type Request struct {
        Method   string
        Endpoint string
        Query    url.Values
        Body     interface{}
}

// Response represents a generic API response.
type Response[T any] struct {
        Data         []T         `json:"data"`
        Pagination   *Pagination `json:"pagination,omitempty"`
        Total        *int        `json:"total,omitempty"`
        TotalCost    *int        `json:"total_cost,omitempty"`
        MaxTotalCost *int        `json:"max_total_cost,omitempty"`
}

// Pagination contains pagination information.
type Pagination struct {
        Cursor string `json:"cursor,omitempty"`
}

// ErrorResponse represents an API error response.
type ErrorResponse struct {
        Error   string `json:"error"`
        Status  int    `json:"status"`
        Message string `json:"message"`
}

// APIError represents a Twitch API error.
type APIError struct {
        StatusCode int
        ErrorType  string
        Message    string
}

func (e *APIError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("twitch api error %d: %s - %s", e.StatusCode, e.ErrorType, e.Message)
}</span>

// RateLimitError is returned when the API rate limit is exceeded and retries are exhausted.
type RateLimitError struct {
        ResetAt    time.Time     // When the rate limit resets
        Remaining  int           // Points remaining (usually 0)
        Limit      int           // Total bucket size
        RetryAfter time.Duration // How long until reset
}

func (e *RateLimitError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("rate limit exceeded: %d/%d points remaining, resets in %v", e.Remaining, e.Limit, e.RetryAfter.Round(time.Second))
}</span>

// IsRateLimitError returns true if the error is a rate limit error.
func IsRateLimitError(err error) bool <span class="cov0" title="0">{
        _, ok := err.(*RateLimitError)
        return ok
}</span>

// Do executes an API request with automatic retry on rate limit (429).
func (c *Client) Do(ctx context.Context, req *Request, result interface{}) error <span class="cov0" title="0">{
        // Check cache for GET requests
        if c.cacheEnabled &amp;&amp; c.cache != nil &amp;&amp; req.Method == http.MethodGet &amp;&amp; !shouldSkipCache(ctx) </span><span class="cov0" title="0">{
                cacheKey := CacheKey(req.Endpoint, req.Query.Encode())
                if cached := c.cache.Get(ctx, cacheKey); cached != nil </span><span class="cov0" title="0">{
                        if result != nil </span><span class="cov0" title="0">{
                                return json.Unmarshal(cached, result)
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }
        }

        // Execute with middleware if configured
        <span class="cov0" title="0">if len(c.middleware) &gt; 0 </span><span class="cov0" title="0">{
                return c.doWithMiddleware(ctx, req, result)
        }</span>

        <span class="cov0" title="0">return c.doWithRetry(ctx, req, result)</span>
}

// doWithMiddleware executes request through the middleware chain.
func (c *Client) doWithMiddleware(ctx context.Context, req *Request, result interface{}) error <span class="cov0" title="0">{
        // Build middleware chain
        var chain MiddlewareNext
        chain = func(ctx context.Context, req *Request) (*MiddlewareResponse, error) </span><span class="cov0" title="0">{
                // Final handler - execute the actual request and capture response info
                return c.doWithRetryAndResponse(ctx, req, result)
        }</span>

        // Wrap chain with middleware in reverse order
        <span class="cov0" title="0">for i := len(c.middleware) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                mw := c.middleware[i]
                next := chain
                chain = func(ctx context.Context, req *Request) (*MiddlewareResponse, error) </span><span class="cov0" title="0">{
                        return mw(ctx, req, next)
                }</span>
        }

        <span class="cov0" title="0">_, err := chain(ctx, req)
        return err</span>
}

// doWithRetry executes a request with retry logic.
func (c *Client) doWithRetry(ctx context.Context, req *Request, result interface{}) error <span class="cov0" title="0">{
        _, err := c.doWithRetryAndResponse(ctx, req, result)
        return err
}</span>

// doWithRetryAndResponse executes a request with retry logic and returns response info for middleware.
func (c *Client) doWithRetryAndResponse(ctx context.Context, req *Request, result interface{}) (*MiddlewareResponse, error) <span class="cov0" title="0">{
        var lastErr error
        var lastResp *MiddlewareResponse

        for attempt := 0; attempt &lt;= c.maxRetries; attempt++ </span><span class="cov0" title="0">{
                resp, err := c.doOnceWithResponse(ctx, req, result)
                if err == nil </span><span class="cov0" title="0">{
                        return resp, nil
                }</span>

                <span class="cov0" title="0">lastResp = resp

                // Check if it's a rate limit error
                if apiErr, ok := err.(*APIError); ok &amp;&amp; apiErr.StatusCode == http.StatusTooManyRequests </span><span class="cov0" title="0">{
                        if !c.retryEnabled || attempt &gt;= c.maxRetries </span><span class="cov0" title="0">{
                                // Return a RateLimitError with reset info
                                c.rateMu.Lock()
                                resetAt := c.rateLimitReset
                                remaining := c.rateLimitRemaining
                                limit := c.rateLimitLimit
                                c.rateMu.Unlock()

                                retryAfter := time.Until(resetAt)
                                if retryAfter &lt; 0 </span><span class="cov0" title="0">{
                                        retryAfter = 0
                                }</span>

                                <span class="cov0" title="0">return lastResp, &amp;RateLimitError{
                                        ResetAt:    resetAt,
                                        Remaining:  remaining,
                                        Limit:      limit,
                                        RetryAfter: retryAfter,
                                }</span>
                        }

                        // Calculate wait time
                        <span class="cov0" title="0">var waitTime time.Duration
                        if c.useExpBackoff </span><span class="cov0" title="0">{
                                // Exponential backoff: baseDelay * 2^attempt
                                waitTime = c.baseRetryDelay * (1 &lt;&lt; uint(attempt))
                        }</span> else<span class="cov0" title="0"> {
                                // Wait until reset time
                                c.rateMu.Lock()
                                resetAt := c.rateLimitReset
                                c.rateMu.Unlock()
                                waitTime = time.Until(resetAt)
                        }</span>

                        // Apply bounds
                        <span class="cov0" title="0">if waitTime &lt; 0 </span><span class="cov0" title="0">{
                                waitTime = c.baseRetryDelay
                        }</span>
                        <span class="cov0" title="0">if waitTime &gt; c.maxRetryWait </span><span class="cov0" title="0">{
                                waitTime = c.maxRetryWait
                        }</span>

                        // Wait before retry
                        <span class="cov0" title="0">select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return lastResp, ctx.Err()</span>
                        case &lt;-time.After(waitTime):<span class="cov0" title="0"></span>
                                // Continue to next attempt
                        }

                        <span class="cov0" title="0">lastErr = err
                        continue</span>
                }

                // Not a rate limit error, return immediately
                <span class="cov0" title="0">return lastResp, err</span>
        }

        <span class="cov0" title="0">return lastResp, lastErr</span>
}

// doOnce executes a single API request without retries.
func (c *Client) doOnce(ctx context.Context, req *Request, result interface{}) error <span class="cov0" title="0">{
        _, err := c.doOnceWithResponse(ctx, req, result)
        return err
}</span>

// doOnceWithResponse executes a single API request and returns response info for middleware.
func (c *Client) doOnceWithResponse(ctx context.Context, req *Request, result interface{}) (*MiddlewareResponse, error) <span class="cov0" title="0">{
        // Build URL
        reqURL := c.baseURL + req.Endpoint
        if len(req.Query) &gt; 0 </span><span class="cov0" title="0">{
                reqURL += "?" + req.Query.Encode()
        }</span>

        // Build body
        <span class="cov0" title="0">var bodyReader io.Reader
        if req.Body != nil </span><span class="cov0" title="0">{
                bodyBytes, err := json.Marshal(req.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("marshaling request body: %w", err)
                }</span>
                <span class="cov0" title="0">bodyReader = bytes.NewReader(bodyBytes)</span>
        }

        // Create HTTP request
        <span class="cov0" title="0">httpReq, err := http.NewRequestWithContext(ctx, req.Method, reqURL, bodyReader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating request: %w", err)
        }</span>

        // Set headers
        <span class="cov0" title="0">httpReq.Header.Set("Client-Id", c.clientID)
        if req.Body != nil </span><span class="cov0" title="0">{
                httpReq.Header.Set("Content-Type", "application/json")
        }</span>

        // Set custom headers from middleware context
        <span class="cov0" title="0">if customHeaders := headersFromContext(ctx); customHeaders != nil </span><span class="cov0" title="0">{
                for k, v := range customHeaders </span><span class="cov0" title="0">{
                        httpReq.Header.Set(k, v)
                }</span>
        }

        // Set authorization
        <span class="cov0" title="0">var token *Token
        if c.authClient != nil </span><span class="cov0" title="0">{
                token = c.authClient.GetToken()
        }</span> else<span class="cov0" title="0"> if c.tokenProvider != nil </span><span class="cov0" title="0">{
                token = c.tokenProvider.GetToken()
        }</span>
        <span class="cov0" title="0">if token != nil &amp;&amp; token.AccessToken != "" </span><span class="cov0" title="0">{
                httpReq.Header.Set("Authorization", "Bearer "+token.AccessToken)
        }</span>

        // Execute request
        <span class="cov0" title="0">resp, err := c.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("executing request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        // Update rate limit info from headers
        <span class="cov0" title="0">c.updateRateLimit(resp)

        // Read response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading response body: %w", err)
        }</span>

        // Build middleware response with real data
        <span class="cov0" title="0">mwResp := &amp;MiddlewareResponse{
                StatusCode: resp.StatusCode,
                Headers:    resp.Header.Clone(),
                Body:       body,
        }

        // Check for errors
        if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                var errResp ErrorResponse
                if err := json.Unmarshal(body, &amp;errResp); err != nil </span><span class="cov0" title="0">{
                        return mwResp, &amp;APIError{
                                StatusCode: resp.StatusCode,
                                ErrorType:  "unknown",
                                Message:    string(body),
                        }
                }</span>
                <span class="cov0" title="0">return mwResp, &amp;APIError{
                        StatusCode: resp.StatusCode,
                        ErrorType:  errResp.Error,
                        Message:    errResp.Message,
                }</span>
        }

        // Parse response
        <span class="cov0" title="0">if result != nil &amp;&amp; len(body) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(body, result); err != nil </span><span class="cov0" title="0">{
                        return mwResp, fmt.Errorf("parsing response: %w", err)
                }</span>
        }

        // Cache successful GET responses
        <span class="cov0" title="0">if c.cacheEnabled &amp;&amp; c.cache != nil &amp;&amp; req.Method == http.MethodGet &amp;&amp; !shouldSkipCache(ctx) &amp;&amp; len(body) &gt; 0 </span><span class="cov0" title="0">{
                cacheKey := CacheKey(req.Endpoint, req.Query.Encode())
                c.cache.Set(ctx, cacheKey, body, c.cacheTTL)
        }</span>

        <span class="cov0" title="0">return mwResp, nil</span>
}

// updateRateLimit updates rate limit information from response headers.
// Only updates state when headers are present AND parse successfully to avoid poisoning state.
func (c *Client) updateRateLimit(resp *http.Response) <span class="cov0" title="0">{
        c.rateMu.Lock()
        defer c.rateMu.Unlock()

        if limit := resp.Header.Get("Ratelimit-Limit"); limit != "" </span><span class="cov0" title="0">{
                var l int
                if n, err := fmt.Sscanf(limit, "%d", &amp;l); err == nil &amp;&amp; n == 1 &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                        c.rateLimitLimit = l
                }</span>
        }

        <span class="cov0" title="0">if remaining := resp.Header.Get("Ratelimit-Remaining"); remaining != "" </span><span class="cov0" title="0">{
                var r int
                if n, err := fmt.Sscanf(remaining, "%d", &amp;r); err == nil &amp;&amp; n == 1 &amp;&amp; r &gt;= 0 </span><span class="cov0" title="0">{
                        c.rateLimitRemaining = r
                }</span>
        }

        <span class="cov0" title="0">if reset := resp.Header.Get("Ratelimit-Reset"); reset != "" </span><span class="cov0" title="0">{
                var r int64
                if n, err := fmt.Sscanf(reset, "%d", &amp;r); err == nil &amp;&amp; n == 1 &amp;&amp; r &gt; 0 </span><span class="cov0" title="0">{
                        c.rateLimitReset = time.Unix(r, 0)
                }</span>
        }
}

// RateLimitInfo contains rate limit status information.
type RateLimitInfo struct {
        Limit     int       // Points added per minute (bucket size)
        Remaining int       // Points remaining in bucket
        ResetAt   time.Time // When the bucket resets to full
}

// GetRateLimitInfo returns current rate limit information.
func (c *Client) GetRateLimitInfo() RateLimitInfo <span class="cov0" title="0">{
        c.rateMu.Lock()
        defer c.rateMu.Unlock()
        return RateLimitInfo{
                Limit:     c.rateLimitLimit,
                Remaining: c.rateLimitRemaining,
                ResetAt:   c.rateLimitReset,
        }
}</span>

// WaitForRateLimit blocks until the rate limit resets or context is cancelled.
// Returns immediately if there are remaining points in the bucket.
func (c *Client) WaitForRateLimit(ctx context.Context) error <span class="cov0" title="0">{
        c.rateMu.Lock()
        remaining := c.rateLimitRemaining
        resetAt := c.rateLimitReset
        c.rateMu.Unlock()

        if remaining &gt; 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">waitTime := time.Until(resetAt)
        if waitTime &lt;= 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        case &lt;-time.After(waitTime):<span class="cov0" title="0">
                return nil</span>
        }
}

// Helper functions for common request patterns

// get performs a GET request.
func (c *Client) get(ctx context.Context, endpoint string, query url.Values, result interface{}) error <span class="cov0" title="0">{
        return c.Do(ctx, &amp;Request{
                Method:   http.MethodGet,
                Endpoint: endpoint,
                Query:    query,
        }, result)
}</span>

// post performs a POST request.
func (c *Client) post(ctx context.Context, endpoint string, query url.Values, body interface{}, result interface{}) error <span class="cov0" title="0">{
        return c.Do(ctx, &amp;Request{
                Method:   http.MethodPost,
                Endpoint: endpoint,
                Query:    query,
                Body:     body,
        }, result)
}</span>

// put performs a PUT request.
func (c *Client) put(ctx context.Context, endpoint string, query url.Values, body interface{}, result interface{}) error <span class="cov0" title="0">{
        return c.Do(ctx, &amp;Request{
                Method:   http.MethodPut,
                Endpoint: endpoint,
                Query:    query,
                Body:     body,
        }, result)
}</span>

// patch performs a PATCH request.
func (c *Client) patch(ctx context.Context, endpoint string, query url.Values, body interface{}, result interface{}) error <span class="cov0" title="0">{
        return c.Do(ctx, &amp;Request{
                Method:   http.MethodPatch,
                Endpoint: endpoint,
                Query:    query,
                Body:     body,
        }, result)
}</span>

// delete performs a DELETE request.
func (c *Client) delete(ctx context.Context, endpoint string, query url.Values, result interface{}) error <span class="cov0" title="0">{
        return c.Do(ctx, &amp;Request{
                Method:   http.MethodDelete,
                Endpoint: endpoint,
                Query:    query,
        }, result)
}</span>

// Pagination helpers

// PaginationParams contains common pagination parameters.
type PaginationParams struct {
        First  int    // Maximum number of items to return (1-100)
        After  string // Cursor for forward pagination
        Before string // Cursor for backward pagination
}

// addPaginationParams adds pagination parameters to a query.
func addPaginationParams(q url.Values, p *PaginationParams) <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if p.First &gt; 0 </span><span class="cov0" title="0">{
                q.Set("first", fmt.Sprintf("%d", p.First))
        }</span>
        <span class="cov0" title="0">if p.After != "" </span><span class="cov0" title="0">{
                q.Set("after", p.After)
        }</span>
        <span class="cov0" title="0">if p.Before != "" </span><span class="cov0" title="0">{
                q.Set("before", p.Before)
        }</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// Clip represents a Twitch clip.
type Clip struct {
        ID              string    `json:"id"`
        URL             string    `json:"url"`
        EmbedURL        string    `json:"embed_url"`
        BroadcasterID   string    `json:"broadcaster_id"`
        BroadcasterName string    `json:"broadcaster_name"`
        CreatorID       string    `json:"creator_id"`
        CreatorName     string    `json:"creator_name"`
        VideoID         string    `json:"video_id"`
        GameID          string    `json:"game_id"`
        Language        string    `json:"language"`
        Title           string    `json:"title"`
        ViewCount       int       `json:"view_count"`
        CreatedAt       time.Time `json:"created_at"`
        ThumbnailURL    string    `json:"thumbnail_url"`
        Duration        float64   `json:"duration"`
        VODOffset       int       `json:"vod_offset,omitempty"`
        IsFeatured      bool      `json:"is_featured"`
}

// CreateClipParams contains parameters for CreateClip.
type CreateClipParams struct {
        BroadcasterID string
        HasDelay      bool // Add delay before clip creation (for live streams)
}

// CreateClipResponse represents the response from CreateClip.
type CreateClipResponse struct {
        ID      string `json:"id"`
        EditURL string `json:"edit_url"`
}

// CreateClip creates a clip from the broadcaster's stream.
// Requires: clips:edit scope.
func (c *Client) CreateClip(ctx context.Context, params *CreateClipParams) (*CreateClipResponse, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        if params.HasDelay </span><span class="cov0" title="0">{
                q.Set("has_delay", "true")
        }</span>

        <span class="cov0" title="0">var resp Response[CreateClipResponse]
        if err := c.post(ctx, "/clips", q, nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// GetClipsParams contains parameters for GetClips.
type GetClipsParams struct {
        BroadcasterID string
        GameID        string
        IDs           []string // Clip IDs (max 100)
        StartedAt     time.Time
        EndedAt       time.Time
        IsFeatured    *bool
        *PaginationParams
}

// GetClips gets clips for a broadcaster or game.
func (c *Client) GetClips(ctx context.Context, params *GetClipsParams) (*Response[Clip], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params.BroadcasterID != "" </span><span class="cov0" title="0">{
                q.Set("broadcaster_id", params.BroadcasterID)
        }</span>
        <span class="cov0" title="0">if params.GameID != "" </span><span class="cov0" title="0">{
                q.Set("game_id", params.GameID)
        }</span>
        <span class="cov0" title="0">for _, id := range params.IDs </span><span class="cov0" title="0">{
                q.Add("id", id)
        }</span>
        <span class="cov0" title="0">if !params.StartedAt.IsZero() </span><span class="cov0" title="0">{
                q.Set("started_at", params.StartedAt.Format(time.RFC3339))
        }</span>
        <span class="cov0" title="0">if !params.EndedAt.IsZero() </span><span class="cov0" title="0">{
                q.Set("ended_at", params.EndedAt.Format(time.RFC3339))
        }</span>
        <span class="cov0" title="0">if params.IsFeatured != nil </span><span class="cov0" title="0">{
                if *params.IsFeatured </span><span class="cov0" title="0">{
                        q.Set("is_featured", "true")
                }</span> else<span class="cov0" title="0"> {
                        q.Set("is_featured", "false")
                }</span>
        }
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[Clip]
        if err := c.get(ctx, "/clips", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ClipDownload represents a clip download URL.
type ClipDownload struct {
        ID        string `json:"id"`
        URL       string `json:"url"`
        ExpiresAt string `json:"expires_at"`
}

// GetClipsDownload gets a download URL for clips.
// Requires: clips:edit scope for clips the user created, or the broadcaster's clips.
func (c *Client) GetClipsDownload(ctx context.Context, clipIDs []string) (*Response[ClipDownload], error) <span class="cov0" title="0">{
        q := url.Values{}
        for _, id := range clipIDs </span><span class="cov0" title="0">{
                q.Add("id", id)
        }</span>

        <span class="cov0" title="0">var resp Response[ClipDownload]
        if err := c.get(ctx, "/clips/download", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// CreateClipFromVODParams contains parameters for CreateClipFromVOD.
type CreateClipFromVODParams struct {
        EditorID      string   `json:"editor_id"`      // Required: User ID of the editor
        BroadcasterID string   `json:"broadcaster_id"` // Required: User ID of the channel
        VODID         string   `json:"vod_id"`         // Required: ID of the VOD to clip
        VODOffset     int      `json:"vod_offset"`     // Required: Offset in seconds where clip ends
        Title         string   `json:"title"`          // Required: Clip title
        Duration      *float64 `json:"duration,omitempty"` // Optional: Clip length (5-60 seconds, default 30)
}

// CreateClipFromVOD creates a clip from a VOD.
// Requires: editor:manage:clips or channel:manage:clips scope.
func (c *Client) CreateClipFromVOD(ctx context.Context, params *CreateClipFromVODParams) (*CreateClipResponse, error) <span class="cov0" title="0">{
        var resp Response[CreateClipResponse]
        if err := c.post(ctx, "/videos/clips", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package helix

import (
        "context"
        "net/url"
)

// Conduit represents an EventSub conduit.
type Conduit struct {
        ID         string `json:"id"`
        ShardCount int    `json:"shard_count"`
}

// GetConduits gets the conduits for a client ID.
// Requires: App access token.
func (c *Client) GetConduits(ctx context.Context) (*Response[Conduit], error) <span class="cov0" title="0">{
        var resp Response[Conduit]
        if err := c.get(ctx, "/eventsub/conduits", nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// CreateConduitParams contains parameters for CreateConduit.
type CreateConduitParams struct {
        ShardCount int `json:"shard_count"`
}

// CreateConduit creates a new conduit.
// Requires: App access token.
func (c *Client) CreateConduit(ctx context.Context, shardCount int) (*Conduit, error) <span class="cov0" title="0">{
        params := CreateConduitParams{ShardCount: shardCount}

        var resp Response[Conduit]
        if err := c.post(ctx, "/eventsub/conduits", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// UpdateConduitParams contains parameters for UpdateConduit.
type UpdateConduitParams struct {
        ID         string `json:"id"`
        ShardCount int    `json:"shard_count"`
}

// UpdateConduit updates a conduit's shard count.
// Requires: App access token.
func (c *Client) UpdateConduit(ctx context.Context, params *UpdateConduitParams) (*Conduit, error) <span class="cov0" title="0">{
        var resp Response[Conduit]
        if err := c.patch(ctx, "/eventsub/conduits", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// DeleteConduit deletes a conduit.
// Requires: App access token.
func (c *Client) DeleteConduit(ctx context.Context, conduitID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("id", conduitID)

        return c.delete(ctx, "/eventsub/conduits", q, nil)
}</span>

// ConduitShard represents a shard in a conduit.
type ConduitShard struct {
        ID        string                `json:"id"`
        Status    string                `json:"status"`
        Transport ConduitShardTransport `json:"transport"`
}

// ConduitShardTransport represents the transport for a conduit shard.
type ConduitShardTransport struct {
        Method         string `json:"method"`
        Callback       string `json:"callback,omitempty"`
        SessionID      string `json:"session_id,omitempty"`
        ConnectedAt    string `json:"connected_at,omitempty"`
        DisconnectedAt string `json:"disconnected_at,omitempty"`
}

// GetConduitShardsParams contains parameters for GetConduitShards.
type GetConduitShardsParams struct {
        ConduitID string
        Status    string // enabled, webhook_callback_verification_pending, webhook_callback_verification_failed, notification_failures_exceeded, websocket_disconnected, websocket_failed_ping_pong, websocket_received_inbound_traffic, websocket_internal_error, websocket_network_timeout, websocket_network_error, websocket_failed_to_reconnect
        *PaginationParams
}

// GetConduitShardsResponse represents the response from GetConduitShards.
type GetConduitShardsResponse struct {
        Data       []ConduitShard `json:"data"`
        Pagination *Pagination    `json:"pagination,omitempty"`
}

// GetConduitShards gets the shards for a conduit.
// Requires: App access token.
func (c *Client) GetConduitShards(ctx context.Context, params *GetConduitShardsParams) (*GetConduitShardsResponse, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("conduit_id", params.ConduitID)
        if params.Status != "" </span><span class="cov0" title="0">{
                q.Set("status", params.Status)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp GetConduitShardsResponse
        if err := c.get(ctx, "/eventsub/conduits/shards", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// UpdateConduitShardsParams contains parameters for UpdateConduitShards.
type UpdateConduitShardsParams struct {
        ConduitID string                     `json:"conduit_id"`
        Shards    []UpdateConduitShardParams `json:"shards"`
}

// UpdateConduitShardParams represents parameters for a single shard update.
type UpdateConduitShardParams struct {
        ID        string                      `json:"id"`
        Transport UpdateConduitShardTransport `json:"transport"`
}

// UpdateConduitShardTransport represents transport parameters for shard update.
type UpdateConduitShardTransport struct {
        Method    string `json:"method"`
        Callback  string `json:"callback,omitempty"`
        Secret    string `json:"secret,omitempty"`
        SessionID string `json:"session_id,omitempty"`
}

// UpdateConduitShardsResponse represents the response from UpdateConduitShards.
type UpdateConduitShardsResponse struct {
        Data   []ConduitShard `json:"data"`
        Errors []struct {
                ID      string `json:"id"`
                Message string `json:"message"`
                Code    string `json:"code"`
        } `json:"errors,omitempty"`
}

// UpdateConduitShards updates shards for a conduit.
// Requires: App access token.
func (c *Client) UpdateConduitShards(ctx context.Context, params *UpdateConduitShardsParams) (*UpdateConduitShardsResponse, error) <span class="cov0" title="0">{
        var resp UpdateConduitShardsResponse
        if err := c.patch(ctx, "/eventsub/conduits/shards", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// DropsEntitlement represents a drops entitlement.
type DropsEntitlement struct {
        ID                string    `json:"id"`
        BenefitID         string    `json:"benefit_id"`
        Timestamp         time.Time `json:"timestamp"`
        UserID            string    `json:"user_id"`
        GameID            string    `json:"game_id"`
        FulfillmentStatus string    `json:"fulfillment_status"` // CLAIMED, FULFILLED
        LastUpdated       time.Time `json:"last_updated"`
}

// GetDropsEntitlementsParams contains parameters for GetDropsEntitlements.
type GetDropsEntitlementsParams struct {
        ID                string // Entitlement ID
        UserID            string // Filter by user
        GameID            string // Filter by game
        FulfillmentStatus string // CLAIMED, FULFILLED
        *PaginationParams
}

// GetDropsEntitlements gets drops entitlements.
// Requires: App access token or user token with viewing:activity:read scope.
func (c *Client) GetDropsEntitlements(ctx context.Context, params *GetDropsEntitlementsParams) (*Response[DropsEntitlement], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil </span><span class="cov0" title="0">{
                if params.ID != "" </span><span class="cov0" title="0">{
                        q.Set("id", params.ID)
                }</span>
                <span class="cov0" title="0">if params.UserID != "" </span><span class="cov0" title="0">{
                        q.Set("user_id", params.UserID)
                }</span>
                <span class="cov0" title="0">if params.GameID != "" </span><span class="cov0" title="0">{
                        q.Set("game_id", params.GameID)
                }</span>
                <span class="cov0" title="0">if params.FulfillmentStatus != "" </span><span class="cov0" title="0">{
                        q.Set("fulfillment_status", params.FulfillmentStatus)
                }</span>
                <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)</span>
        }

        <span class="cov0" title="0">var resp Response[DropsEntitlement]
        if err := c.get(ctx, "/entitlements/drops", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// UpdateDropsEntitlementsParams contains parameters for UpdateDropsEntitlements.
type UpdateDropsEntitlementsParams struct {
        EntitlementIDs    []string `json:"entitlement_ids"`    // Max 100
        FulfillmentStatus string   `json:"fulfillment_status"` // CLAIMED, FULFILLED
}

// UpdateDropsEntitlementsResponse represents the response from UpdateDropsEntitlements.
type UpdateDropsEntitlementsResponse struct {
        Status string   `json:"status"` // SUCCESS, INVALID_ID, NOT_FOUND, UNAUTHORIZED, UPDATE_FAILED
        IDs    []string `json:"ids"`
}

// UpdateDropsEntitlements updates the fulfillment status of drops entitlements.
// Requires: App access token or user token.
func (c *Client) UpdateDropsEntitlements(ctx context.Context, params *UpdateDropsEntitlementsParams) ([]UpdateDropsEntitlementsResponse, error) <span class="cov0" title="0">{
        var resp Response[UpdateDropsEntitlementsResponse]
        if err := c.patch(ctx, "/entitlements/drops", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// EventSubSubscription represents an EventSub subscription.
type EventSubSubscription struct {
        ID        string            `json:"id"`
        Status    string            `json:"status"`
        Type      string            `json:"type"`
        Version   string            `json:"version"`
        Condition map[string]string `json:"condition"`
        CreatedAt time.Time         `json:"created_at"`
        Transport EventSubTransport `json:"transport"`
        Cost      int               `json:"cost"`
}

// EventSubTransport represents the transport for an EventSub subscription.
type EventSubTransport struct {
        Method         string `json:"method"` // webhook, websocket, conduit
        Callback       string `json:"callback,omitempty"`
        Secret         string `json:"secret,omitempty"`
        SessionID      string `json:"session_id,omitempty"`
        ConduitID      string `json:"conduit_id,omitempty"`
        ConnectedAt    string `json:"connected_at,omitempty"`
        DisconnectedAt string `json:"disconnected_at,omitempty"`
}

// GetEventSubSubscriptionsParams contains parameters for GetEventSubSubscriptions.
type GetEventSubSubscriptionsParams struct {
        Status string // Filter by status
        Type   string // Filter by subscription type
        UserID string // Filter by user ID
        *PaginationParams
}

// EventSubResponse represents the response from EventSub operations.
type EventSubResponse struct {
        Data         []EventSubSubscription `json:"data"`
        Total        int                    `json:"total"`
        TotalCost    int                    `json:"total_cost"`
        MaxTotalCost int                    `json:"max_total_cost"`
        Pagination   *Pagination            `json:"pagination,omitempty"`
}

// GetEventSubSubscriptions gets EventSub subscriptions.
// Requires: App access token.
func (c *Client) GetEventSubSubscriptions(ctx context.Context, params *GetEventSubSubscriptionsParams) (*EventSubResponse, error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil </span><span class="cov0" title="0">{
                if params.Status != "" </span><span class="cov0" title="0">{
                        q.Set("status", params.Status)
                }</span>
                <span class="cov0" title="0">if params.Type != "" </span><span class="cov0" title="0">{
                        q.Set("type", params.Type)
                }</span>
                <span class="cov0" title="0">if params.UserID != "" </span><span class="cov0" title="0">{
                        q.Set("user_id", params.UserID)
                }</span>
                <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)</span>
        }

        <span class="cov0" title="0">var resp EventSubResponse
        if err := c.get(ctx, "/eventsub/subscriptions", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// CreateEventSubSubscriptionParams contains parameters for CreateEventSubSubscription.
type CreateEventSubSubscriptionParams struct {
        Type      string                  `json:"type"`
        Version   string                  `json:"version"`
        Condition map[string]string       `json:"condition"`
        Transport CreateEventSubTransport `json:"transport"`
}

// CreateEventSubTransport represents the transport when creating a subscription.
type CreateEventSubTransport struct {
        Method    string `json:"method"` // webhook, websocket, conduit
        Callback  string `json:"callback,omitempty"`
        Secret    string `json:"secret,omitempty"`
        SessionID string `json:"session_id,omitempty"`
        ConduitID string `json:"conduit_id,omitempty"`
}

// CreateEventSubSubscription creates an EventSub subscription.
// Requires: App access token.
func (c *Client) CreateEventSubSubscription(ctx context.Context, params *CreateEventSubSubscriptionParams) (*EventSubSubscription, error) <span class="cov0" title="0">{
        var resp EventSubResponse
        if err := c.post(ctx, "/eventsub/subscriptions", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// DeleteEventSubSubscription deletes an EventSub subscription.
// Requires: App access token.
func (c *Client) DeleteEventSubSubscription(ctx context.Context, subscriptionID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("id", subscriptionID)

        return c.delete(ctx, "/eventsub/subscriptions", q, nil)
}</span>

// EventSub subscription types - Automod
const (
        EventSubTypeAutomodMessageHold    = "automod.message.hold"
        EventSubTypeAutomodMessageUpdate  = "automod.message.update"
        EventSubTypeAutomodSettingsUpdate = "automod.settings.update"
        EventSubTypeAutomodTermsUpdate    = "automod.terms.update"
)

// EventSub subscription types - Channel
const (
        EventSubTypeChannelUpdate              = "channel.update"
        EventSubTypeChannelFollow              = "channel.follow"
        EventSubTypeChannelAdBreakBegin        = "channel.ad_break.begin"
        EventSubTypeChannelBitsUse             = "channel.bits.use"
        EventSubTypeChannelSubscribe           = "channel.subscribe"
        EventSubTypeChannelSubscriptionEnd     = "channel.subscription.end"
        EventSubTypeChannelSubscriptionGift    = "channel.subscription.gift"
        EventSubTypeChannelSubscriptionMessage = "channel.subscription.message"
        EventSubTypeChannelCheer               = "channel.cheer"
        EventSubTypeChannelRaid                = "channel.raid"
        EventSubTypeChannelBan                 = "channel.ban"
        EventSubTypeChannelUnban               = "channel.unban"
        EventSubTypeChannelUnbanRequestCreate  = "channel.unban_request.create"
        EventSubTypeChannelUnbanRequestResolve = "channel.unban_request.resolve"
        EventSubTypeChannelModerate            = "channel.moderate"
        EventSubTypeChannelModeratorAdd        = "channel.moderator.add"
        EventSubTypeChannelModeratorRemove     = "channel.moderator.remove"
        EventSubTypeChannelVIPAdd              = "channel.vip.add"
        EventSubTypeChannelVIPRemove           = "channel.vip.remove"
        EventSubTypeChannelWarningSend         = "channel.warning.send"
        EventSubTypeChannelWarningAcknowledge  = "channel.warning.acknowledge"
)

// EventSub subscription types - Channel Chat
const (
        EventSubTypeChannelChatClear             = "channel.chat.clear"
        EventSubTypeChannelChatClearUserMessages = "channel.chat.clear_user_messages"
        EventSubTypeChannelChatMessage           = "channel.chat.message"
        EventSubTypeChannelChatMessageDelete     = "channel.chat.message_delete"
        EventSubTypeChannelChatNotification      = "channel.chat.notification"
        EventSubTypeChannelChatSettingsUpdate    = "channel.chat_settings.update"
        EventSubTypeChannelChatUserMessageHold   = "channel.chat.user_message_hold"
        EventSubTypeChannelChatUserMessageUpdate = "channel.chat.user_message_update"
)

// EventSub subscription types - Channel Shared Chat
const (
        EventSubTypeChannelSharedChatBegin  = "channel.shared_chat.begin"
        EventSubTypeChannelSharedChatUpdate = "channel.shared_chat.update"
        EventSubTypeChannelSharedChatEnd    = "channel.shared_chat.end"
)

// EventSub subscription types - Channel Points
const (
        EventSubTypeChannelPointsAutomaticRewardRedemptionAdd = "channel.channel_points_automatic_reward_redemption.add"
        EventSubTypeChannelPointsRewardAdd                    = "channel.channel_points_custom_reward.add"
        EventSubTypeChannelPointsRewardUpdate                 = "channel.channel_points_custom_reward.update"
        EventSubTypeChannelPointsRewardRemove                 = "channel.channel_points_custom_reward.remove"
        EventSubTypeChannelPointsRedemptionAdd                = "channel.channel_points_custom_reward_redemption.add"
        EventSubTypeChannelPointsRedemptionUpdate             = "channel.channel_points_custom_reward_redemption.update"
)

// EventSub subscription types - Polls &amp; Predictions
const (
        EventSubTypeChannelPollBegin          = "channel.poll.begin"
        EventSubTypeChannelPollProgress       = "channel.poll.progress"
        EventSubTypeChannelPollEnd            = "channel.poll.end"
        EventSubTypeChannelPredictionBegin    = "channel.prediction.begin"
        EventSubTypeChannelPredictionProgress = "channel.prediction.progress"
        EventSubTypeChannelPredictionLock     = "channel.prediction.lock"
        EventSubTypeChannelPredictionEnd      = "channel.prediction.end"
)

// EventSub subscription types - Hype Train
const (
        EventSubTypeChannelHypeTrainBegin    = "channel.hype_train.begin"
        EventSubTypeChannelHypeTrainProgress = "channel.hype_train.progress"
        EventSubTypeChannelHypeTrainEnd      = "channel.hype_train.end"
)

// EventSub subscription types - Charity
const (
        EventSubTypeChannelCharityCampaignDonate   = "channel.charity_campaign.donate"
        EventSubTypeChannelCharityCampaignStart    = "channel.charity_campaign.start"
        EventSubTypeChannelCharityCampaignProgress = "channel.charity_campaign.progress"
        EventSubTypeChannelCharityCampaignStop     = "channel.charity_campaign.stop"
)

// EventSub subscription types - Goals
const (
        EventSubTypeChannelGoalBegin    = "channel.goal.begin"
        EventSubTypeChannelGoalProgress = "channel.goal.progress"
        EventSubTypeChannelGoalEnd      = "channel.goal.end"
)

// EventSub subscription types - Shield Mode
const (
        EventSubTypeChannelShieldModeBegin = "channel.shield_mode.begin"
        EventSubTypeChannelShieldModeEnd   = "channel.shield_mode.end"
)

// EventSub subscription types - Shoutout
const (
        EventSubTypeChannelShoutoutCreate  = "channel.shoutout.create"
        EventSubTypeChannelShoutoutReceive = "channel.shoutout.receive"
)

// EventSub subscription types - Suspicious User
const (
        EventSubTypeChannelSuspiciousUserMessage = "channel.suspicious_user.message"
        EventSubTypeChannelSuspiciousUserUpdate  = "channel.suspicious_user.update"
)

// EventSub subscription types - Guest Star (Beta)
const (
        EventSubTypeChannelGuestStarSessionBegin   = "channel.guest_star_session.begin"
        EventSubTypeChannelGuestStarSessionEnd     = "channel.guest_star_session.end"
        EventSubTypeChannelGuestStarGuestUpdate    = "channel.guest_star_guest.update"
        EventSubTypeChannelGuestStarSettingsUpdate = "channel.guest_star_settings.update"
)

// EventSub subscription types - Conduit
const (
        EventSubTypeConduitShardDisabled = "conduit.shard.disabled"
)

// EventSub subscription types - Drop
const (
        EventSubTypeDropEntitlementGrant = "drop.entitlement.grant"
)

// EventSub subscription types - Extension
const (
        EventSubTypeExtensionBitsTransactionCreate = "extension.bits_transaction.create"
)

// EventSub subscription types - Stream
const (
        EventSubTypeStreamOnline  = "stream.online"
        EventSubTypeStreamOffline = "stream.offline"
)

// EventSub subscription types - User
const (
        EventSubTypeUserAuthorizationGrant  = "user.authorization.grant"
        EventSubTypeUserAuthorizationRevoke = "user.authorization.revoke"
        EventSubTypeUserUpdate              = "user.update"
        EventSubTypeUserWhisperMessage      = "user.whisper.message"
)

// EventSub subscription statuses
const (
        EventSubStatusEnabled                            = "enabled"
        EventSubStatusWebhookCallbackVerificationPending = "webhook_callback_verification_pending"
        EventSubStatusWebhookCallbackVerificationFailed  = "webhook_callback_verification_failed"
        EventSubStatusNotificationFailuresExceeded       = "notification_failures_exceeded"
        EventSubStatusAuthorizationRevoked               = "authorization_revoked"
        EventSubStatusModeratorRemoved                   = "moderator_removed"
        EventSubStatusUserRemoved                        = "user_removed"
        EventSubStatusVersionRemoved                     = "version_removed"
        EventSubStatusBetaMaintenance                    = "beta_maintenance"
        EventSubStatusWebsocketDisconnected              = "websocket_disconnected"
        EventSubStatusWebsocketFailedPingPong            = "websocket_failed_ping_pong"
        EventSubStatusWebsocketReceivedInboundTraffic    = "websocket_received_inbound_traffic"
        EventSubStatusWebsocketConnectionUnused          = "websocket_connection_unused"
        EventSubStatusWebsocketInternalError             = "websocket_internal_error"
        EventSubStatusWebsocketNetworkTimeout            = "websocket_network_timeout"
        EventSubStatusWebsocketNetworkError              = "websocket_network_error"
        EventSubStatusWebsocketFailedToReconnect         = "websocket_failed_to_reconnect"
)

// EventSub transport methods
const (
        EventSubTransportWebhook   = "webhook"
        EventSubTransportWebSocket = "websocket"
        EventSubTransportConduit   = "conduit"
)

// EventSubTypeVersion maps subscription types to their latest versions.
var EventSubTypeVersion = map[string]string{
        // Automod
        EventSubTypeAutomodMessageHold:    "2",
        EventSubTypeAutomodMessageUpdate:  "2",
        EventSubTypeAutomodSettingsUpdate: "1",
        EventSubTypeAutomodTermsUpdate:    "1",
        // Channel
        EventSubTypeChannelUpdate:              "2",
        EventSubTypeChannelFollow:              "2",
        EventSubTypeChannelAdBreakBegin:        "1",
        EventSubTypeChannelBitsUse:             "1",
        EventSubTypeChannelSubscribe:           "1",
        EventSubTypeChannelSubscriptionEnd:     "1",
        EventSubTypeChannelSubscriptionGift:    "1",
        EventSubTypeChannelSubscriptionMessage: "1",
        EventSubTypeChannelCheer:               "1",
        EventSubTypeChannelRaid:                "1",
        EventSubTypeChannelBan:                 "1",
        EventSubTypeChannelUnban:               "1",
        EventSubTypeChannelUnbanRequestCreate:  "1",
        EventSubTypeChannelUnbanRequestResolve: "1",
        EventSubTypeChannelModerate:            "2",
        EventSubTypeChannelModeratorAdd:        "1",
        EventSubTypeChannelModeratorRemove:     "1",
        EventSubTypeChannelVIPAdd:              "1",
        EventSubTypeChannelVIPRemove:           "1",
        EventSubTypeChannelWarningSend:         "1",
        EventSubTypeChannelWarningAcknowledge:  "1",
        // Chat
        EventSubTypeChannelChatClear:             "1",
        EventSubTypeChannelChatClearUserMessages: "1",
        EventSubTypeChannelChatMessage:           "1",
        EventSubTypeChannelChatMessageDelete:     "1",
        EventSubTypeChannelChatNotification:      "1",
        EventSubTypeChannelChatSettingsUpdate:    "1",
        EventSubTypeChannelChatUserMessageHold:   "1",
        EventSubTypeChannelChatUserMessageUpdate: "1",
        // Shared Chat
        EventSubTypeChannelSharedChatBegin:  "1",
        EventSubTypeChannelSharedChatUpdate: "1",
        EventSubTypeChannelSharedChatEnd:    "1",
        // Channel Points
        EventSubTypeChannelPointsAutomaticRewardRedemptionAdd: "2",
        EventSubTypeChannelPointsRewardAdd:                    "1",
        EventSubTypeChannelPointsRewardUpdate:                 "1",
        EventSubTypeChannelPointsRewardRemove:                 "1",
        EventSubTypeChannelPointsRedemptionAdd:                "1",
        EventSubTypeChannelPointsRedemptionUpdate:             "1",
        // Polls &amp; Predictions
        EventSubTypeChannelPollBegin:          "1",
        EventSubTypeChannelPollProgress:       "1",
        EventSubTypeChannelPollEnd:            "1",
        EventSubTypeChannelPredictionBegin:    "1",
        EventSubTypeChannelPredictionProgress: "1",
        EventSubTypeChannelPredictionLock:     "1",
        EventSubTypeChannelPredictionEnd:      "1",
        // Hype Train
        EventSubTypeChannelHypeTrainBegin:    "1",
        EventSubTypeChannelHypeTrainProgress: "1",
        EventSubTypeChannelHypeTrainEnd:      "1",
        // Charity
        EventSubTypeChannelCharityCampaignDonate:   "1",
        EventSubTypeChannelCharityCampaignStart:    "1",
        EventSubTypeChannelCharityCampaignProgress: "1",
        EventSubTypeChannelCharityCampaignStop:     "1",
        // Goals
        EventSubTypeChannelGoalBegin:    "1",
        EventSubTypeChannelGoalProgress: "1",
        EventSubTypeChannelGoalEnd:      "1",
        // Shield Mode
        EventSubTypeChannelShieldModeBegin: "1",
        EventSubTypeChannelShieldModeEnd:   "1",
        // Shoutout
        EventSubTypeChannelShoutoutCreate:  "1",
        EventSubTypeChannelShoutoutReceive: "1",
        // Suspicious User
        EventSubTypeChannelSuspiciousUserMessage: "1",
        EventSubTypeChannelSuspiciousUserUpdate:  "1",
        // Guest Star (Beta)
        EventSubTypeChannelGuestStarSessionBegin:   "beta",
        EventSubTypeChannelGuestStarSessionEnd:     "beta",
        EventSubTypeChannelGuestStarGuestUpdate:    "beta",
        EventSubTypeChannelGuestStarSettingsUpdate: "beta",
        // Conduit
        EventSubTypeConduitShardDisabled: "1",
        // Drop
        EventSubTypeDropEntitlementGrant: "1",
        // Extension
        EventSubTypeExtensionBitsTransactionCreate: "1",
        // Stream
        EventSubTypeStreamOnline:  "1",
        EventSubTypeStreamOffline: "1",
        // User
        EventSubTypeUserAuthorizationGrant:  "1",
        EventSubTypeUserAuthorizationRevoke: "1",
        EventSubTypeUserUpdate:              "1",
        EventSubTypeUserWhisperMessage:      "1",
}

// GetEventSubVersion returns the latest version for a subscription type.
// Returns "1" if the type is not found.
func GetEventSubVersion(subType string) string <span class="cov0" title="0">{
        if v, ok := EventSubTypeVersion[subType]; ok </span><span class="cov0" title="0">{
                return v
        }</span>
        <span class="cov0" title="0">return "1"</span>
}

// EventSubCondition helpers for building common conditions.

// BroadcasterCondition returns a condition with broadcaster_user_id.
func BroadcasterCondition(broadcasterID string) map[string]string <span class="cov0" title="0">{
        return map[string]string{"broadcaster_user_id": broadcasterID}
}</span>

// BroadcasterModeratorCondition returns a condition with broadcaster and moderator IDs.
func BroadcasterModeratorCondition(broadcasterID, moderatorID string) map[string]string <span class="cov0" title="0">{
        return map[string]string{
                "broadcaster_user_id": broadcasterID,
                "moderator_user_id":   moderatorID,
        }
}</span>

// UserCondition returns a condition with user_id.
func UserCondition(userID string) map[string]string <span class="cov0" title="0">{
        return map[string]string{"user_id": userID}
}</span>

// FromToBroadcasterCondition returns a condition for raid events.
func FromToBroadcasterCondition(fromBroadcasterID, toBroadcasterID string) map[string]string <span class="cov0" title="0">{
        cond := make(map[string]string)
        if fromBroadcasterID != "" </span><span class="cov0" title="0">{
                cond["from_broadcaster_user_id"] = fromBroadcasterID
        }</span>
        <span class="cov0" title="0">if toBroadcasterID != "" </span><span class="cov0" title="0">{
                cond["to_broadcaster_user_id"] = toBroadcasterID
        }</span>
        <span class="cov0" title="0">return cond</span>
}

// ClientCondition returns a condition with client_id for extension events.
func ClientCondition(clientID string) map[string]string <span class="cov0" title="0">{
        return map[string]string{"client_id": clientID}
}</span>

// ConduitCondition returns a condition with conduit_id.
func ConduitCondition(conduitID string) map[string]string <span class="cov0" title="0">{
        return map[string]string{"conduit_id": conduitID}
}</span>

// RewardCondition returns a condition for channel points reward events.
func RewardCondition(broadcasterID, rewardID string) map[string]string <span class="cov0" title="0">{
        cond := map[string]string{"broadcaster_user_id": broadcasterID}
        if rewardID != "" </span><span class="cov0" title="0">{
                cond["reward_id"] = rewardID
        }</span>
        <span class="cov0" title="0">return cond</span>
}

// SubscribeToChannel is a helper to subscribe to a channel event using the latest version.
func (c *Client) SubscribeToChannel(ctx context.Context, eventType, broadcasterID string, transport CreateEventSubTransport) (*EventSubSubscription, error) <span class="cov0" title="0">{
        return c.CreateEventSubSubscription(ctx, &amp;CreateEventSubSubscriptionParams{
                Type:      eventType,
                Version:   GetEventSubVersion(eventType),
                Condition: BroadcasterCondition(broadcasterID),
                Transport: transport,
        })
}</span>

// SubscribeToChannelWithModerator is a helper to subscribe to channel events that require moderator.
func (c *Client) SubscribeToChannelWithModerator(ctx context.Context, eventType, broadcasterID, moderatorID string, transport CreateEventSubTransport) (*EventSubSubscription, error) <span class="cov0" title="0">{
        return c.CreateEventSubSubscription(ctx, &amp;CreateEventSubSubscriptionParams{
                Type:      eventType,
                Version:   GetEventSubVersion(eventType),
                Condition: BroadcasterModeratorCondition(broadcasterID, moderatorID),
                Transport: transport,
        })
}</span>

// SubscribeToUser is a helper to subscribe to user events using the latest version.
func (c *Client) SubscribeToUser(ctx context.Context, eventType, userID string, transport CreateEventSubTransport) (*EventSubSubscription, error) <span class="cov0" title="0">{
        return c.CreateEventSubSubscription(ctx, &amp;CreateEventSubSubscriptionParams{
                Type:      eventType,
                Version:   GetEventSubVersion(eventType),
                Condition: UserCondition(userID),
                Transport: transport,
        })
}</span>

// GetAllSubscriptions returns all EventSub subscriptions, handling pagination automatically.
func (c *Client) GetAllSubscriptions(ctx context.Context, params *GetEventSubSubscriptionsParams) ([]EventSubSubscription, error) <span class="cov0" title="0">{
        var all []EventSubSubscription
        if params == nil </span><span class="cov0" title="0">{
                params = &amp;GetEventSubSubscriptionsParams{}
        }</span>
        <span class="cov0" title="0">if params.PaginationParams == nil </span><span class="cov0" title="0">{
                params.PaginationParams = &amp;PaginationParams{}
        }</span>

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                resp, err := c.GetEventSubSubscriptions(ctx, params)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">all = append(all, resp.Data...)
                if resp.Pagination == nil || resp.Pagination.Cursor == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">params.After = resp.Pagination.Cursor</span>
        }
        <span class="cov0" title="0">return all, nil</span>
}

// DeleteAllSubscriptions deletes all EventSub subscriptions matching the filter.
func (c *Client) DeleteAllSubscriptions(ctx context.Context, params *GetEventSubSubscriptionsParams) (int, error) <span class="cov0" title="0">{
        subs, err := c.GetAllSubscriptions(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">deleted := 0
        for _, sub := range subs </span><span class="cov0" title="0">{
                if err := c.DeleteEventSubSubscription(ctx, sub.ID); err != nil </span><span class="cov0" title="0">{
                        return deleted, err
                }</span>
                <span class="cov0" title="0">deleted++</span>
        }
        <span class="cov0" title="0">return deleted, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package helix

import (
        "bytes"
        "crypto/hmac"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "sync"
        "time"
)

// EventSub webhook message types
const (
        EventSubMessageTypeNotification = "notification"
        EventSubMessageTypeVerification = "webhook_callback_verification"
        EventSubMessageTypeRevocation   = "revocation"
)

// EventSub headers
const (
        EventSubHeaderMessageID           = "Twitch-Eventsub-Message-Id"
        EventSubHeaderMessageTimestamp    = "Twitch-Eventsub-Message-Timestamp"
        EventSubHeaderMessageSignature    = "Twitch-Eventsub-Message-Signature"
        EventSubHeaderMessageType         = "Twitch-Eventsub-Message-Type"
        EventSubHeaderSubscriptionType    = "Twitch-Eventsub-Subscription-Type"
        EventSubHeaderSubscriptionVersion = "Twitch-Eventsub-Subscription-Version"
)

// EventSubWebhookMessage represents a message received from EventSub webhooks.
type EventSubWebhookMessage struct {
        MessageID           string
        MessageTimestamp    time.Time
        MessageType         string
        SubscriptionType    string
        SubscriptionVersion string
        Subscription        EventSubSubscription
        Challenge           string
        Event               json.RawMessage
}

// EventSubWebhookPayload represents the JSON payload from EventSub.
type EventSubWebhookPayload struct {
        Subscription EventSubSubscription `json:"subscription"`
        Challenge    string               `json:"challenge,omitempty"`
        Event        json.RawMessage      `json:"event,omitempty"`
}

// EventSubWebhookHandler handles EventSub webhook requests.
type EventSubWebhookHandler struct {
        secret          string
        maxTimestampAge time.Duration
        onNotification  func(*EventSubWebhookMessage)
        onVerification  func(*EventSubWebhookMessage) bool
        onRevocation    func(*EventSubWebhookMessage)
}

// EventSubWebhookOption configures the webhook handler.
type EventSubWebhookOption func(*EventSubWebhookHandler)

// WithWebhookSecret sets the secret used for signature verification.
func WithWebhookSecret(secret string) EventSubWebhookOption <span class="cov0" title="0">{
        return func(h *EventSubWebhookHandler) </span><span class="cov0" title="0">{
                h.secret = secret
        }</span>
}

// WithMaxTimestampAge sets the maximum age for message timestamps (default: 10 minutes).
func WithMaxTimestampAge(d time.Duration) EventSubWebhookOption <span class="cov0" title="0">{
        return func(h *EventSubWebhookHandler) </span><span class="cov0" title="0">{
                h.maxTimestampAge = d
        }</span>
}

// WithNotificationHandler sets the handler for notification messages.
func WithNotificationHandler(fn func(*EventSubWebhookMessage)) EventSubWebhookOption <span class="cov0" title="0">{
        return func(h *EventSubWebhookHandler) </span><span class="cov0" title="0">{
                h.onNotification = fn
        }</span>
}

// WithVerificationHandler sets the handler for verification challenges.
// Return true to accept the subscription, false to reject.
func WithVerificationHandler(fn func(*EventSubWebhookMessage) bool) EventSubWebhookOption <span class="cov0" title="0">{
        return func(h *EventSubWebhookHandler) </span><span class="cov0" title="0">{
                h.onVerification = fn
        }</span>
}

// WithRevocationHandler sets the handler for subscription revocations.
func WithRevocationHandler(fn func(*EventSubWebhookMessage)) EventSubWebhookOption <span class="cov0" title="0">{
        return func(h *EventSubWebhookHandler) </span><span class="cov0" title="0">{
                h.onRevocation = fn
        }</span>
}

// NewEventSubWebhookHandler creates a new EventSub webhook handler.
func NewEventSubWebhookHandler(opts ...EventSubWebhookOption) *EventSubWebhookHandler <span class="cov0" title="0">{
        h := &amp;EventSubWebhookHandler{
                maxTimestampAge: 10 * time.Minute,
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(h)
        }</span>
        <span class="cov0" title="0">return h</span>
}

// ServeHTTP implements http.Handler for the webhook handler.
func (h *EventSubWebhookHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        // Read body
        <span class="cov0" title="0">body, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to read body", http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = r.Body.Close() }</span>()

        // Verify signature
        <span class="cov0" title="0">if h.secret != "" </span><span class="cov0" title="0">{
                if !h.verifySignature(r.Header, body) </span><span class="cov0" title="0">{
                        http.Error(w, "Invalid signature", http.StatusForbidden)
                        return
                }</span>
        }

        // Parse message
        <span class="cov0" title="0">msg, err := h.parseMessage(r.Header, body)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        // Check timestamp age (replay attack prevention)
        <span class="cov0" title="0">if time.Since(msg.MessageTimestamp) &gt; h.maxTimestampAge </span><span class="cov0" title="0">{
                http.Error(w, "Message timestamp too old", http.StatusBadRequest)
                return
        }</span>

        // Handle based on message type
        <span class="cov0" title="0">switch msg.MessageType </span>{
        case EventSubMessageTypeVerification:<span class="cov0" title="0">
                h.handleVerification(w, msg)</span>
        case EventSubMessageTypeNotification:<span class="cov0" title="0">
                h.handleNotification(w, msg)</span>
        case EventSubMessageTypeRevocation:<span class="cov0" title="0">
                h.handleRevocation(w, msg)</span>
        default:<span class="cov0" title="0">
                http.Error(w, "Unknown message type", http.StatusBadRequest)</span>
        }
}

// verifySignature verifies the HMAC-SHA256 signature of the message.
func (h *EventSubWebhookHandler) verifySignature(headers http.Header, body []byte) bool <span class="cov0" title="0">{
        messageID := headers.Get(EventSubHeaderMessageID)
        timestamp := headers.Get(EventSubHeaderMessageTimestamp)
        signature := headers.Get(EventSubHeaderMessageSignature)

        if messageID == "" || timestamp == "" || signature == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        // Build the message to sign: message_id + message_timestamp + body
        <span class="cov0" title="0">message := []byte(messageID + timestamp)
        message = append(message, body...)

        // Compute HMAC-SHA256
        mac := hmac.New(sha256.New, []byte(h.secret))
        mac.Write(message)
        expectedSig := "sha256=" + hex.EncodeToString(mac.Sum(nil))

        // Constant-time comparison
        return hmac.Equal([]byte(expectedSig), []byte(signature))</span>
}

// parseMessage parses the webhook message from headers and body.
func (h *EventSubWebhookHandler) parseMessage(headers http.Header, body []byte) (*EventSubWebhookMessage, error) <span class="cov0" title="0">{
        timestamp, err := time.Parse(time.RFC3339, headers.Get(EventSubHeaderMessageTimestamp))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid timestamp: %w", err)
        }</span>

        <span class="cov0" title="0">var payload EventSubWebhookPayload
        if err := json.Unmarshal(body, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid payload: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;EventSubWebhookMessage{
                MessageID:           headers.Get(EventSubHeaderMessageID),
                MessageTimestamp:    timestamp,
                MessageType:         headers.Get(EventSubHeaderMessageType),
                SubscriptionType:    headers.Get(EventSubHeaderSubscriptionType),
                SubscriptionVersion: headers.Get(EventSubHeaderSubscriptionVersion),
                Subscription:        payload.Subscription,
                Challenge:           payload.Challenge,
                Event:               payload.Event,
        }, nil</span>
}

// handleVerification handles webhook verification challenges.
func (h *EventSubWebhookHandler) handleVerification(w http.ResponseWriter, msg *EventSubWebhookMessage) <span class="cov0" title="0">{
        accept := true
        if h.onVerification != nil </span><span class="cov0" title="0">{
                accept = h.onVerification(msg)
        }</span>

        <span class="cov0" title="0">if accept </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "text/plain")
                w.WriteHeader(http.StatusOK)
                _, _ = w.Write([]byte(msg.Challenge))
        }</span> else<span class="cov0" title="0"> {
                http.Error(w, "Subscription rejected", http.StatusBadRequest)
        }</span>
}

// handleNotification handles event notifications.
func (h *EventSubWebhookHandler) handleNotification(w http.ResponseWriter, msg *EventSubWebhookMessage) <span class="cov0" title="0">{
        if h.onNotification != nil </span><span class="cov0" title="0">{
                h.onNotification(msg)
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

// handleRevocation handles subscription revocations.
func (h *EventSubWebhookHandler) handleRevocation(w http.ResponseWriter, msg *EventSubWebhookMessage) <span class="cov0" title="0">{
        if h.onRevocation != nil </span><span class="cov0" title="0">{
                h.onRevocation(msg)
        }</span>
        <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
}

// VerifyEventSubSignature verifies an EventSub webhook signature.
// This is useful for custom handler implementations.
func VerifyEventSubSignature(secret, messageID, timestamp string, body []byte, signature string) bool <span class="cov0" title="0">{
        message := []byte(messageID + timestamp)
        message = append(message, body...)

        mac := hmac.New(sha256.New, []byte(secret))
        mac.Write(message)
        expectedSig := "sha256=" + hex.EncodeToString(mac.Sum(nil))

        return hmac.Equal([]byte(expectedSig), []byte(signature))
}</span>

// ParseEventSubEvent parses the event data from a webhook message into the provided type.
func ParseEventSubEvent[T any](msg *EventSubWebhookMessage) (*T, error) <span class="cov0" title="0">{
        var event T
        if err := json.Unmarshal(msg.Event, &amp;event); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing event: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;event, nil</span>
}

// EventSubMiddleware returns middleware that verifies EventSub signatures.
// Use this with your own http.Handler if you need more control.
func EventSubMiddleware(secret string, maxAge time.Duration) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // Read and buffer body
                        body, err := io.ReadAll(r.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                http.Error(w, "Failed to read body", http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov0" title="0">r.Body = io.NopCloser(bytes.NewReader(body))

                        // Verify signature
                        if !VerifyEventSubSignature(
                                secret,
                                r.Header.Get(EventSubHeaderMessageID),
                                r.Header.Get(EventSubHeaderMessageTimestamp),
                                body,
                                r.Header.Get(EventSubHeaderMessageSignature),
                        ) </span><span class="cov0" title="0">{
                                http.Error(w, "Invalid signature", http.StatusForbidden)
                                return
                        }</span>

                        // Check timestamp
                        <span class="cov0" title="0">timestamp, err := time.Parse(time.RFC3339, r.Header.Get(EventSubHeaderMessageTimestamp))
                        if err != nil || time.Since(timestamp) &gt; maxAge </span><span class="cov0" title="0">{
                                http.Error(w, "Invalid or expired timestamp", http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// MessageDeduplicator helps prevent processing duplicate EventSub messages.
// It is safe for concurrent use.
type MessageDeduplicator struct {
        mu      sync.Mutex
        seen    map[string]time.Time
        maxAge  time.Duration
        maxSize int
}

// NewMessageDeduplicator creates a new message deduplicator.
func NewMessageDeduplicator(maxAge time.Duration, maxSize int) *MessageDeduplicator <span class="cov0" title="0">{
        return &amp;MessageDeduplicator{
                seen:    make(map[string]time.Time),
                maxAge:  maxAge,
                maxSize: maxSize,
        }
}</span>

// IsDuplicate returns true if this message ID has been seen before.
// It also marks the message as seen. This method is safe for concurrent use.
func (d *MessageDeduplicator) IsDuplicate(messageID string) bool <span class="cov0" title="0">{
        d.mu.Lock()
        defer d.mu.Unlock()

        now := time.Now()

        // Clean up old entries if we're at capacity
        if len(d.seen) &gt;= d.maxSize </span><span class="cov0" title="0">{
                for id, seenAt := range d.seen </span><span class="cov0" title="0">{
                        if now.Sub(seenAt) &gt; d.maxAge </span><span class="cov0" title="0">{
                                delete(d.seen, id)
                        }</span>
                }
        }

        // Check if we've seen this message
        <span class="cov0" title="0">if _, ok := d.seen[messageID]; ok </span><span class="cov0" title="0">{
                return true
        }</span>

        // Mark as seen
        <span class="cov0" title="0">d.seen[messageID] = now
        return false</span>
}

// Clear removes all tracked message IDs. This method is safe for concurrent use.
func (d *MessageDeduplicator) Clear() <span class="cov0" title="0">{
        d.mu.Lock()
        d.seen = make(map[string]time.Time)
        d.mu.Unlock()
}</span>

// Common revocation reasons
const (
        RevocationReasonAuthorizationRevoked = "authorization_revoked"
        RevocationReasonUserRemoved          = "user_removed"
        RevocationReasonNotificationFailures = "notification_failures_exceeded"
        RevocationReasonVersionRemoved       = "version_removed"
        RevocationReasonModeratorsChanged    = "moderator_removed"
)

// GetRevocationReason extracts the revocation reason from a subscription status.
func GetRevocationReason(subscription EventSubSubscription) string <span class="cov0" title="0">{
        // Status contains the reason for revoked subscriptions
        if strings.HasPrefix(subscription.Status, "authorization_revoked") </span><span class="cov0" title="0">{
                return RevocationReasonAuthorizationRevoked
        }</span>
        <span class="cov0" title="0">return subscription.Status</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package helix

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "sync"
        "time"

        "github.com/gorilla/websocket"
)

const (
        // EventSubWebSocketURL is the Twitch EventSub WebSocket endpoint.
        EventSubWebSocketURL = "wss://eventsub.wss.twitch.tv/ws"
)

// WebSocket message types
const (
        WSMessageTypeWelcome      = "session_welcome"
        WSMessageTypeKeepalive    = "session_keepalive"
        WSMessageTypeNotification = "notification"
        WSMessageTypeReconnect    = "session_reconnect"
        WSMessageTypeRevocation   = "revocation"
)

// WebSocket close codes from Twitch
const (
        WSCloseInternalError         = 4000 // Internal server error
        WSCloseClientSentInbound     = 4001 // Client sent inbound traffic
        WSCloseClientFailedPingPong  = 4002 // Client failed ping-pong
        WSCloseConnectionUnused      = 4003 // Connection unused (no subscriptions within 10s)
        WSCloseReconnectGraceExpired = 4004 // Reconnect grace time expired
        WSCloseNetworkTimeout        = 4005 // Network timeout
        WSCloseNetworkError          = 4006 // Network error
        WSCloseInvalidReconnect      = 4007 // Invalid reconnect
)

// WebSocketMessage represents a message received from EventSub WebSocket.
type WebSocketMessage struct {
        Metadata WebSocketMetadata `json:"metadata"`
        Payload  json.RawMessage   `json:"payload"`
}

// WebSocketMetadata contains metadata about the WebSocket message.
type WebSocketMetadata struct {
        MessageID           string    `json:"message_id"`
        MessageType         string    `json:"message_type"`
        MessageTimestamp    time.Time `json:"message_timestamp"`
        SubscriptionType    string    `json:"subscription_type,omitempty"`
        SubscriptionVersion string    `json:"subscription_version,omitempty"`
}

// WebSocketWelcomePayload is the payload for welcome messages.
type WebSocketWelcomePayload struct {
        Session WebSocketSession `json:"session"`
}

// WebSocketSession contains session information.
type WebSocketSession struct {
        ID                      string    `json:"id"`
        Status                  string    `json:"status"`
        ConnectedAt             time.Time `json:"connected_at"`
        KeepaliveTimeoutSeconds int       `json:"keepalive_timeout_seconds"`
        ReconnectURL            string    `json:"reconnect_url,omitempty"`
}

// WebSocketReconnectPayload is the payload for reconnect messages.
type WebSocketReconnectPayload struct {
        Session WebSocketSession `json:"session"`
}

// WebSocketNotificationPayload is the payload for notification messages.
type WebSocketNotificationPayload struct {
        Subscription EventSubSubscription `json:"subscription"`
        Event        json.RawMessage      `json:"event"`
}

// EventSubWebSocketClient manages an EventSub WebSocket connection.
type EventSubWebSocketClient struct {
        url              string
        conn             *websocket.Conn
        sessionID        string
        keepaliveTimeout time.Duration

        // Handlers
        onWelcome      func(*WebSocketSession)
        onNotification func(subscription *EventSubSubscription, event json.RawMessage)
        onRevocation   func(*EventSubSubscription)
        onReconnect    func(reconnectURL string)
        onError        func(error)
        onKeepalive    func()

        // State
        mu           sync.RWMutex
        connected    bool
        connecting   bool // prevents concurrent Connect() calls
        stopChan     chan struct{}
        stopOnce     sync.Once  // ensures stopChan is closed only once
        wg           sync.WaitGroup // tracks readLoop goroutine
        reconnectURL string
}

// EventSubWSOption configures the WebSocket client.
type EventSubWSOption func(*EventSubWebSocketClient)

// WithWSURL sets a custom WebSocket URL (useful for testing).
func WithWSURL(url string) EventSubWSOption <span class="cov0" title="0">{
        return func(c *EventSubWebSocketClient) </span><span class="cov0" title="0">{
                c.url = url
        }</span>
}

// WithWSWelcomeHandler sets the handler for welcome messages.
func WithWSWelcomeHandler(fn func(*WebSocketSession)) EventSubWSOption <span class="cov0" title="0">{
        return func(c *EventSubWebSocketClient) </span><span class="cov0" title="0">{
                c.onWelcome = fn
        }</span>
}

// WithWSNotificationHandler sets the handler for notification messages.
func WithWSNotificationHandler(fn func(*EventSubSubscription, json.RawMessage)) EventSubWSOption <span class="cov0" title="0">{
        return func(c *EventSubWebSocketClient) </span><span class="cov0" title="0">{
                c.onNotification = fn
        }</span>
}

// WithWSRevocationHandler sets the handler for revocation messages.
func WithWSRevocationHandler(fn func(*EventSubSubscription)) EventSubWSOption <span class="cov0" title="0">{
        return func(c *EventSubWebSocketClient) </span><span class="cov0" title="0">{
                c.onRevocation = fn
        }</span>
}

// WithWSReconnectHandler sets the handler for reconnect messages.
func WithWSReconnectHandler(fn func(string)) EventSubWSOption <span class="cov0" title="0">{
        return func(c *EventSubWebSocketClient) </span><span class="cov0" title="0">{
                c.onReconnect = fn
        }</span>
}

// WithWSErrorHandler sets the handler for errors.
func WithWSErrorHandler(fn func(error)) EventSubWSOption <span class="cov0" title="0">{
        return func(c *EventSubWebSocketClient) </span><span class="cov0" title="0">{
                c.onError = fn
        }</span>
}

// WithWSKeepaliveHandler sets the handler for keepalive messages.
func WithWSKeepaliveHandler(fn func()) EventSubWSOption <span class="cov0" title="0">{
        return func(c *EventSubWebSocketClient) </span><span class="cov0" title="0">{
                c.onKeepalive = fn
        }</span>
}

// NewEventSubWebSocketClient creates a new EventSub WebSocket client.
func NewEventSubWebSocketClient(opts ...EventSubWSOption) *EventSubWebSocketClient <span class="cov0" title="0">{
        c := &amp;EventSubWebSocketClient{
                url:      EventSubWebSocketURL,
                stopChan: make(chan struct{}),
        }
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(c)
        }</span>
        <span class="cov0" title="0">return c</span>
}

// ErrAlreadyConnecting is returned when Connect is called while already connecting.
var ErrAlreadyConnecting = errors.New("connection already in progress")

// Connect establishes a WebSocket connection to EventSub.
// Returns the session ID that should be used when creating subscriptions.
// This method is safe for concurrent use - only one connection attempt will proceed.
func (c *EventSubWebSocketClient) Connect(ctx context.Context) (string, error) <span class="cov0" title="0">{
        c.mu.Lock()
        if c.connected </span><span class="cov0" title="0">{
                sessionID := c.sessionID
                c.mu.Unlock()
                return sessionID, nil
        }</span>
        <span class="cov0" title="0">if c.connecting </span><span class="cov0" title="0">{
                c.mu.Unlock()
                return "", ErrAlreadyConnecting
        }</span>
        <span class="cov0" title="0">c.connecting = true
        c.mu.Unlock()

        // Ensure we clear connecting flag on exit
        defer func() </span><span class="cov0" title="0">{
                c.mu.Lock()
                c.connecting = false
                c.mu.Unlock()
        }</span>()

        // Connect to WebSocket
        <span class="cov0" title="0">conn, _, err := websocket.DefaultDialer.DialContext(ctx, c.url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("connecting to websocket: %w", err)
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        c.conn = conn
        c.stopChan = make(chan struct{})
        c.stopOnce = sync.Once{} // reset for new connection
        c.mu.Unlock()

        // Wait for welcome message
        sessionID, err := c.waitForWelcome(ctx)
        if err != nil </span><span class="cov0" title="0">{
                _ = conn.Close()
                return "", err
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        c.sessionID = sessionID
        c.connected = true
        c.mu.Unlock()

        // Start message handler
        c.wg.Add(1)
        go c.readLoop()

        return sessionID, nil</span>
}

// waitForWelcome waits for and processes the welcome message.
func (c *EventSubWebSocketClient) waitForWelcome(ctx context.Context) (string, error) <span class="cov0" title="0">{
        // Set read deadline for welcome message (10 seconds per Twitch docs)
        _ = c.conn.SetReadDeadline(time.Now().Add(10 * time.Second))
        defer func() </span><span class="cov0" title="0">{ _ = c.conn.SetReadDeadline(time.Time{}) }</span>()

        <span class="cov0" title="0">_, data, err := c.conn.ReadMessage()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("reading welcome message: %w", err)
        }</span>

        <span class="cov0" title="0">var msg WebSocketMessage
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("parsing welcome message: %w", err)
        }</span>

        <span class="cov0" title="0">if msg.Metadata.MessageType != WSMessageTypeWelcome </span><span class="cov0" title="0">{
                return "", fmt.Errorf("expected welcome message, got %s", msg.Metadata.MessageType)
        }</span>

        <span class="cov0" title="0">var payload WebSocketWelcomePayload
        if err := json.Unmarshal(msg.Payload, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("parsing welcome payload: %w", err)
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        c.keepaliveTimeout = time.Duration(payload.Session.KeepaliveTimeoutSeconds) * time.Second
        c.mu.Unlock()

        if c.onWelcome != nil </span><span class="cov0" title="0">{
                c.onWelcome(&amp;payload.Session)
        }</span>

        <span class="cov0" title="0">return payload.Session.ID, nil</span>
}

// readLoop continuously reads messages from the WebSocket.
func (c *EventSubWebSocketClient) readLoop() <span class="cov0" title="0">{
        defer c.wg.Done()
        defer func() </span><span class="cov0" title="0">{
                c.mu.Lock()
                c.connected = false
                if c.conn != nil </span><span class="cov0" title="0">{
                        _ = c.conn.Close()
                }</span>
                <span class="cov0" title="0">c.mu.Unlock()</span>
        }()

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                // Capture connection and stopChan under lock
                c.mu.RLock()
                conn := c.conn
                stopChan := c.stopChan
                timeout := c.keepaliveTimeout
                c.mu.RUnlock()

                // Check if we should stop
                select </span>{
                case &lt;-stopChan:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0"></span>
                }

                // Check for nil connection
                <span class="cov0" title="0">if conn == nil </span><span class="cov0" title="0">{
                        return
                }</span>

                // Set read deadline based on keepalive timeout (with buffer)
                <span class="cov0" title="0">if timeout &gt; 0 </span><span class="cov0" title="0">{
                        _ = conn.SetReadDeadline(time.Now().Add(timeout + 10*time.Second))
                }</span>

                <span class="cov0" title="0">_, data, err := conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if c.onError != nil &amp;&amp; !errors.Is(err, websocket.ErrCloseSent) </span><span class="cov0" title="0">{
                                c.onError(fmt.Errorf("reading message: %w", err))
                        }</span>
                        <span class="cov0" title="0">return</span>
                }

                <span class="cov0" title="0">c.handleMessage(data)</span>
        }
}

// handleMessage processes a received WebSocket message.
func (c *EventSubWebSocketClient) handleMessage(data []byte) <span class="cov0" title="0">{
        var msg WebSocketMessage
        if err := json.Unmarshal(data, &amp;msg); err != nil </span><span class="cov0" title="0">{
                if c.onError != nil </span><span class="cov0" title="0">{
                        c.onError(fmt.Errorf("parsing message: %w", err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Recover from handler panics to prevent crashing the read loop
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        if c.onError != nil </span><span class="cov0" title="0">{
                                c.onError(fmt.Errorf("handler panic: %v", r))
                        }</span>
                }
        }()

        <span class="cov0" title="0">switch msg.Metadata.MessageType </span>{
        case WSMessageTypeKeepalive:<span class="cov0" title="0">
                if c.onKeepalive != nil </span><span class="cov0" title="0">{
                        c.onKeepalive()
                }</span>

        case WSMessageTypeNotification:<span class="cov0" title="0">
                c.handleNotification(msg)</span>

        case WSMessageTypeReconnect:<span class="cov0" title="0">
                c.handleReconnect(msg)</span>

        case WSMessageTypeRevocation:<span class="cov0" title="0">
                c.handleRevocation(msg)</span>
        }
}

// handleNotification processes a notification message.
func (c *EventSubWebSocketClient) handleNotification(msg WebSocketMessage) <span class="cov0" title="0">{
        if c.onNotification == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var payload WebSocketNotificationPayload
        if err := json.Unmarshal(msg.Payload, &amp;payload); err != nil </span><span class="cov0" title="0">{
                if c.onError != nil </span><span class="cov0" title="0">{
                        c.onError(fmt.Errorf("parsing notification: %w", err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.onNotification(&amp;payload.Subscription, payload.Event)</span>
}

// handleReconnect processes a reconnect message.
func (c *EventSubWebSocketClient) handleReconnect(msg WebSocketMessage) <span class="cov0" title="0">{
        var payload WebSocketReconnectPayload
        if err := json.Unmarshal(msg.Payload, &amp;payload); err != nil </span><span class="cov0" title="0">{
                if c.onError != nil </span><span class="cov0" title="0">{
                        c.onError(fmt.Errorf("parsing reconnect: %w", err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.mu.Lock()
        c.reconnectURL = payload.Session.ReconnectURL
        c.mu.Unlock()

        if c.onReconnect != nil </span><span class="cov0" title="0">{
                c.onReconnect(payload.Session.ReconnectURL)
        }</span>
}

// handleRevocation processes a revocation message.
func (c *EventSubWebSocketClient) handleRevocation(msg WebSocketMessage) <span class="cov0" title="0">{
        if c.onRevocation == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">var payload WebSocketNotificationPayload
        if err := json.Unmarshal(msg.Payload, &amp;payload); err != nil </span><span class="cov0" title="0">{
                if c.onError != nil </span><span class="cov0" title="0">{
                        c.onError(fmt.Errorf("parsing revocation: %w", err))
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.onRevocation(&amp;payload.Subscription)</span>
}

// Close closes the WebSocket connection.
func (c *EventSubWebSocketClient) Close() error <span class="cov0" title="0">{
        c.mu.Lock()
        if !c.connected </span><span class="cov0" title="0">{
                c.mu.Unlock()
                return nil
        }</span>

        // Signal readLoop to stop (only once to prevent panic)
        <span class="cov0" title="0">c.stopOnce.Do(func() </span><span class="cov0" title="0">{
                close(c.stopChan)
        }</span>)
        <span class="cov0" title="0">c.connected = false
        c.mu.Unlock()

        // Wait for readLoop to finish (it will close the connection)
        c.wg.Wait()

        return nil</span>
}

// SessionID returns the current session ID.
func (c *EventSubWebSocketClient) SessionID() string <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.sessionID
}</span>

// IsConnected returns whether the client is connected.
func (c *EventSubWebSocketClient) IsConnected() bool <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.connected
}</span>

// Reconnect connects to a new URL (typically from a reconnect message).
func (c *EventSubWebSocketClient) Reconnect(ctx context.Context, url string) (string, error) <span class="cov0" title="0">{
        // Stop old readLoop first
        c.mu.Lock()
        oldConn := c.conn
        if c.stopChan != nil </span><span class="cov0" title="0">{
                c.stopOnce.Do(func() </span><span class="cov0" title="0">{
                        close(c.stopChan)
                }</span>)
        }
        <span class="cov0" title="0">c.mu.Unlock()

        // Wait for old readLoop to finish
        c.wg.Wait()

        // Close old connection
        if oldConn != nil </span><span class="cov0" title="0">{
                _ = oldConn.Close()
        }</span>

        // Connect to new URL
        <span class="cov0" title="0">newConn, _, err := websocket.DefaultDialer.DialContext(ctx, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("connecting to reconnect URL: %w", err)
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        c.conn = newConn
        c.stopChan = make(chan struct{})
        c.stopOnce = sync.Once{} // reset for new connection
        c.mu.Unlock()

        // Wait for welcome on new connection
        sessionID, err := c.waitForWelcome(ctx)
        if err != nil </span><span class="cov0" title="0">{
                _ = newConn.Close()
                return "", err
        }</span>

        <span class="cov0" title="0">c.mu.Lock()
        c.sessionID = sessionID
        c.connected = true
        c.mu.Unlock()

        // Start new read loop
        c.wg.Add(1)
        go c.readLoop()

        return sessionID, nil</span>
}

// ParseWSEvent parses the event JSON into the specified type.
func ParseWSEvent[T any](eventData json.RawMessage) (*T, error) <span class="cov0" title="0">{
        var event T
        if err := json.Unmarshal(eventData, &amp;event); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing event: %w", err)
        }</span>
        <span class="cov0" title="0">return &amp;event, nil</span>
}

// EventSubWebSocket provides a higher-level interface for EventSub WebSocket.
type EventSubWebSocket struct {
        client    *Client
        ws        *EventSubWebSocketClient
        sessionID string

        mu       sync.RWMutex
        handlers map[string]func(json.RawMessage)
}

// NewEventSubWebSocket creates a new high-level EventSub WebSocket manager.
func NewEventSubWebSocket(helixClient *Client) *EventSubWebSocket <span class="cov0" title="0">{
        return &amp;EventSubWebSocket{
                client:   helixClient,
                handlers: make(map[string]func(json.RawMessage)),
        }
}</span>

// Connect establishes the WebSocket connection.
func (e *EventSubWebSocket) Connect(ctx context.Context) error <span class="cov0" title="0">{
        e.ws = NewEventSubWebSocketClient(
                WithWSNotificationHandler(func(sub *EventSubSubscription, event json.RawMessage) </span><span class="cov0" title="0">{
                        e.mu.RLock()
                        handler, ok := e.handlers[sub.Type]
                        e.mu.RUnlock()
                        if ok </span><span class="cov0" title="0">{
                                handler(event)
                        }</span>
                }),
        )

        <span class="cov0" title="0">sessionID, err := e.ws.Connect(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">e.sessionID = sessionID
        return nil</span>
}

// Subscribe creates a subscription for the given event type.
func (e *EventSubWebSocket) Subscribe(ctx context.Context, eventType, version string, condition map[string]string, handler func(json.RawMessage)) error <span class="cov0" title="0">{
        // Register handler
        e.mu.Lock()
        e.handlers[eventType] = handler
        e.mu.Unlock()

        // Create subscription via API
        _, err := e.client.CreateEventSubSubscription(ctx, &amp;CreateEventSubSubscriptionParams{
                Type:      eventType,
                Version:   version,
                Condition: condition,
                Transport: CreateEventSubTransport{
                        Method:    "websocket",
                        SessionID: e.sessionID,
                },
        })
        return err
}</span>

// Close closes the WebSocket connection.
func (e *EventSubWebSocket) Close() error <span class="cov0" title="0">{
        if e.ws != nil </span><span class="cov0" title="0">{
                return e.ws.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package helix

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "time"
)

// ExtensionJWTRole defines the role in an extension JWT.
type ExtensionJWTRole string

const (
        // ExtensionRoleExternal is used for EBS (Extension Backend Service) signed tokens.
        ExtensionRoleExternal ExtensionJWTRole = "external"
        // ExtensionRoleBroadcaster is used when acting as the broadcaster.
        ExtensionRoleBroadcaster ExtensionJWTRole = "broadcaster"
        // ExtensionRoleModerator is used when acting as a moderator.
        ExtensionRoleModerator ExtensionJWTRole = "moderator"
        // ExtensionRoleViewer is used when acting as a viewer.
        ExtensionRoleViewer ExtensionJWTRole = "viewer"
)

// ExtensionJWTClaims represents the claims in a Twitch Extension JWT.
type ExtensionJWTClaims struct {
        // Required claims
        Exp    int64            `json:"exp"`     // Expiration time (Unix timestamp)
        UserID string           `json:"user_id"` // Twitch user ID
        Role   ExtensionJWTRole `json:"role"`    // User's role

        // Optional claims
        ChannelID    string `json:"channel_id,omitempty"`     // Channel ID for channel-specific operations
        OpaqueUserID string `json:"opaque_user_id,omitempty"` // Opaque user identifier
        IsUnlinked   bool   `json:"is_unlinked,omitempty"`    // Whether user has not shared identity

        // PubSub specific
        PubsubPermsListen []string `json:"pubsub_perms_listen,omitempty"` // Channels to listen to
        PubsubPermsSend   []string `json:"pubsub_perms_send,omitempty"`   // Channels to send to
}

// ExtensionJWT represents an extension JWT configuration and signer.
type ExtensionJWT struct {
        extensionID string
        secret      []byte
        ownerID     string // Extension owner's user ID
}

// NewExtensionJWT creates a new extension JWT signer.
// The secret should be the base64-encoded secret from the Extension Settings page.
func NewExtensionJWT(extensionID, base64Secret, ownerID string) (*ExtensionJWT, error) <span class="cov0" title="0">{
        secret, err := base64.StdEncoding.DecodeString(base64Secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decoding secret: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;ExtensionJWT{
                extensionID: extensionID,
                secret:      secret,
                ownerID:     ownerID,
        }, nil</span>
}

// ExtensionID returns the extension ID.
func (e *ExtensionJWT) ExtensionID() string <span class="cov0" title="0">{
        return e.extensionID
}</span>

// OwnerID returns the extension owner's user ID.
func (e *ExtensionJWT) OwnerID() string <span class="cov0" title="0">{
        return e.ownerID
}</span>

// CreateToken creates a signed JWT with the given claims.
func (e *ExtensionJWT) CreateToken(claims *ExtensionJWTClaims) (string, error) <span class="cov0" title="0">{
        // Set default expiration if not set (1 hour)
        if claims.Exp == 0 </span><span class="cov0" title="0">{
                claims.Exp = time.Now().Add(time.Hour).Unix()
        }</span>

        // Create header
        <span class="cov0" title="0">header := map[string]string{
                "alg": "HS256",
                "typ": "JWT",
        }

        headerJSON, err := json.Marshal(header)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("marshaling header: %w", err)
        }</span>

        <span class="cov0" title="0">claimsJSON, err := json.Marshal(claims)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("marshaling claims: %w", err)
        }</span>

        // Encode header and claims
        <span class="cov0" title="0">headerB64 := base64URLEncode(headerJSON)
        claimsB64 := base64URLEncode(claimsJSON)

        // Create signature
        message := headerB64 + "." + claimsB64
        signature := e.sign([]byte(message))
        signatureB64 := base64URLEncode(signature)

        return message + "." + signatureB64, nil</span>
}

// CreateEBSToken creates a token for Extension Backend Service operations.
// This is the most common token type for server-to-server extension API calls.
func (e *ExtensionJWT) CreateEBSToken(expiration time.Duration) (string, error) <span class="cov0" title="0">{
        claims := &amp;ExtensionJWTClaims{
                Exp:    time.Now().Add(expiration).Unix(),
                UserID: e.ownerID,
                Role:   ExtensionRoleExternal,
        }
        return e.CreateToken(claims)
}</span>

// CreateBroadcasterToken creates a token for broadcaster-level operations.
func (e *ExtensionJWT) CreateBroadcasterToken(channelID string, expiration time.Duration) (string, error) <span class="cov0" title="0">{
        claims := &amp;ExtensionJWTClaims{
                Exp:       time.Now().Add(expiration).Unix(),
                UserID:    e.ownerID,
                Role:      ExtensionRoleBroadcaster,
                ChannelID: channelID,
        }
        return e.CreateToken(claims)
}</span>

// CreatePubSubToken creates a token for PubSub operations.
func (e *ExtensionJWT) CreatePubSubToken(channelID string, listen, send []string, expiration time.Duration) (string, error) <span class="cov0" title="0">{
        claims := &amp;ExtensionJWTClaims{
                Exp:               time.Now().Add(expiration).Unix(),
                UserID:            e.ownerID,
                Role:              ExtensionRoleExternal,
                ChannelID:         channelID,
                PubsubPermsListen: listen,
                PubsubPermsSend:   send,
        }
        return e.CreateToken(claims)
}</span>

// sign creates an HMAC-SHA256 signature.
func (e *ExtensionJWT) sign(message []byte) []byte <span class="cov0" title="0">{
        mac := hmac.New(sha256.New, e.secret)
        mac.Write(message)
        return mac.Sum(nil)
}</span>

// base64URLEncode encodes bytes to base64url without padding.
func base64URLEncode(data []byte) string <span class="cov0" title="0">{
        encoded := base64.RawURLEncoding.EncodeToString(data)
        return encoded
}</span>

// extensionTokenProvider is an adapter to provide extension JWT tokens.
type extensionTokenProvider struct {
        jwt   *ExtensionJWT
        token *Token
}

// GetToken returns the current token, generating a new one if expired.
func (p *extensionTokenProvider) GetToken() *Token <span class="cov0" title="0">{
        if p.token != nil &amp;&amp; time.Now().Before(p.token.ExpiresAt) </span><span class="cov0" title="0">{
                return p.token
        }</span>

        // Generate a new EBS token
        <span class="cov0" title="0">tokenStr, err := p.jwt.CreateEBSToken(time.Hour)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">p.token = &amp;Token{
                AccessToken: tokenStr,
                ExpiresAt:   time.Now().Add(time.Hour),
        }
        return p.token</span>
}

// NewExtensionClient creates a new Helix client with extension JWT authentication.
// This client automatically adds the extension JWT to API requests.
func NewExtensionClient(clientID string, jwt *ExtensionJWT, opts ...Option) *Client <span class="cov0" title="0">{
        client := NewClient(clientID, nil, opts...)
        client.tokenProvider = &amp;extensionTokenProvider{jwt: jwt}
        return client
}</span>

// SetExtensionJWT updates the Client to use extension JWT authentication.
// This modifies the client to use the provided JWT for all requests.
func (c *Client) SetExtensionJWT(jwt *ExtensionJWT) <span class="cov0" title="0">{
        c.authClient = nil
        c.tokenProvider = &amp;extensionTokenProvider{jwt: jwt}
}</span>

// WithExtensionJWT returns an Option to configure extension JWT authentication.
func WithExtensionJWT(jwt *ExtensionJWT) Option <span class="cov0" title="0">{
        return func(c *Client) </span><span class="cov0" title="0">{
                c.authClient = nil
                c.tokenProvider = &amp;extensionTokenProvider{jwt: jwt}
        }</span>
}

// ParseExtensionJWT parses and validates an extension JWT.
// This is useful for verifying JWTs received from the Twitch extension frontend.
func ParseExtensionJWT(tokenString, base64Secret string) (*ExtensionJWTClaims, error) <span class="cov0" title="0">{
        secret, err := base64.StdEncoding.DecodeString(base64Secret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decoding secret: %w", err)
        }</span>

        // Split token into parts
        <span class="cov0" title="0">parts := splitToken(tokenString)
        if len(parts) != 3 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid token format")
        }</span>

        // Verify signature
        <span class="cov0" title="0">message := parts[0] + "." + parts[1]
        mac := hmac.New(sha256.New, secret)
        mac.Write([]byte(message))
        expectedSig := mac.Sum(nil)

        sig, err := base64.RawURLEncoding.DecodeString(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decoding signature: %w", err)
        }</span>

        <span class="cov0" title="0">if !hmac.Equal(expectedSig, sig) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid signature")
        }</span>

        // Decode claims
        <span class="cov0" title="0">claimsJSON, err := base64.RawURLEncoding.DecodeString(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decoding claims: %w", err)
        }</span>

        <span class="cov0" title="0">var claims ExtensionJWTClaims
        if err := json.Unmarshal(claimsJSON, &amp;claims); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing claims: %w", err)
        }</span>

        // Check expiration
        <span class="cov0" title="0">if time.Now().Unix() &gt; claims.Exp </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token expired")
        }</span>

        <span class="cov0" title="0">return &amp;claims, nil</span>
}

// splitToken splits a JWT string into its parts.
func splitToken(token string) []string <span class="cov0" title="0">{
        var parts []string
        start := 0
        for i := 0; i &lt; len(token); i++ </span><span class="cov0" title="0">{
                if token[i] == '.' </span><span class="cov0" title="0">{
                        parts = append(parts, token[start:i])
                        start = i + 1
                }</span>
        }
        <span class="cov0" title="0">parts = append(parts, token[start:])
        return parts</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package helix

import (
        "context"
        "net/url"
        "strconv"
)

// ExtensionConfigurationSegment represents a configuration segment.
type ExtensionConfigurationSegment struct {
        Segment       string `json:"segment"` // broadcaster, developer, global
        BroadcasterID string `json:"broadcaster_id,omitempty"`
        Content       string `json:"content"`
        Version       string `json:"version"`
}

// GetExtensionConfigurationSegmentParams contains parameters for GetExtensionConfigurationSegment.
type GetExtensionConfigurationSegmentParams struct {
        ExtensionID   string
        Segment       []string // broadcaster, developer, global
        BroadcasterID string   // Required if segment includes "broadcaster"
}

// GetExtensionConfigurationSegment gets extension configuration segment data.
// Requires: JWT created by extension.
func (c *Client) GetExtensionConfigurationSegment(ctx context.Context, params *GetExtensionConfigurationSegmentParams) (*Response[ExtensionConfigurationSegment], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("extension_id", params.ExtensionID)
        for _, seg := range params.Segment </span><span class="cov0" title="0">{
                q.Add("segment", seg)
        }</span>
        <span class="cov0" title="0">if params.BroadcasterID != "" </span><span class="cov0" title="0">{
                q.Set("broadcaster_id", params.BroadcasterID)
        }</span>

        <span class="cov0" title="0">var resp Response[ExtensionConfigurationSegment]
        if err := c.get(ctx, "/extensions/configurations", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// SetExtensionConfigurationSegmentParams contains parameters for SetExtensionConfigurationSegment.
type SetExtensionConfigurationSegmentParams struct {
        ExtensionID   string `json:"extension_id"`
        Segment       string `json:"segment"` // broadcaster, developer, global
        BroadcasterID string `json:"broadcaster_id,omitempty"`
        Content       string `json:"content,omitempty"`
        Version       string `json:"version,omitempty"`
}

// SetExtensionConfigurationSegment sets extension configuration segment data.
// Requires: JWT created by extension.
func (c *Client) SetExtensionConfigurationSegment(ctx context.Context, params *SetExtensionConfigurationSegmentParams) error <span class="cov0" title="0">{
        return c.put(ctx, "/extensions/configurations", nil, params, nil)
}</span>

// SetExtensionRequiredConfigurationParams contains parameters for SetExtensionRequiredConfiguration.
type SetExtensionRequiredConfigurationParams struct {
        ExtensionID           string `json:"-"`
        ExtensionVersion      string `json:"extension_version"`
        RequiredConfiguration string `json:"required_configuration"`
}

// SetExtensionRequiredConfiguration sets the required configuration for an extension.
// Requires: JWT created by extension.
func (c *Client) SetExtensionRequiredConfiguration(ctx context.Context, params *SetExtensionRequiredConfigurationParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.ExtensionID)

        return c.put(ctx, "/extensions/required_configuration", q, params, nil)
}</span>

// SendExtensionPubSubMessageParams contains parameters for SendExtensionPubSubMessage.
type SendExtensionPubSubMessageParams struct {
        Target            []string `json:"target"` // broadcast, global, whisper-&lt;user_id&gt;
        BroadcasterID     string   `json:"broadcaster_id"`
        IsGlobalBroadcast bool     `json:"is_global_broadcast,omitempty"`
        Message           string   `json:"message"`
}

// SendExtensionPubSubMessage sends a PubSub message for an extension.
// Requires: JWT created by extension.
func (c *Client) SendExtensionPubSubMessage(ctx context.Context, params *SendExtensionPubSubMessageParams) error <span class="cov0" title="0">{
        return c.post(ctx, "/extensions/pubsub", nil, params, nil)
}</span>

// ExtensionLiveChannel represents a live channel using an extension.
type ExtensionLiveChannel struct {
        BroadcasterID   string `json:"broadcaster_id"`
        BroadcasterName string `json:"broadcaster_name"`
        GameName        string `json:"game_name"`
        GameID          string `json:"game_id"`
        Title           string `json:"title"`
}

// GetExtensionLiveChannelsParams contains parameters for GetExtensionLiveChannels.
type GetExtensionLiveChannelsParams struct {
        ExtensionID string
        *PaginationParams
}

// GetExtensionLiveChannels gets live channels that have an extension installed and activated.
func (c *Client) GetExtensionLiveChannels(ctx context.Context, params *GetExtensionLiveChannelsParams) (*Response[ExtensionLiveChannel], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("extension_id", params.ExtensionID)
        addPaginationParams(q, params.PaginationParams)

        var resp Response[ExtensionLiveChannel]
        if err := c.get(ctx, "/extensions/live", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ExtensionSecret represents an extension secret.
type ExtensionSecret struct {
        FormatVersion int                   `json:"format_version"`
        Secrets       []ExtensionSecretData `json:"secrets"`
}

// ExtensionSecretData represents the secret data.
type ExtensionSecretData struct {
        Content   string `json:"content"`
        ActiveAt  string `json:"active_at"`
        ExpiresAt string `json:"expires_at"`
}

// GetExtensionSecrets gets the secrets for an extension.
// Requires: JWT created by extension.
func (c *Client) GetExtensionSecrets(ctx context.Context, extensionID string) (*Response[ExtensionSecret], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("extension_id", extensionID)

        var resp Response[ExtensionSecret]
        if err := c.get(ctx, "/extensions/jwt/secrets", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// CreateExtensionSecret creates a new secret for an extension.
// Requires: JWT created by extension.
func (c *Client) CreateExtensionSecret(ctx context.Context, extensionID string, delay int) (*Response[ExtensionSecret], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("extension_id", extensionID)
        if delay &gt; 0 </span><span class="cov0" title="0">{
                q.Set("delay", strconv.Itoa(delay))
        }</span>

        <span class="cov0" title="0">var resp Response[ExtensionSecret]
        if err := c.post(ctx, "/extensions/jwt/secrets", q, nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// SendExtensionChatMessageParams contains parameters for SendExtensionChatMessage.
type SendExtensionChatMessageParams struct {
        BroadcasterID    string `json:"broadcaster_id"`
        Text             string `json:"text"`
        ExtensionID      string `json:"extension_id"`
        ExtensionVersion string `json:"extension_version"`
}

// SendExtensionChatMessage sends a chat message from an extension.
// Requires: JWT created by extension.
func (c *Client) SendExtensionChatMessage(ctx context.Context, params *SendExtensionChatMessageParams) error <span class="cov0" title="0">{
        return c.post(ctx, "/extensions/chat", nil, params, nil)
}</span>

// Extension represents a Twitch extension.
type Extension struct {
        AuthorName                string            `json:"author_name"`
        BitsEnabled               bool              `json:"bits_enabled"`
        CanInstall                bool              `json:"can_install"`
        ConfigurationLocation     string            `json:"configuration_location"`
        Description               string            `json:"description"`
        EULAToSURL                string            `json:"eula_tos_url"`
        HasChatSupport            bool              `json:"has_chat_support"`
        IconURL                   string            `json:"icon_url"`
        IconURLs                  map[string]string `json:"icon_urls"`
        ID                        string            `json:"id"`
        Name                      string            `json:"name"`
        PrivacyPolicyURL          string            `json:"privacy_policy_url"`
        RequestIdentityLink       bool              `json:"request_identity_link"`
        ScreenshotURLs            []string          `json:"screenshot_urls"`
        State                     string            `json:"state"`
        SubscriptionsSupportLevel string            `json:"subscriptions_support_level"`
        Summary                   string            `json:"summary"`
        SupportEmail              string            `json:"support_email"`
        Version                   string            `json:"version"`
        ViewerSummary             string            `json:"viewer_summary"`
        Views                     ExtensionViews    `json:"views"`
        AllowlistedConfigURLs     []string          `json:"allowlisted_config_urls"`
        AllowlistedPanelURLs      []string          `json:"allowlisted_panel_urls"`
}

// ExtensionViews represents the views configuration for an extension.
type ExtensionViews struct {
        Mobile       ExtensionView `json:"mobile,omitempty"`
        Panel        ExtensionView `json:"panel,omitempty"`
        VideoOverlay ExtensionView `json:"video_overlay,omitempty"`
        Component    ExtensionView `json:"component,omitempty"`
}

// ExtensionView represents a single view configuration.
type ExtensionView struct {
        ViewerURL              string `json:"viewer_url"`
        Height                 int    `json:"height,omitempty"`
        CanLinkExternalContent bool   `json:"can_link_external_content,omitempty"`
}

// GetExtensions gets information about extensions.
// Requires: JWT created by extension.
func (c *Client) GetExtensions(ctx context.Context, extensionID, extensionVersion string) (*Response[Extension], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("extension_id", extensionID)
        if extensionVersion != "" </span><span class="cov0" title="0">{
                q.Set("extension_version", extensionVersion)
        }</span>

        <span class="cov0" title="0">var resp Response[Extension]
        if err := c.get(ctx, "/extensions", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetReleasedExtensions gets information about a released extension.
func (c *Client) GetReleasedExtensions(ctx context.Context, extensionID, extensionVersion string) (*Response[Extension], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("extension_id", extensionID)
        if extensionVersion != "" </span><span class="cov0" title="0">{
                q.Set("extension_version", extensionVersion)
        }</span>

        <span class="cov0" title="0">var resp Response[Extension]
        if err := c.get(ctx, "/extensions/released", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ExtensionBitsProduct represents an extension Bits product.
type ExtensionBitsProduct struct {
        SKU           string            `json:"sku"`
        Cost          ExtensionBitsCost `json:"cost"`
        InDevelopment bool              `json:"in_development"`
        DisplayName   string            `json:"display_name"`
        Expiration    string            `json:"expiration,omitempty"`
        IsBroadcast   bool              `json:"is_broadcast"`
}

// ExtensionBitsCost represents the cost of an extension Bits product.
type ExtensionBitsCost struct {
        Amount int    `json:"amount"`
        Type   string `json:"type"` // bits
}

// GetExtensionBitsProductsParams contains parameters for GetExtensionBitsProducts.
type GetExtensionBitsProductsParams struct {
        ShouldIncludeAll bool // Include disabled/expired products
}

// GetExtensionBitsProducts gets Bits products for an extension.
// Requires: App access token for the extension.
func (c *Client) GetExtensionBitsProducts(ctx context.Context, params *GetExtensionBitsProductsParams) (*Response[ExtensionBitsProduct], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil &amp;&amp; params.ShouldIncludeAll </span><span class="cov0" title="0">{
                q.Set("should_include_all", "true")
        }</span>

        <span class="cov0" title="0">var resp Response[ExtensionBitsProduct]
        if err := c.get(ctx, "/bits/extensions", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// UpdateExtensionBitsProductParams contains parameters for UpdateExtensionBitsProduct.
type UpdateExtensionBitsProductParams struct {
        SKU           string            `json:"sku"`
        Cost          ExtensionBitsCost `json:"cost"`
        DisplayName   string            `json:"display_name"`
        InDevelopment bool              `json:"in_development,omitempty"`
        Expiration    string            `json:"expiration,omitempty"`
        IsBroadcast   bool              `json:"is_broadcast,omitempty"`
}

// UpdateExtensionBitsProduct updates an extension Bits product.
// Requires: App access token for the extension.
func (c *Client) UpdateExtensionBitsProduct(ctx context.Context, params *UpdateExtensionBitsProductParams) (*Response[ExtensionBitsProduct], error) <span class="cov0" title="0">{
        var resp Response[ExtensionBitsProduct]
        if err := c.put(ctx, "/bits/extensions", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ExtensionTransaction represents an extension transaction.
type ExtensionTransaction struct {
        ID               string                      `json:"id"`
        Timestamp        string                      `json:"timestamp"`
        BroadcasterID    string                      `json:"broadcaster_id"`
        BroadcasterLogin string                      `json:"broadcaster_login"`
        BroadcasterName  string                      `json:"broadcaster_name"`
        UserID           string                      `json:"user_id"`
        UserLogin        string                      `json:"user_login"`
        UserName         string                      `json:"user_name"`
        ProductType      string                      `json:"product_type"`
        ProductData      ExtensionTransactionProduct `json:"product_data"`
}

// ExtensionTransactionProduct represents the product in a transaction.
type ExtensionTransactionProduct struct {
        SKU           string            `json:"sku"`
        Cost          ExtensionBitsCost `json:"cost"`
        DisplayName   string            `json:"display_name"`
        InDevelopment bool              `json:"in_development"`
}

// GetExtensionTransactionsParams contains parameters for GetExtensionTransactions.
type GetExtensionTransactionsParams struct {
        ExtensionID string
        IDs         []string // Transaction IDs (max 100)
        *PaginationParams
}

// GetExtensionTransactions gets extension transactions.
// Requires: App access token for the extension.
func (c *Client) GetExtensionTransactions(ctx context.Context, params *GetExtensionTransactionsParams) (*Response[ExtensionTransaction], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("extension_id", params.ExtensionID)
        for _, id := range params.IDs </span><span class="cov0" title="0">{
                q.Add("id", id)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[ExtensionTransaction]
        if err := c.get(ctx, "/extensions/transactions", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package helix

import (
        "context"
        "net/url"
)

// Game represents a Twitch game/category.
type Game struct {
        ID        string `json:"id"`
        Name      string `json:"name"`
        BoxArtURL string `json:"box_art_url"`
        IGDBId    string `json:"igdb_id,omitempty"`
}

// GetGamesParams contains parameters for GetGames.
type GetGamesParams struct {
        IDs     []string // Game IDs (max 100)
        Names   []string // Game names (max 100)
        IGDBIDs []string // IGDB IDs (max 100)
}

// GetGames gets information about one or more games.
func (c *Client) GetGames(ctx context.Context, params *GetGamesParams) (*Response[Game], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil </span><span class="cov0" title="0">{
                for _, id := range params.IDs </span><span class="cov0" title="0">{
                        q.Add("id", id)
                }</span>
                <span class="cov0" title="0">for _, name := range params.Names </span><span class="cov0" title="0">{
                        q.Add("name", name)
                }</span>
                <span class="cov0" title="0">for _, igdbID := range params.IGDBIDs </span><span class="cov0" title="0">{
                        q.Add("igdb_id", igdbID)
                }</span>
        }

        <span class="cov0" title="0">var resp Response[Game]
        if err := c.get(ctx, "/games", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetTopGamesParams contains parameters for GetTopGames.
type GetTopGamesParams struct {
        *PaginationParams
}

// GetTopGames gets the top games/categories sorted by number of current viewers.
func (c *Client) GetTopGames(ctx context.Context, params *GetTopGamesParams) (*Response[Game], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil </span><span class="cov0" title="0">{
                addPaginationParams(q, params.PaginationParams)
        }</span>

        <span class="cov0" title="0">var resp Response[Game]
        if err := c.get(ctx, "/games/top", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// CreatorGoal represents a creator goal.
type CreatorGoal struct {
        ID               string    `json:"id"`
        BroadcasterID    string    `json:"broadcaster_id"`
        BroadcasterName  string    `json:"broadcaster_name"`
        BroadcasterLogin string    `json:"broadcaster_login"`
        Type             string    `json:"type"` // follower, subscription, subscription_count, new_subscription, new_subscription_count
        Description      string    `json:"description"`
        CurrentAmount    int       `json:"current_amount"`
        TargetAmount     int       `json:"target_amount"`
        CreatedAt        time.Time `json:"created_at"`
}

// GetCreatorGoals gets the creator goals for a channel.
// Requires: channel:read:goals scope.
func (c *Client) GetCreatorGoals(ctx context.Context, broadcasterID string) (*Response[CreatorGoal], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[CreatorGoal]
        if err := c.get(ctx, "/goals", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// HypeTrainEvent represents a hype train event.
type HypeTrainEvent struct {
        ID             string             `json:"id"`
        EventType      string             `json:"event_type"`
        EventTimestamp time.Time          `json:"event_timestamp"`
        Version        string             `json:"version"`
        EventData      HypeTrainEventData `json:"event_data"`
}

// HypeTrainEventData contains the hype train event data.
type HypeTrainEventData struct {
        ID               string                  `json:"id"`
        BroadcasterID    string                  `json:"broadcaster_id"`
        CooldownEndTime  time.Time               `json:"cooldown_end_time"`
        ExpiresAt        time.Time               `json:"expires_at"`
        Goal             int                     `json:"goal"`
        LastContribution HypeTrainContribution   `json:"last_contribution"`
        Level            int                     `json:"level"`
        StartedAt        time.Time               `json:"started_at"`
        TopContributions []HypeTrainContribution `json:"top_contributions"`
        Total            int                     `json:"total"`
}

// HypeTrainContribution represents a contribution to a hype train.
type HypeTrainContribution struct {
        Total int    `json:"total"`
        Type  string `json:"type"` // BITS, SUBS, OTHER
        User  string `json:"user"`
}

// GetHypeTrainEventsParams contains parameters for GetHypeTrainEvents.
type GetHypeTrainEventsParams struct {
        BroadcasterID string
        *PaginationParams
}

// GetHypeTrainEvents gets hype train events for a channel.
// Requires: channel:read:hype_train scope.
// Note: This endpoint is deprecated; use EventSub instead.
func (c *Client) GetHypeTrainEvents(ctx context.Context, params *GetHypeTrainEventsParams) (*Response[HypeTrainEvent], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        addPaginationParams(q, params.PaginationParams)

        var resp Response[HypeTrainEvent]
        if err := c.get(ctx, "/hypetrain/events", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// HypeTrainStatus represents the current hype train status.
type HypeTrainStatus struct {
        ID               string                  `json:"id"`
        BroadcasterID    string                  `json:"broadcaster_id"`
        Level            int                     `json:"level"`
        Total            int                     `json:"total"`
        Goal             int                     `json:"goal"`
        TopContributions []HypeTrainContribution `json:"top_contributions"`
        LastContribution HypeTrainContribution   `json:"last_contribution"`
        StartedAt        time.Time               `json:"started_at"`
        ExpiresAt        time.Time               `json:"expires_at"`
        CooldownEndTime  time.Time               `json:"cooldown_end_time"`
}

// GetHypeTrainStatus gets the current hype train status for a channel.
// Requires: channel:read:hype_train scope.
func (c *Client) GetHypeTrainStatus(ctx context.Context, broadcasterID string) (*HypeTrainStatus, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[HypeTrainStatus]
        if err := c.get(ctx, "/hypetrain/status", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package helix

import (
        "context"
        "net/url"
)

// GuestStarSettings represents channel Guest Star settings.
type GuestStarSettings struct {
        IsModeratorSendLiveEnabled  bool   `json:"is_moderator_send_live_enabled"`
        SlotCount                   int    `json:"slot_count"`
        IsBrowserSourceAudioEnabled bool   `json:"is_browser_source_audio_enabled"`
        GroupLayout                 string `json:"group_layout"` // TILED_LAYOUT, SCREENSHARE_LAYOUT, HORIZONTAL_LAYOUT, VERTICAL_LAYOUT
        BrowserSourceToken          string `json:"browser_source_token,omitempty"`
}

// GetChannelGuestStarSettings gets the Guest Star settings for a channel.
// Requires: channel:read:guest_star, channel:manage:guest_star, or moderator:read:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) GetChannelGuestStarSettings(ctx context.Context, broadcasterID, moderatorID string) (*GuestStarSettings, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("moderator_id", moderatorID)

        var resp Response[GuestStarSettings]
        if err := c.get(ctx, "/channels/guest_star_settings", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// UpdateChannelGuestStarSettingsParams contains parameters for UpdateChannelGuestStarSettings.
type UpdateChannelGuestStarSettingsParams struct {
        BroadcasterID               string `json:"-"`
        IsModeratorSendLiveEnabled  *bool  `json:"is_moderator_send_live_enabled,omitempty"`
        SlotCount                   *int   `json:"slot_count,omitempty"`
        IsBrowserSourceAudioEnabled *bool  `json:"is_browser_source_audio_enabled,omitempty"`
        GroupLayout                 string `json:"group_layout,omitempty"`
        RegenerateBrowserSources    *bool  `json:"regenerate_browser_sources,omitempty"`
}

// UpdateChannelGuestStarSettings updates the Guest Star settings for a channel.
// Requires: channel:manage:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) UpdateChannelGuestStarSettings(ctx context.Context, params *UpdateChannelGuestStarSettingsParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)

        return c.put(ctx, "/channels/guest_star_settings", q, params, nil)
}</span>

// GuestStarSession represents a Guest Star session.
type GuestStarSession struct {
        ID     string           `json:"id"`
        Guests []GuestStarGuest `json:"guests"`
}

// GuestStarGuest represents a guest in a Guest Star session.
type GuestStarGuest struct {
        SlotID          string                 `json:"slot_id"`
        IsLive          bool                   `json:"is_live"`
        UserID          string                 `json:"user_id"`
        UserDisplayName string                 `json:"user_display_name"`
        UserLogin       string                 `json:"user_login"`
        Volume          int                    `json:"volume"`
        AssignedAt      string                 `json:"assigned_at"`
        AudioSettings   GuestStarAudioSettings `json:"audio_settings"`
        VideoSettings   GuestStarVideoSettings `json:"video_settings"`
}

// GuestStarAudioSettings represents audio settings for a guest.
type GuestStarAudioSettings struct {
        IsHostEnabled bool `json:"is_host_enabled"`
        IsSelfMuted   bool `json:"is_self_muted"`
        IsAvailable   bool `json:"is_available"`
}

// GuestStarVideoSettings represents video settings for a guest.
type GuestStarVideoSettings struct {
        IsHostEnabled bool `json:"is_host_enabled"`
        IsSelfMuted   bool `json:"is_self_muted"`
        IsAvailable   bool `json:"is_available"`
}

// GetGuestStarSession gets the active Guest Star session for a channel.
// Requires: channel:read:guest_star, channel:manage:guest_star, or moderator:read:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) GetGuestStarSession(ctx context.Context, broadcasterID, moderatorID string) (*GuestStarSession, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("moderator_id", moderatorID)

        var resp Response[GuestStarSession]
        if err := c.get(ctx, "/guest_star/session", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// CreateGuestStarSession creates a Guest Star session.
// Requires: channel:manage:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) CreateGuestStarSession(ctx context.Context, broadcasterID string) (*GuestStarSession, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[GuestStarSession]
        if err := c.post(ctx, "/guest_star/session", q, nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// EndGuestStarSession ends a Guest Star session.
// Requires: channel:manage:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) EndGuestStarSession(ctx context.Context, broadcasterID, sessionID string) (*GuestStarSession, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("session_id", sessionID)

        var resp Response[GuestStarSession]
        if err := c.delete(ctx, "/guest_star/session", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// GuestStarInvite represents a Guest Star invite.
type GuestStarInvite struct {
        UserID           string `json:"user_id"`
        InvitedAt        string `json:"invited_at"`
        Status           string `json:"status"` // INVITED, ACCEPTED, READY
        IsVideoEnabled   bool   `json:"is_video_enabled"`
        IsAudioEnabled   bool   `json:"is_audio_enabled"`
        IsVideoAvailable bool   `json:"is_video_available"`
        IsAudioAvailable bool   `json:"is_audio_available"`
}

// GetGuestStarInvites gets the pending invites for a Guest Star session.
// Requires: channel:read:guest_star, channel:manage:guest_star, or moderator:read:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) GetGuestStarInvites(ctx context.Context, broadcasterID, moderatorID, sessionID string) (*Response[GuestStarInvite], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("moderator_id", moderatorID)
        q.Set("session_id", sessionID)

        var resp Response[GuestStarInvite]
        if err := c.get(ctx, "/guest_star/invites", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// SendGuestStarInvite sends an invite to a Guest Star session.
// Requires: channel:manage:guest_star or moderator:manage:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) SendGuestStarInvite(ctx context.Context, broadcasterID, moderatorID, sessionID, guestID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("moderator_id", moderatorID)
        q.Set("session_id", sessionID)
        q.Set("guest_id", guestID)

        return c.post(ctx, "/guest_star/invites", q, nil, nil)
}</span>

// DeleteGuestStarInvite deletes an invite to a Guest Star session.
// Requires: channel:manage:guest_star or moderator:manage:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) DeleteGuestStarInvite(ctx context.Context, broadcasterID, moderatorID, sessionID, guestID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("moderator_id", moderatorID)
        q.Set("session_id", sessionID)
        q.Set("guest_id", guestID)

        return c.delete(ctx, "/guest_star/invites", q, nil)
}</span>

// AssignGuestStarSlot assigns a guest to a slot in a Guest Star session.
// Requires: channel:manage:guest_star or moderator:manage:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) AssignGuestStarSlot(ctx context.Context, broadcasterID, moderatorID, sessionID, guestID, slotID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("moderator_id", moderatorID)
        q.Set("session_id", sessionID)
        q.Set("guest_id", guestID)
        q.Set("slot_id", slotID)

        return c.post(ctx, "/guest_star/slot", q, nil, nil)
}</span>

// UpdateGuestStarSlotParams contains parameters for UpdateGuestStarSlot.
type UpdateGuestStarSlotParams struct {
        BroadcasterID     string `json:"-"`
        ModeratorID       string `json:"-"`
        SessionID         string `json:"-"`
        SourceSlotID      string `json:"-"`
        DestinationSlotID string `json:"-"`
}

// UpdateGuestStarSlot moves a guest from one slot to another.
// Requires: channel:manage:guest_star or moderator:manage:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) UpdateGuestStarSlot(ctx context.Context, params *UpdateGuestStarSlotParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)
        q.Set("session_id", params.SessionID)
        q.Set("source_slot_id", params.SourceSlotID)
        if params.DestinationSlotID != "" </span><span class="cov0" title="0">{
                q.Set("destination_slot_id", params.DestinationSlotID)
        }</span>

        <span class="cov0" title="0">return c.patch(ctx, "/guest_star/slot", q, nil, nil)</span>
}

// DeleteGuestStarSlot removes a guest from a slot.
// Requires: channel:manage:guest_star or moderator:manage:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) DeleteGuestStarSlot(ctx context.Context, broadcasterID, moderatorID, sessionID, guestID, slotID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("moderator_id", moderatorID)
        q.Set("session_id", sessionID)
        q.Set("guest_id", guestID)
        q.Set("slot_id", slotID)

        return c.delete(ctx, "/guest_star/slot", q, nil)
}</span>

// UpdateGuestStarSlotSettingsParams contains parameters for UpdateGuestStarSlotSettings.
type UpdateGuestStarSlotSettingsParams struct {
        BroadcasterID  string `json:"-"`
        ModeratorID    string `json:"-"`
        SessionID      string `json:"-"`
        SlotID         string `json:"-"`
        IsAudioEnabled *bool  `json:"is_audio_enabled,omitempty"`
        IsVideoEnabled *bool  `json:"is_video_enabled,omitempty"`
        IsLive         *bool  `json:"is_live,omitempty"`
        Volume         *int   `json:"volume,omitempty"`
}

// UpdateGuestStarSlotSettings updates the settings for a Guest Star slot.
// Requires: channel:manage:guest_star or moderator:manage:guest_star scope.
// Note: This is a BETA endpoint.
func (c *Client) UpdateGuestStarSlotSettings(ctx context.Context, params *UpdateGuestStarSlotSettingsParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)
        q.Set("session_id", params.SessionID)
        q.Set("slot_id", params.SlotID)

        return c.patch(ctx, "/guest_star/slot_settings", q, params, nil)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package helix

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
)

const (
        // IngestBaseURL is the base URL for the Twitch Ingest API.
        IngestBaseURL = "https://ingest.twitch.tv"
)

// IngestServer represents a Twitch ingest server for live video streaming.
type IngestServer struct {
        ID           int     `json:"_id"`
        Availability float64 `json:"availability"`
        Default      bool    `json:"default"`
        Name         string  `json:"name"`
        URLTemplate  string  `json:"url_template"`
        Priority     int     `json:"priority"`
}

// IngestServersResponse represents the response from the ingest servers endpoint.
type IngestServersResponse struct {
        Ingests []IngestServer `json:"ingests"`
}

// GetIngestServers returns a list of endpoints for ingesting live video into Twitch.
// This endpoint does not require authentication.
// Note: This endpoint uses a different base URL (ingest.twitch.tv) than the Helix API.
func (c *Client) GetIngestServers(ctx context.Context) (*IngestServersResponse, error) <span class="cov0" title="0">{
        baseURL := c.ingestBaseURL
        if baseURL == "" </span><span class="cov0" title="0">{
                baseURL = IngestBaseURL
        }</span>
        <span class="cov0" title="0">url := baseURL + "/ingests"

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("executing request: %w", err)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = resp.Body.Close() }</span>()

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading response body: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return nil, &amp;APIError{
                        StatusCode: resp.StatusCode,
                        ErrorType:  "ingest_error",
                        Message:    string(body),
                }
        }</span>

        <span class="cov0" title="0">var result IngestServersResponse
        if err := json.Unmarshal(body, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// GetIngestServerByName finds an ingest server by its name (location).
// Returns nil if no server with the given name is found.
func (r *IngestServersResponse) GetIngestServerByName(name string) *IngestServer <span class="cov0" title="0">{
        for i := range r.Ingests </span><span class="cov0" title="0">{
                if r.Ingests[i].Name == name </span><span class="cov0" title="0">{
                        return &amp;r.Ingests[i]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetRTMPURL returns the RTMP URL for this ingest server with the stream key inserted.
func (s *IngestServer) GetRTMPURL(streamKey string) string <span class="cov0" title="0">{
        // URL template looks like: rtmp://iad05.contribute.live-video.net/app/{stream_key}
        // Replace {stream_key} placeholder with actual key
        return replaceStreamKey(s.URLTemplate, streamKey)
}</span>

func replaceStreamKey(template, streamKey string) string <span class="cov0" title="0">{
        result := template
        for i := 0; i &lt; len(result); i++ </span><span class="cov0" title="0">{
                if i+12 &lt;= len(result) &amp;&amp; result[i:i+12] == "{stream_key}" </span><span class="cov0" title="0">{
                        result = result[:i] + streamKey + result[i+12:]
                        break</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package helix

import (
        "context"
        "errors"
        "fmt"
        "strings"
        "sync"
        "time"

        "github.com/gorilla/websocket"
)

const (
        // TwitchIRCWebSocket is the WebSocket URL for Twitch IRC.
        TwitchIRCWebSocket = "wss://irc-ws.chat.twitch.tv:443"

        // TwitchIRCTCP is the TCP address for Twitch IRC.
        TwitchIRCTCP = "irc.chat.twitch.tv:6697"
)

// IRC command constants
const (
        ircCAP         = "CAP"
        ircPASS        = "PASS"
        ircNICK        = "NICK"
        ircJOIN        = "JOIN"
        ircPART        = "PART"
        ircPRIVMSG     = "PRIVMSG"
        ircWHISPER     = "WHISPER"
        ircPING        = "PING"
        ircPONG        = "PONG"
        ircNOTICE      = "NOTICE"
        ircUSERNOTICE  = "USERNOTICE"
        ircROOMSTATE   = "ROOMSTATE"
        ircCLEARCHAT   = "CLEARCHAT"
        ircCLEARMSG    = "CLEARMSG"
        ircGLOBALUSERSTATE = "GLOBALUSERSTATE"
        ircUSERSTATE   = "USERSTATE"
        ircRECONNECT   = "RECONNECT"
)

// IRC errors
var (
        ErrIRCNotConnected  = errors.New("irc: not connected")
        ErrIRCAlreadyConnected = errors.New("irc: already connected")
        ErrIRCAuthFailed    = errors.New("irc: authentication failed")
)

// IRCClient manages a connection to Twitch IRC.
type IRCClient struct {
        url   string
        conn  *websocket.Conn
        nick  string
        token string

        // Channel tracking
        channels map[string]bool

        // Handlers
        onMessage         func(*ChatMessage)
        onJoin            func(channel, user string)
        onPart            func(channel, user string)
        onNotice          func(*Notice)
        onUserNotice      func(*UserNotice)
        onRoomState       func(*RoomState)
        onClearChat       func(*ClearChat)
        onClearMessage    func(*ClearMessage)
        onWhisper         func(*Whisper)
        onGlobalUserState func(*GlobalUserState)
        onUserState       func(*UserState)
        onError           func(error)
        onConnect         func()
        onDisconnect      func()
        onReconnect       func()
        onRawMessage      func(string)

        // State
        mu           sync.RWMutex
        connected    bool
        stopChan     chan struct{}
        stopOnce     sync.Once       // ensures stopChan is closed only once
        wg           sync.WaitGroup  // tracks readLoop goroutine
        writeMu      sync.Mutex
        globalState  *GlobalUserState
        pongReceived chan struct{}

        // Options
        autoReconnect  bool
        reconnectDelay time.Duration
        capabilities   []string
}

// IRCOption configures the IRC client.
type IRCOption func(*IRCClient)

// NewIRCClient creates a new IRC client.
// Returns nil if nick or token is empty.
func NewIRCClient(nick, token string, opts ...IRCOption) *IRCClient <span class="cov8" title="1">{
        // Validate inputs
        if nick == "" || token == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Ensure token has oauth: prefix
        <span class="cov8" title="1">if !strings.HasPrefix(token, "oauth:") </span><span class="cov8" title="1">{
                token = "oauth:" + token
        }</span>

        <span class="cov8" title="1">c := &amp;IRCClient{
                url:            TwitchIRCWebSocket,
                nick:           strings.ToLower(nick),
                token:          token,
                channels:       make(map[string]bool),
                autoReconnect:  true,
                reconnectDelay: 5 * time.Second,
                capabilities: []string{
                        "twitch.tv/tags",
                        "twitch.tv/commands",
                        "twitch.tv/membership",
                },
                pongReceived: make(chan struct{}, 1),
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(c)
        }</span>

        <span class="cov8" title="1">return c</span>
}

// WithIRCURL sets a custom WebSocket URL.
func WithIRCURL(url string) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.url = url
        }</span>
}

// WithAutoReconnect enables or disables auto-reconnect.
func WithAutoReconnect(enabled bool) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.autoReconnect = enabled
        }</span>
}

// WithReconnectDelay sets the delay between reconnection attempts.
func WithReconnectDelay(d time.Duration) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.reconnectDelay = d
        }</span>
}

// WithMessageHandler sets the handler for chat messages.
func WithMessageHandler(fn func(*ChatMessage)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onMessage = fn
        }</span>
}

// WithJoinHandler sets the handler for join events.
func WithJoinHandler(fn func(channel, user string)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onJoin = fn
        }</span>
}

// WithPartHandler sets the handler for part events.
func WithPartHandler(fn func(channel, user string)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onPart = fn
        }</span>
}

// WithNoticeHandler sets the handler for notice messages.
func WithNoticeHandler(fn func(*Notice)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onNotice = fn
        }</span>
}

// WithUserNoticeHandler sets the handler for user notices (subs, raids, etc.).
func WithUserNoticeHandler(fn func(*UserNotice)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onUserNotice = fn
        }</span>
}

// WithRoomStateHandler sets the handler for room state changes.
func WithRoomStateHandler(fn func(*RoomState)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onRoomState = fn
        }</span>
}

// WithClearChatHandler sets the handler for clear chat events.
func WithClearChatHandler(fn func(*ClearChat)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onClearChat = fn
        }</span>
}

// WithClearMessageHandler sets the handler for clear message events.
func WithClearMessageHandler(fn func(*ClearMessage)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onClearMessage = fn
        }</span>
}

// WithWhisperHandler sets the handler for whisper messages.
func WithWhisperHandler(fn func(*Whisper)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onWhisper = fn
        }</span>
}

// WithGlobalUserStateHandler sets the handler for global user state.
func WithGlobalUserStateHandler(fn func(*GlobalUserState)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onGlobalUserState = fn
        }</span>
}

// WithUserStateHandler sets the handler for user state.
func WithUserStateHandler(fn func(*UserState)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onUserState = fn
        }</span>
}

// WithIRCErrorHandler sets the handler for errors.
func WithIRCErrorHandler(fn func(error)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onError = fn
        }</span>
}

// WithConnectHandler sets the handler for successful connections.
func WithConnectHandler(fn func()) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onConnect = fn
        }</span>
}

// WithDisconnectHandler sets the handler for disconnections.
func WithDisconnectHandler(fn func()) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onDisconnect = fn
        }</span>
}

// WithReconnectHandler sets the handler for reconnection events.
func WithReconnectHandler(fn func()) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onReconnect = fn
        }</span>
}

// WithRawMessageHandler sets the handler for raw IRC messages.
func WithRawMessageHandler(fn func(string)) IRCOption <span class="cov8" title="1">{
        return func(c *IRCClient) </span><span class="cov8" title="1">{
                c.onRawMessage = fn
        }</span>
}

// Connect establishes a connection to Twitch IRC.
func (c *IRCClient) Connect(ctx context.Context) error <span class="cov8" title="1">{
        c.mu.Lock()
        if c.connected </span><span class="cov8" title="1">{
                c.mu.Unlock()
                return ErrIRCAlreadyConnected
        }</span>
        <span class="cov8" title="1">c.mu.Unlock()

        conn, _, err := websocket.DefaultDialer.DialContext(ctx, c.url, nil)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("connecting to IRC: %w", err)
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        c.conn = conn
        c.stopChan = make(chan struct{})
        c.stopOnce = sync.Once{} // reset for new connection
        c.mu.Unlock()

        // Request capabilities
        caps := strings.Join(c.capabilities, " ")
        if err := c.send(fmt.Sprintf("CAP REQ :%s", caps)); err != nil </span><span class="cov0" title="0">{
                _ = conn.Close()
                return fmt.Errorf("requesting capabilities: %w", err)
        }</span>

        // Authenticate
        <span class="cov8" title="1">if err := c.send(fmt.Sprintf("PASS %s", c.token)); err != nil </span><span class="cov0" title="0">{
                _ = conn.Close()
                return fmt.Errorf("sending PASS: %w", err)
        }</span>

        <span class="cov8" title="1">if err := c.send(fmt.Sprintf("NICK %s", c.nick)); err != nil </span><span class="cov0" title="0">{
                _ = conn.Close()
                return fmt.Errorf("sending NICK: %w", err)
        }</span>

        // Wait for authentication response
        <span class="cov8" title="1">if err := c.waitForAuth(ctx); err != nil </span><span class="cov8" title="1">{
                _ = conn.Close()
                return err
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        c.connected = true
        c.mu.Unlock()

        // Start read loop
        c.wg.Add(1)
        go c.readLoop()

        // Rejoin channels
        c.mu.RLock()
        channels := make([]string, 0, len(c.channels))
        for ch := range c.channels </span><span class="cov8" title="1">{
                channels = append(channels, ch)
        }</span>
        <span class="cov8" title="1">c.mu.RUnlock()

        if len(channels) &gt; 0 </span><span class="cov8" title="1">{
                _ = c.Join(channels...)
        }</span>

        <span class="cov8" title="1">if c.onConnect != nil </span><span class="cov8" title="1">{
                c.onConnect()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// waitForAuth waits for authentication confirmation.
func (c *IRCClient) waitForAuth(ctx context.Context) error <span class="cov8" title="1">{
        // Read messages until we get 001 (welcome) or NOTICE (auth failed)
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">_, data, err := c.conn.ReadMessage()
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("reading auth response: %w", err)
                }</span>

                <span class="cov8" title="1">lines := strings.Split(string(data), "\r\n")
                for _, line := range lines </span><span class="cov8" title="1">{
                        if line == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">msg := parseIRCMessage(line)

                        switch msg.Command </span>{
                        case "001":<span class="cov8" title="1"> // RPL_WELCOME
                                return nil</span>
                        case ircNOTICE:<span class="cov8" title="1">
                                if strings.Contains(msg.Trailing, "Login authentication failed") ||
                                        strings.Contains(msg.Trailing, "Improperly formatted auth") </span><span class="cov8" title="1">{
                                        return ErrIRCAuthFailed
                                }</span>
                        case ircGLOBALUSERSTATE:<span class="cov8" title="1">
                                c.mu.Lock()
                                c.globalState = parseGlobalUserState(msg)
                                c.mu.Unlock()
                                if c.onGlobalUserState != nil </span><span class="cov8" title="1">{
                                        c.onGlobalUserState(c.globalState)
                                }</span>
                        case ircCAP:<span class="cov8" title="1">
                                // CAP ACK - capabilities acknowledged
                                continue</span>
                        }
                }
        }
}

// readLoop continuously reads messages from the WebSocket.
func (c *IRCClient) readLoop() <span class="cov8" title="1">{
        defer c.wg.Done()
        defer func() </span><span class="cov8" title="1">{
                c.mu.Lock()
                wasConnected := c.connected
                autoReconnect := c.autoReconnect
                c.connected = false
                if c.conn != nil </span><span class="cov8" title="1">{
                        _ = c.conn.Close()
                }</span>
                <span class="cov8" title="1">c.mu.Unlock()

                if wasConnected &amp;&amp; c.onDisconnect != nil </span><span class="cov8" title="1">{
                        c.onDisconnect()
                }</span>

                // Auto-reconnect
                <span class="cov8" title="1">if wasConnected &amp;&amp; autoReconnect </span><span class="cov8" title="1">{
                        go c.reconnect()
                }</span>
        }()

        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                // Capture connection and stopChan under lock
                c.mu.RLock()
                conn := c.conn
                stopChan := c.stopChan
                c.mu.RUnlock()

                // Check if we should stop
                select </span>{
                case &lt;-stopChan:<span class="cov8" title="1">
                        return</span>
                default:<span class="cov8" title="1"></span>
                }

                // Check for nil connection
                <span class="cov8" title="1">if conn == nil </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">_, data, err := conn.ReadMessage()
                if err != nil </span><span class="cov8" title="1">{
                        if c.onError != nil &amp;&amp; !errors.Is(err, websocket.ErrCloseSent) </span><span class="cov8" title="1">{
                                c.onError(fmt.Errorf("reading message: %w", err))
                        }</span>
                        <span class="cov8" title="1">return</span>
                }

                <span class="cov8" title="1">lines := strings.Split(string(data), "\r\n")
                for _, line := range lines </span><span class="cov8" title="1">{
                        if line == "" </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if c.onRawMessage != nil </span><span class="cov8" title="1">{
                                c.onRawMessage(line)
                        }</span>

                        <span class="cov8" title="1">c.handleMessage(line)</span>
                }
        }
}

// handleMessage processes a single IRC message.
func (c *IRCClient) handleMessage(raw string) <span class="cov8" title="1">{
        // Recover from handler panics to prevent crashing the read loop
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        if c.onError != nil </span><span class="cov8" title="1">{
                                c.onError(fmt.Errorf("handler panic: %v", r))
                        }</span>
                }
        }()

        <span class="cov8" title="1">msg := parseIRCMessage(raw)

        switch msg.Command </span>{
        case ircPING:<span class="cov8" title="1">
                _ = c.send("PONG :" + msg.Trailing)</span>

        case ircPONG:<span class="cov8" title="1">
                select </span>{
                case c.pongReceived &lt;- struct{}{}:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }

        case ircPRIVMSG:<span class="cov8" title="1">
                if c.onMessage != nil </span><span class="cov8" title="1">{
                        c.onMessage(parseChatMessage(msg))
                }</span>

        case ircWHISPER:<span class="cov8" title="1">
                if c.onWhisper != nil </span><span class="cov8" title="1">{
                        c.onWhisper(parseWhisper(msg))
                }</span>

        case ircUSERNOTICE:<span class="cov8" title="1">
                if c.onUserNotice != nil </span><span class="cov8" title="1">{
                        c.onUserNotice(parseUserNotice(msg))
                }</span>

        case ircNOTICE:<span class="cov8" title="1">
                if c.onNotice != nil </span><span class="cov8" title="1">{
                        c.onNotice(parseNotice(msg))
                }</span>

        case ircROOMSTATE:<span class="cov8" title="1">
                if c.onRoomState != nil </span><span class="cov8" title="1">{
                        c.onRoomState(parseRoomState(msg))
                }</span>

        case ircCLEARCHAT:<span class="cov8" title="1">
                if c.onClearChat != nil </span><span class="cov8" title="1">{
                        c.onClearChat(parseClearChat(msg))
                }</span>

        case ircCLEARMSG:<span class="cov8" title="1">
                if c.onClearMessage != nil </span><span class="cov8" title="1">{
                        c.onClearMessage(parseClearMessage(msg))
                }</span>

        case ircGLOBALUSERSTATE:<span class="cov8" title="1">
                state := parseGlobalUserState(msg)
                c.mu.Lock()
                c.globalState = state
                c.mu.Unlock()
                if c.onGlobalUserState != nil </span><span class="cov8" title="1">{
                        c.onGlobalUserState(state)
                }</span>

        case ircUSERSTATE:<span class="cov8" title="1">
                if c.onUserState != nil </span><span class="cov8" title="1">{
                        c.onUserState(parseUserState(msg))
                }</span>

        case ircJOIN:<span class="cov8" title="1">
                if c.onJoin != nil </span><span class="cov8" title="1">{
                        channel := ""
                        if len(msg.Params) &gt; 0 </span><span class="cov8" title="1">{
                                channel = parseChannel(msg.Params[0])
                        }</span>
                        <span class="cov8" title="1">user := parseUserFromPrefix(msg.Prefix)
                        c.onJoin(channel, user)</span>
                }

        case ircPART:<span class="cov8" title="1">
                if c.onPart != nil </span><span class="cov8" title="1">{
                        channel := ""
                        if len(msg.Params) &gt; 0 </span><span class="cov8" title="1">{
                                channel = parseChannel(msg.Params[0])
                        }</span>
                        <span class="cov8" title="1">user := parseUserFromPrefix(msg.Prefix)
                        c.onPart(channel, user)</span>
                }

        case ircRECONNECT:<span class="cov8" title="1">
                // Twitch is requesting we reconnect - close connection and let readLoop handle reconnection.
                // Don't set connected=false here; readLoop's defer will do it after capturing wasConnected=true.
                c.mu.Lock()
                if c.conn != nil </span><span class="cov8" title="1">{
                        _ = c.conn.Close()
                }</span>
                <span class="cov8" title="1">c.mu.Unlock()</span>
        }
}

// reconnect attempts to reconnect to IRC.
func (c *IRCClient) reconnect() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                // Capture state under lock
                c.mu.RLock()
                stopChan := c.stopChan
                autoReconnect := c.autoReconnect
                c.mu.RUnlock()

                // Check if we should stop reconnecting
                if !autoReconnect </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">select </span>{
                case &lt;-stopChan:<span class="cov0" title="0">
                        return</span>
                case &lt;-time.After(c.reconnectDelay):<span class="cov8" title="1"></span>
                }

                // Re-check autoReconnect after delay
                <span class="cov8" title="1">c.mu.RLock()
                autoReconnect = c.autoReconnect
                c.mu.RUnlock()
                if !autoReconnect </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">if c.onReconnect != nil </span><span class="cov8" title="1">{
                        c.onReconnect()
                }</span>

                <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
                err := c.Connect(ctx)
                cancel()

                if err == nil </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">if c.onError != nil </span><span class="cov8" title="1">{
                        c.onError(fmt.Errorf("reconnect failed: %w", err))
                }</span>
        }
}

// send sends a raw IRC message.
func (c *IRCClient) send(message string) error <span class="cov8" title="1">{
        c.writeMu.Lock()
        defer c.writeMu.Unlock()

        c.mu.RLock()
        conn := c.conn
        c.mu.RUnlock()

        if conn == nil </span><span class="cov8" title="1">{
                return ErrIRCNotConnected
        }</span>

        <span class="cov8" title="1">return conn.WriteMessage(websocket.TextMessage, []byte(message+"\r\n"))</span>
}

// Close closes the IRC connection.
func (c *IRCClient) Close() error <span class="cov8" title="1">{
        c.mu.Lock()
        if !c.connected </span><span class="cov8" title="1">{
                c.mu.Unlock()
                return nil
        }</span>

        <span class="cov8" title="1">c.autoReconnect = false
        c.connected = false

        // Signal readLoop to stop (only once to prevent panic)
        if c.stopChan != nil </span><span class="cov8" title="1">{
                c.stopOnce.Do(func() </span><span class="cov8" title="1">{
                        close(c.stopChan)
                }</span>)
        }
        <span class="cov8" title="1">c.mu.Unlock()

        // Wait for readLoop to finish (it will close the connection)
        c.wg.Wait()

        return nil</span>
}

// IsConnected returns whether the client is connected.
func (c *IRCClient) IsConnected() bool <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.connected
}</span>

// Join joins one or more channels.
func (c *IRCClient) Join(channels ...string) error <span class="cov8" title="1">{
        c.mu.Lock()
        for _, ch := range channels </span><span class="cov8" title="1">{
                c.channels[strings.ToLower(strings.TrimPrefix(ch, "#"))] = true
        }</span>
        <span class="cov8" title="1">c.mu.Unlock()

        if !c.IsConnected() </span><span class="cov8" title="1">{
                return nil // Will join on connect
        }</span>

        <span class="cov8" title="1">for _, ch := range channels </span><span class="cov8" title="1">{
                ch = strings.ToLower(strings.TrimPrefix(ch, "#"))
                if err := c.send(fmt.Sprintf("JOIN #%s", ch)); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("joining %s: %w", ch, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Part leaves one or more channels.
func (c *IRCClient) Part(channels ...string) error <span class="cov8" title="1">{
        c.mu.Lock()
        for _, ch := range channels </span><span class="cov8" title="1">{
                delete(c.channels, strings.ToLower(strings.TrimPrefix(ch, "#")))
        }</span>
        <span class="cov8" title="1">c.mu.Unlock()

        if !c.IsConnected() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, ch := range channels </span><span class="cov8" title="1">{
                ch = strings.ToLower(strings.TrimPrefix(ch, "#"))
                if err := c.send(fmt.Sprintf("PART #%s", ch)); err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("parting %s: %w", ch, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Say sends a message to a channel.
func (c *IRCClient) Say(channel, message string) error <span class="cov8" title="1">{
        channel = strings.ToLower(strings.TrimPrefix(channel, "#"))
        return c.send(fmt.Sprintf("PRIVMSG #%s :%s", channel, message))
}</span>

// Reply sends a reply to a message.
func (c *IRCClient) Reply(channel, parentMsgID, message string) error <span class="cov8" title="1">{
        channel = strings.ToLower(strings.TrimPrefix(channel, "#"))
        return c.send(fmt.Sprintf("@reply-parent-msg-id=%s PRIVMSG #%s :%s", parentMsgID, channel, message))
}</span>

// Whisper sends a whisper to a user.
// Note: Whispers require verified bot status for high volume.
func (c *IRCClient) Whisper(user, message string) error <span class="cov8" title="1">{
        return c.send(fmt.Sprintf("PRIVMSG #jtv :/w %s %s", user, message))
}</span>

// GetGlobalUserState returns the global user state.
func (c *IRCClient) GetGlobalUserState() *GlobalUserState <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.globalState
}</span>

// GetJoinedChannels returns the list of joined channels.
func (c *IRCClient) GetJoinedChannels() []string <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        channels := make([]string, 0, len(c.channels))
        for ch := range c.channels </span><span class="cov8" title="1">{
                channels = append(channels, ch)
        }</span>
        <span class="cov8" title="1">return channels</span>
}

// Ping sends a PING and waits for PONG.
func (c *IRCClient) Ping(ctx context.Context) error <span class="cov8" title="1">{
        // Drain all pending pongs
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-c.pongReceived:<span class="cov8" title="1">
                        continue</span>
                default:<span class="cov8" title="1"></span>
                }
                <span class="cov8" title="1">break</span>
        }

        <span class="cov8" title="1">if err := c.send("PING :tmi.twitch.tv"); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return ctx.Err()</span>
        case &lt;-c.pongReceived:<span class="cov8" title="1">
                return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package helix

import (
        "strconv"
        "strings"
        "time"
)

// parseIRCMessage parses a raw IRC message into an IRCMessage struct.
// Format: [@tags] [:prefix] COMMAND [params...] [:trailing]
func parseIRCMessage(raw string) *IRCMessage <span class="cov8" title="1">{
        msg := &amp;IRCMessage{
                Raw:  raw,
                Tags: make(map[string]string),
        }

        raw = strings.TrimSpace(raw)
        if raw == "" </span><span class="cov0" title="0">{
                return msg
        }</span>

        <span class="cov8" title="1">pos := 0

        // Parse tags (starts with @)
        if raw[pos] == '@' </span><span class="cov8" title="1">{
                end := strings.Index(raw, " ")
                if end == -1 </span><span class="cov0" title="0">{
                        return msg
                }</span>
                <span class="cov8" title="1">msg.Tags = parseTags(raw[1:end])
                pos = end + 1</span>
        }

        // Skip whitespace
        <span class="cov8" title="1">for pos &lt; len(raw) &amp;&amp; raw[pos] == ' ' </span><span class="cov0" title="0">{
                pos++
        }</span>

        // Parse prefix (starts with :)
        <span class="cov8" title="1">if pos &lt; len(raw) &amp;&amp; raw[pos] == ':' </span><span class="cov8" title="1">{
                end := strings.Index(raw[pos:], " ")
                if end == -1 </span><span class="cov0" title="0">{
                        msg.Prefix = raw[pos+1:]
                        return msg
                }</span>
                <span class="cov8" title="1">msg.Prefix = raw[pos+1 : pos+end]
                pos = pos + end + 1</span>
        }

        // Skip whitespace
        <span class="cov8" title="1">for pos &lt; len(raw) &amp;&amp; raw[pos] == ' ' </span><span class="cov0" title="0">{
                pos++
        }</span>

        // Parse command
        <span class="cov8" title="1">end := strings.Index(raw[pos:], " ")
        if end == -1 </span><span class="cov8" title="1">{
                msg.Command = raw[pos:]
                return msg
        }</span>
        <span class="cov8" title="1">msg.Command = raw[pos : pos+end]
        pos = pos + end + 1

        // Skip whitespace
        for pos &lt; len(raw) &amp;&amp; raw[pos] == ' ' </span><span class="cov0" title="0">{
                pos++
        }</span>

        // Parse params
        <span class="cov8" title="1">for pos &lt; len(raw) </span><span class="cov8" title="1">{
                if raw[pos] == ':' </span><span class="cov8" title="1">{
                        // Trailing parameter (rest of message)
                        msg.Trailing = raw[pos+1:]
                        break</span>
                }

                <span class="cov8" title="1">end := strings.Index(raw[pos:], " ")
                if end == -1 </span><span class="cov8" title="1">{
                        msg.Params = append(msg.Params, raw[pos:])
                        break</span>
                }
                <span class="cov8" title="1">msg.Params = append(msg.Params, raw[pos:pos+end])
                pos = pos + end + 1

                // Skip whitespace
                for pos &lt; len(raw) &amp;&amp; raw[pos] == ' ' </span><span class="cov0" title="0">{
                        pos++
                }</span>
        }

        <span class="cov8" title="1">return msg</span>
}

// parseTags parses IRCv3 tags from a tag string.
func parseTags(tagStr string) map[string]string <span class="cov8" title="1">{
        tags := make(map[string]string)
        if tagStr == "" </span><span class="cov0" title="0">{
                return tags
        }</span>

        <span class="cov8" title="1">pairs := strings.Split(tagStr, ";")
        for _, pair := range pairs </span><span class="cov8" title="1">{
                if pair == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">eqIdx := strings.Index(pair, "=")
                if eqIdx == -1 </span><span class="cov0" title="0">{
                        tags[pair] = ""
                        continue</span>
                }
                <span class="cov8" title="1">key := pair[:eqIdx]
                value := unescapeTagValue(pair[eqIdx+1:])
                tags[key] = value</span>
        }

        <span class="cov8" title="1">return tags</span>
}

// unescapeTagValue unescapes IRC tag values.
func unescapeTagValue(s string) string <span class="cov8" title="1">{
        var result strings.Builder
        result.Grow(len(s))

        i := 0
        for i &lt; len(s) </span><span class="cov8" title="1">{
                if i+1 &lt; len(s) &amp;&amp; s[i] == '\\' </span><span class="cov8" title="1">{
                        switch s[i+1] </span>{
                        case ':':<span class="cov0" title="0">
                                result.WriteByte(';')</span>
                        case 's':<span class="cov8" title="1">
                                result.WriteByte(' ')</span>
                        case '\\':<span class="cov0" title="0">
                                result.WriteByte('\\')</span>
                        case 'r':<span class="cov0" title="0">
                                result.WriteByte('\r')</span>
                        case 'n':<span class="cov0" title="0">
                                result.WriteByte('\n')</span>
                        default:<span class="cov0" title="0">
                                result.WriteByte(s[i+1])</span>
                        }
                        <span class="cov8" title="1">i += 2</span>
                } else<span class="cov8" title="1"> {
                        result.WriteByte(s[i])
                        i++
                }</span>
        }

        <span class="cov8" title="1">return result.String()</span>
}

// parseEmotes parses the emotes tag into a slice of IRCEmote.
// Format: emote_id:start-end,start-end/emote_id:start-end
func parseEmotes(emoteStr string) []IRCEmote <span class="cov8" title="1">{
        if emoteStr == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">var emotes []IRCEmote
        emoteParts := strings.Split(emoteStr, "/")

        for _, part := range emoteParts </span><span class="cov0" title="0">{
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">colonIdx := strings.Index(part, ":")
                if colonIdx == -1 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">emoteID := part[:colonIdx]
                positionsStr := part[colonIdx+1:]
                positions := strings.Split(positionsStr, ",")

                for _, posStr := range positions </span><span class="cov0" title="0">{
                        dashIdx := strings.Index(posStr, "-")
                        if dashIdx == -1 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">start, err1 := strconv.Atoi(posStr[:dashIdx])
                        end, err2 := strconv.Atoi(posStr[dashIdx+1:])
                        if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">emotes = append(emotes, IRCEmote{
                                ID:    emoteID,
                                Start: start,
                                End:   end,
                                Count: 1,
                        })</span>
                }
        }

        <span class="cov0" title="0">return emotes</span>
}

// parseBadges parses the badges tag into a map.
// Format: badge/version,badge/version
func parseBadges(badgeStr string) map[string]string <span class="cov8" title="1">{
        badges := make(map[string]string)
        if badgeStr == "" </span><span class="cov8" title="1">{
                return badges
        }</span>

        <span class="cov8" title="1">parts := strings.Split(badgeStr, ",")
        for _, part := range parts </span><span class="cov8" title="1">{
                if part == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">slashIdx := strings.Index(part, "/")
                if slashIdx == -1 </span><span class="cov0" title="0">{
                        badges[part] = ""
                        continue</span>
                }
                <span class="cov8" title="1">badges[part[:slashIdx]] = part[slashIdx+1:]</span>
        }

        <span class="cov8" title="1">return badges</span>
}

// parseTimestamp parses the tmi-sent-ts tag into a time.Time.
func parseTimestamp(ts string) time.Time <span class="cov8" title="1">{
        if ts == "" </span><span class="cov0" title="0">{
                return time.Now()
        }</span>
        <span class="cov8" title="1">ms, err := strconv.ParseInt(ts, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return time.Now()
        }</span>
        <span class="cov8" title="1">return time.UnixMilli(ms)</span>
}

// parseBool parses a "0" or "1" string into a bool.
func parseBool(s string) bool <span class="cov8" title="1">{
        return s == "1"
}</span>

// parseInt parses a string into an int, returning 0 on error.
func parseInt(s string) int <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">n, _ := strconv.Atoi(s)
        return n</span>
}

// parseChannel removes the # prefix from a channel name.
func parseChannel(s string) string <span class="cov8" title="1">{
        return strings.TrimPrefix(s, "#")
}</span>

// parseUserFromPrefix extracts the username from a prefix.
// Format: nick!user@host
func parseUserFromPrefix(prefix string) string <span class="cov8" title="1">{
        if prefix == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">bangIdx := strings.Index(prefix, "!")
        if bangIdx == -1 </span><span class="cov0" title="0">{
                return prefix
        }</span>
        <span class="cov8" title="1">return prefix[:bangIdx]</span>
}

// parseChatMessage converts an IRCMessage into a ChatMessage.
func parseChatMessage(msg *IRCMessage) *ChatMessage <span class="cov8" title="1">{
        channel := ""
        if len(msg.Params) &gt; 0 </span><span class="cov8" title="1">{
                channel = parseChannel(msg.Params[0])
        }</span>

        <span class="cov8" title="1">badges := parseBadges(msg.Tags["badges"])

        return &amp;ChatMessage{
                ID:            msg.Tags["id"],
                Channel:       channel,
                User:          msg.Tags["login"],
                UserID:        msg.Tags["user-id"],
                Message:       msg.Trailing,
                Emotes:        parseEmotes(msg.Tags["emotes"]),
                Badges:        badges,
                BadgeInfo:     parseBadges(msg.Tags["badge-info"]),
                Color:         msg.Tags["color"],
                DisplayName:   msg.Tags["display-name"],
                IsMod:         parseBool(msg.Tags["mod"]),
                IsVIP:         badges["vip"] != "",
                IsSubscriber:  parseBool(msg.Tags["subscriber"]),
                IsBroadcaster: badges["broadcaster"] != "",
                Bits:          parseInt(msg.Tags["bits"]),
                FirstMessage:  parseBool(msg.Tags["first-msg"]),
                ReturningChatter: parseBool(msg.Tags["returning-chatter"]),
                ReplyParentMsgID:       msg.Tags["reply-parent-msg-id"],
                ReplyParentUserID:      msg.Tags["reply-parent-user-id"],
                ReplyParentUserLogin:   msg.Tags["reply-parent-user-login"],
                ReplyParentDisplayName: msg.Tags["reply-parent-display-name"],
                ReplyParentMsgBody:     msg.Tags["reply-parent-msg-body"],
                Timestamp:     parseTimestamp(msg.Tags["tmi-sent-ts"]),
                Raw:           msg.Raw,
        }</span>
}

// parseUserNotice converts an IRCMessage into a UserNotice.
func parseUserNotice(msg *IRCMessage) *UserNotice <span class="cov8" title="1">{
        channel := ""
        if len(msg.Params) &gt; 0 </span><span class="cov8" title="1">{
                channel = parseChannel(msg.Params[0])
        }</span>

        // Extract msg-param-* tags
        <span class="cov8" title="1">msgParams := make(map[string]string)
        for key, value := range msg.Tags </span><span class="cov8" title="1">{
                if strings.HasPrefix(key, "msg-param-") </span><span class="cov8" title="1">{
                        paramName := strings.TrimPrefix(key, "msg-param-")
                        msgParams[paramName] = value
                }</span>
        }

        <span class="cov8" title="1">return &amp;UserNotice{
                Type:          msg.Tags["msg-id"],
                Channel:       channel,
                User:          msg.Tags["login"],
                UserID:        msg.Tags["user-id"],
                DisplayName:   msg.Tags["display-name"],
                Message:       msg.Trailing,
                SystemMessage: msg.Tags["system-msg"],
                MsgParams:     msgParams,
                Badges:        parseBadges(msg.Tags["badges"]),
                BadgeInfo:     parseBadges(msg.Tags["badge-info"]),
                Color:         msg.Tags["color"],
                Emotes:        parseEmotes(msg.Tags["emotes"]),
                Timestamp:     parseTimestamp(msg.Tags["tmi-sent-ts"]),
                Raw:           msg.Raw,
        }</span>
}

// parseRoomState converts an IRCMessage into a RoomState.
func parseRoomState(msg *IRCMessage) *RoomState <span class="cov8" title="1">{
        channel := ""
        if len(msg.Params) &gt; 0 </span><span class="cov8" title="1">{
                channel = parseChannel(msg.Params[0])
        }</span>

        <span class="cov8" title="1">followersOnly := -1
        if fo, ok := msg.Tags["followers-only"]; ok </span><span class="cov8" title="1">{
                followersOnly = parseInt(fo)
        }</span>

        <span class="cov8" title="1">return &amp;RoomState{
                Channel:       channel,
                EmoteOnly:     parseBool(msg.Tags["emote-only"]),
                FollowersOnly: followersOnly,
                R9K:           parseBool(msg.Tags["r9k"]),
                Slow:          parseInt(msg.Tags["slow"]),
                SubsOnly:      parseBool(msg.Tags["subs-only"]),
                RoomID:        msg.Tags["room-id"],
                Raw:           msg.Raw,
        }</span>
}

// parseNotice converts an IRCMessage into a Notice.
func parseNotice(msg *IRCMessage) *Notice <span class="cov8" title="1">{
        channel := ""
        if len(msg.Params) &gt; 0 </span><span class="cov8" title="1">{
                channel = parseChannel(msg.Params[0])
        }</span>

        <span class="cov8" title="1">return &amp;Notice{
                Channel: channel,
                Message: msg.Trailing,
                MsgID:   msg.Tags["msg-id"],
                Raw:     msg.Raw,
        }</span>
}

// parseClearChat converts an IRCMessage into a ClearChat.
func parseClearChat(msg *IRCMessage) *ClearChat <span class="cov8" title="1">{
        channel := ""
        if len(msg.Params) &gt; 0 </span><span class="cov8" title="1">{
                channel = parseChannel(msg.Params[0])
        }</span>

        <span class="cov8" title="1">return &amp;ClearChat{
                Channel:      channel,
                User:         msg.Trailing,
                BanDuration:  parseInt(msg.Tags["ban-duration"]),
                RoomID:       msg.Tags["room-id"],
                TargetUserID: msg.Tags["target-user-id"],
                Timestamp:    parseTimestamp(msg.Tags["tmi-sent-ts"]),
                Raw:          msg.Raw,
        }</span>
}

// parseClearMessage converts an IRCMessage into a ClearMessage.
func parseClearMessage(msg *IRCMessage) *ClearMessage <span class="cov8" title="1">{
        channel := ""
        if len(msg.Params) &gt; 0 </span><span class="cov8" title="1">{
                channel = parseChannel(msg.Params[0])
        }</span>

        <span class="cov8" title="1">return &amp;ClearMessage{
                Channel:     channel,
                User:        msg.Tags["login"],
                Message:     msg.Trailing,
                TargetMsgID: msg.Tags["target-msg-id"],
                Timestamp:   parseTimestamp(msg.Tags["tmi-sent-ts"]),
                Raw:         msg.Raw,
        }</span>
}

// parseWhisper converts an IRCMessage into a Whisper.
func parseWhisper(msg *IRCMessage) *Whisper <span class="cov8" title="1">{
        to := ""
        if len(msg.Params) &gt; 0 </span><span class="cov8" title="1">{
                to = msg.Params[0]
        }</span>

        <span class="cov8" title="1">return &amp;Whisper{
                From:        parseUserFromPrefix(msg.Prefix),
                FromID:      msg.Tags["user-id"],
                To:          to,
                Message:     msg.Trailing,
                DisplayName: msg.Tags["display-name"],
                Color:       msg.Tags["color"],
                Badges:      parseBadges(msg.Tags["badges"]),
                Emotes:      parseEmotes(msg.Tags["emotes"]),
                MessageID:   msg.Tags["message-id"],
                ThreadID:    msg.Tags["thread-id"],
                Raw:         msg.Raw,
        }</span>
}

// parseGlobalUserState converts an IRCMessage into a GlobalUserState.
func parseGlobalUserState(msg *IRCMessage) *GlobalUserState <span class="cov8" title="1">{
        emoteSets := []string{}
        if es := msg.Tags["emote-sets"]; es != "" </span><span class="cov8" title="1">{
                emoteSets = strings.Split(es, ",")
        }</span>

        <span class="cov8" title="1">return &amp;GlobalUserState{
                UserID:      msg.Tags["user-id"],
                DisplayName: msg.Tags["display-name"],
                Color:       msg.Tags["color"],
                Badges:      parseBadges(msg.Tags["badges"]),
                BadgeInfo:   parseBadges(msg.Tags["badge-info"]),
                EmoteSets:   emoteSets,
                Raw:         msg.Raw,
        }</span>
}

// parseUserState converts an IRCMessage into a UserState.
func parseUserState(msg *IRCMessage) *UserState <span class="cov8" title="1">{
        channel := ""
        if len(msg.Params) &gt; 0 </span><span class="cov8" title="1">{
                channel = parseChannel(msg.Params[0])
        }</span>

        <span class="cov8" title="1">emoteSets := []string{}
        if es := msg.Tags["emote-sets"]; es != "" </span><span class="cov8" title="1">{
                emoteSets = strings.Split(es, ",")
        }</span>

        <span class="cov8" title="1">badges := parseBadges(msg.Tags["badges"])

        return &amp;UserState{
                Channel:      channel,
                DisplayName:  msg.Tags["display-name"],
                Color:        msg.Tags["color"],
                Badges:       badges,
                BadgeInfo:    parseBadges(msg.Tags["badge-info"]),
                EmoteSets:    emoteSets,
                IsMod:        parseBool(msg.Tags["mod"]),
                IsSubscriber: parseBool(msg.Tags["subscriber"]),
                Raw:          msg.Raw,
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package helix

import (
        "context"
        "net/http"
        "time"
)

// Middleware is a function that wraps request execution.
// It receives the request context, the request, and a next function to call.
// Middleware can modify the request before calling next, and modify/inspect
// the response after next returns.
type Middleware func(ctx context.Context, req *Request, next MiddlewareNext) (*MiddlewareResponse, error)

// MiddlewareNext is a function that continues the middleware chain.
type MiddlewareNext func(ctx context.Context, req *Request) (*MiddlewareResponse, error)

// MiddlewareResponse contains the response data available to middleware.
type MiddlewareResponse struct {
        StatusCode int
        Headers    http.Header
        Body       []byte
}

// Use adds middleware to the client. Middleware is executed in the order added.
func (c *Client) Use(mw ...Middleware) <span class="cov0" title="0">{
        c.middleware = append(c.middleware, mw...)
}</span>

// LoggingMiddleware creates middleware that logs requests and responses.
func LoggingMiddleware(logger func(format string, args ...interface{})) Middleware <span class="cov0" title="0">{
        return func(ctx context.Context, req *Request, next MiddlewareNext) (*MiddlewareResponse, error) </span><span class="cov0" title="0">{
                logger("-&gt; %s %s", req.Method, req.Endpoint)

                resp, err := next(ctx, req)

                if err != nil </span><span class="cov0" title="0">{
                        logger("&lt;- %s %s: error: %v", req.Method, req.Endpoint, err)
                }</span> else<span class="cov0" title="0"> {
                        logger("&lt;- %s %s: %d", req.Method, req.Endpoint, resp.StatusCode)
                }</span>

                <span class="cov0" title="0">return resp, err</span>
        }
}

// RetryMiddleware creates middleware that retries failed requests.
// This is separate from the built-in rate limit retry and handles other transient errors.
func RetryMiddleware(maxRetries int, retryableStatuses ...int) Middleware <span class="cov0" title="0">{
        statusSet := make(map[int]bool)
        for _, s := range retryableStatuses </span><span class="cov0" title="0">{
                statusSet[s] = true
        }</span>
        // Default retryable statuses if none provided
        <span class="cov0" title="0">if len(statusSet) == 0 </span><span class="cov0" title="0">{
                statusSet[502] = true // Bad Gateway
                statusSet[503] = true // Service Unavailable
                statusSet[504] = true // Gateway Timeout
        }</span>

        <span class="cov0" title="0">return func(ctx context.Context, req *Request, next MiddlewareNext) (*MiddlewareResponse, error) </span><span class="cov0" title="0">{
                var lastResp *MiddlewareResponse
                var lastErr error

                for attempt := 0; attempt &lt;= maxRetries; attempt++ </span><span class="cov0" title="0">{
                        resp, err := next(ctx, req)
                        if err != nil </span><span class="cov0" title="0">{
                                lastErr = err
                                continue</span>
                        }

                        <span class="cov0" title="0">if !statusSet[resp.StatusCode] </span><span class="cov0" title="0">{
                                return resp, nil
                        }</span>

                        <span class="cov0" title="0">lastResp = resp
                        lastErr = nil</span>
                }

                <span class="cov0" title="0">if lastErr != nil </span><span class="cov0" title="0">{
                        return nil, lastErr
                }</span>
                <span class="cov0" title="0">return lastResp, nil</span>
        }
}

// HeaderMiddleware creates middleware that adds custom headers to requests.
func HeaderMiddleware(headers map[string]string) Middleware <span class="cov0" title="0">{
        return func(ctx context.Context, req *Request, next MiddlewareNext) (*MiddlewareResponse, error) </span><span class="cov0" title="0">{
                // Headers are added in the actual HTTP request building,
                // so we store them in context for the client to pick up
                ctx = contextWithHeaders(ctx, headers)
                return next(ctx, req)
        }</span>
}

// headersContextKey is the context key for custom headers.
type headersContextKey struct{}

// contextWithHeaders adds custom headers to context.
func contextWithHeaders(ctx context.Context, headers map[string]string) context.Context <span class="cov0" title="0">{
        existing := headersFromContext(ctx)
        merged := make(map[string]string)
        for k, v := range existing </span><span class="cov0" title="0">{
                merged[k] = v
        }</span>
        <span class="cov0" title="0">for k, v := range headers </span><span class="cov0" title="0">{
                merged[k] = v
        }</span>
        <span class="cov0" title="0">return context.WithValue(ctx, headersContextKey{}, merged)</span>
}

// headersFromContext retrieves custom headers from context.
func headersFromContext(ctx context.Context) map[string]string <span class="cov0" title="0">{
        if headers, ok := ctx.Value(headersContextKey{}).(map[string]string); ok </span><span class="cov0" title="0">{
                return headers
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// MetricsMiddleware creates middleware that tracks request metrics.
type RequestMetrics struct {
        Method     string
        Endpoint   string
        StatusCode int
        Duration   int64 // milliseconds
        Error      error
}

func MetricsMiddleware(collector func(metrics RequestMetrics)) Middleware <span class="cov0" title="0">{
        return func(ctx context.Context, req *Request, next MiddlewareNext) (*MiddlewareResponse, error) </span><span class="cov0" title="0">{
                start := time.Now()

                resp, err := next(ctx, req)

                metrics := RequestMetrics{
                        Method:   req.Method,
                        Endpoint: req.Endpoint,
                        Duration: time.Since(start).Milliseconds(),
                        Error:    err,
                }
                if resp != nil </span><span class="cov0" title="0">{
                        metrics.StatusCode = resp.StatusCode
                }</span>

                <span class="cov0" title="0">collector(metrics)

                return resp, err</span>
        }
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// BannedUser represents a banned user.
type BannedUser struct {
        UserID         string    `json:"user_id"`
        UserLogin      string    `json:"user_login"`
        UserName       string    `json:"user_name"`
        ExpiresAt      time.Time `json:"expires_at,omitempty"`
        CreatedAt      time.Time `json:"created_at"`
        Reason         string    `json:"reason"`
        ModeratorID    string    `json:"moderator_id"`
        ModeratorLogin string    `json:"moderator_login"`
        ModeratorName  string    `json:"moderator_name"`
}

// GetBannedUsersParams contains parameters for GetBannedUsers.
type GetBannedUsersParams struct {
        BroadcasterID string
        UserIDs       []string // Filter by user IDs (max 100)
        *PaginationParams
}

// GetBannedUsers gets the list of banned users for a channel.
// Requires: moderation:read scope.
func (c *Client) GetBannedUsers(ctx context.Context, params *GetBannedUsersParams) (*Response[BannedUser], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        for _, id := range params.UserIDs </span><span class="cov0" title="0">{
                q.Add("user_id", id)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[BannedUser]
        if err := c.get(ctx, "/moderation/banned", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// BanUserParams contains parameters for BanUser.
type BanUserParams struct {
        BroadcasterID string      `json:"-"`
        ModeratorID   string      `json:"-"`
        Data          BanUserData `json:"data"`
}

// BanUserData contains the ban data.
type BanUserData struct {
        UserID   string `json:"user_id"`
        Duration int    `json:"duration,omitempty"` // 0 = permanent, 1-1209600 seconds
        Reason   string `json:"reason,omitempty"`
}

// BanUserResponse represents the response from BanUser.
type BanUserResponse struct {
        BroadcasterID string    `json:"broadcaster_id"`
        ModeratorID   string    `json:"moderator_id"`
        UserID        string    `json:"user_id"`
        CreatedAt     time.Time `json:"created_at"`
        EndTime       time.Time `json:"end_time,omitempty"`
}

// BanUser bans a user from a channel.
// Requires: moderator:manage:banned_users scope.
func (c *Client) BanUser(ctx context.Context, params *BanUserParams) (*BanUserResponse, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)

        var resp Response[BanUserResponse]
        if err := c.post(ctx, "/moderation/bans", q, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// UnbanUser unbans a user from a channel.
// Requires: moderator:manage:banned_users scope.
func (c *Client) UnbanUser(ctx context.Context, broadcasterID, moderatorID, userID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("moderator_id", moderatorID)
        q.Set("user_id", userID)

        return c.delete(ctx, "/moderation/bans", q, nil)
}</span>

// Moderator represents a channel moderator.
type Moderator struct {
        UserID    string `json:"user_id"`
        UserLogin string `json:"user_login"`
        UserName  string `json:"user_name"`
}

// GetModeratorsParams contains parameters for GetModerators.
type GetModeratorsParams struct {
        BroadcasterID string
        UserIDs       []string // Filter by user IDs (max 100)
        *PaginationParams
}

// GetModerators gets the list of moderators for a channel.
// Requires: moderation:read scope.
func (c *Client) GetModerators(ctx context.Context, params *GetModeratorsParams) (*Response[Moderator], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        for _, id := range params.UserIDs </span><span class="cov0" title="0">{
                q.Add("user_id", id)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[Moderator]
        if err := c.get(ctx, "/moderation/moderators", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// AddChannelModerator adds a moderator to a channel.
// Requires: channel:manage:moderators scope.
func (c *Client) AddChannelModerator(ctx context.Context, broadcasterID, userID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("user_id", userID)

        return c.post(ctx, "/moderation/moderators", q, nil, nil)
}</span>

// RemoveChannelModerator removes a moderator from a channel.
// Requires: channel:manage:moderators scope.
func (c *Client) RemoveChannelModerator(ctx context.Context, broadcasterID, userID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("user_id", userID)

        return c.delete(ctx, "/moderation/moderators", q, nil)
}</span>

// DeleteChatMessagesParams contains parameters for DeleteChatMessages.
type DeleteChatMessagesParams struct {
        BroadcasterID string
        ModeratorID   string
        MessageID     string // Optional: Specific message to delete. If empty, deletes all messages.
}

// DeleteChatMessages deletes chat messages.
// Requires: moderator:manage:chat_messages scope.
func (c *Client) DeleteChatMessages(ctx context.Context, params *DeleteChatMessagesParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)
        if params.MessageID != "" </span><span class="cov0" title="0">{
                q.Set("message_id", params.MessageID)
        }</span>

        <span class="cov0" title="0">return c.delete(ctx, "/moderation/chat", q, nil)</span>
}

// BlockedTerm represents a blocked term.
type BlockedTerm struct {
        BroadcasterID string    `json:"broadcaster_id"`
        ModeratorID   string    `json:"moderator_id"`
        ID            string    `json:"id"`
        Text          string    `json:"text"`
        CreatedAt     time.Time `json:"created_at"`
        UpdatedAt     time.Time `json:"updated_at"`
        ExpiresAt     time.Time `json:"expires_at,omitempty"`
}

// GetBlockedTermsParams contains parameters for GetBlockedTerms.
type GetBlockedTermsParams struct {
        BroadcasterID string
        ModeratorID   string
        *PaginationParams
}

// GetBlockedTerms gets the list of blocked terms for a channel.
// Requires: moderator:read:blocked_terms scope.
func (c *Client) GetBlockedTerms(ctx context.Context, params *GetBlockedTermsParams) (*Response[BlockedTerm], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)
        addPaginationParams(q, params.PaginationParams)

        var resp Response[BlockedTerm]
        if err := c.get(ctx, "/moderation/blocked_terms", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// AddBlockedTermParams contains parameters for AddBlockedTerm.
type AddBlockedTermParams struct {
        BroadcasterID string `json:"-"`
        ModeratorID   string `json:"-"`
        Text          string `json:"text"`
}

// AddBlockedTerm adds a blocked term.
// Requires: moderator:manage:blocked_terms scope.
func (c *Client) AddBlockedTerm(ctx context.Context, params *AddBlockedTermParams) (*BlockedTerm, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)

        var resp Response[BlockedTerm]
        if err := c.post(ctx, "/moderation/blocked_terms", q, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// RemoveBlockedTerm removes a blocked term.
// Requires: moderator:manage:blocked_terms scope.
func (c *Client) RemoveBlockedTerm(ctx context.Context, broadcasterID, moderatorID, termID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("moderator_id", moderatorID)
        q.Set("id", termID)

        return c.delete(ctx, "/moderation/blocked_terms", q, nil)
}</span>

// ShieldModeStatus represents shield mode status.
type ShieldModeStatus struct {
        IsActive        bool      `json:"is_active"`
        ModeratorID     string    `json:"moderator_id"`
        ModeratorLogin  string    `json:"moderator_login"`
        ModeratorName   string    `json:"moderator_name"`
        LastActivatedAt time.Time `json:"last_activated_at"`
}

// GetShieldModeStatus gets the shield mode status for a channel.
// Requires: moderator:read:shield_mode scope.
func (c *Client) GetShieldModeStatus(ctx context.Context, broadcasterID, moderatorID string) (*ShieldModeStatus, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("moderator_id", moderatorID)

        var resp Response[ShieldModeStatus]
        if err := c.get(ctx, "/moderation/shield_mode", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// UpdateShieldModeStatusParams contains parameters for UpdateShieldModeStatus.
type UpdateShieldModeStatusParams struct {
        BroadcasterID string `json:"-"`
        ModeratorID   string `json:"-"`
        IsActive      bool   `json:"is_active"`
}

// UpdateShieldModeStatus updates the shield mode status for a channel.
// Requires: moderator:manage:shield_mode scope.
func (c *Client) UpdateShieldModeStatus(ctx context.Context, params *UpdateShieldModeStatusParams) (*ShieldModeStatus, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)

        var resp Response[ShieldModeStatus]
        if err := c.put(ctx, "/moderation/shield_mode", q, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// WarnChatUserParams contains parameters for WarnChatUser.
type WarnChatUserParams struct {
        BroadcasterID string           `json:"-"`
        ModeratorID   string           `json:"-"`
        Data          WarnChatUserData `json:"data"`
}

// WarnChatUserData contains the warning data.
type WarnChatUserData struct {
        UserID string `json:"user_id"`
        Reason string `json:"reason"`
}

// WarnChatUser warns a user in chat.
// Requires: moderator:manage:warnings scope.
func (c *Client) WarnChatUser(ctx context.Context, params *WarnChatUserParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)

        return c.post(ctx, "/moderation/warnings", q, params, nil)
}</span>

// AutoModStatus represents the AutoMod status of a message.
type AutoModStatus struct {
        MsgID       string `json:"msg_id"`
        IsPermitted bool   `json:"is_permitted"`
}

// CheckAutoModStatusParams contains parameters for CheckAutoModStatus.
type CheckAutoModStatusParams struct {
        BroadcasterID string                 `json:"-"`
        Data          []AutoModStatusMessage `json:"data"`
}

// AutoModStatusMessage represents a message to check.
type AutoModStatusMessage struct {
        MsgID   string `json:"msg_id"`
        MsgText string `json:"msg_text"`
}

// CheckAutoModStatus checks if messages meet AutoMod requirements.
// Requires: moderation:read scope.
func (c *Client) CheckAutoModStatus(ctx context.Context, params *CheckAutoModStatusParams) (*Response[AutoModStatus], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)

        var resp Response[AutoModStatus]
        if err := c.post(ctx, "/moderation/enforcements/status", q, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ManageHeldAutoModMessageParams contains parameters for ManageHeldAutoModMessages.
type ManageHeldAutoModMessageParams struct {
        UserID string `json:"user_id"`
        MsgID  string `json:"msg_id"`
        Action string `json:"action"` // ALLOW or DENY
}

// ManageHeldAutoModMessages approves or denies a held AutoMod message.
// Requires: moderator:manage:automod scope.
func (c *Client) ManageHeldAutoModMessages(ctx context.Context, params *ManageHeldAutoModMessageParams) error <span class="cov0" title="0">{
        return c.post(ctx, "/moderation/automod/message", nil, params, nil)
}</span>

// AutoModSettings represents AutoMod settings.
type AutoModSettings struct {
        BroadcasterID           string `json:"broadcaster_id"`
        ModeratorID             string `json:"moderator_id"`
        OverallLevel            *int   `json:"overall_level"`
        Disability              int    `json:"disability"`
        Aggression              int    `json:"aggression"`
        SexualitySexOrGender    int    `json:"sexuality_sex_or_gender"`
        Misogyny                int    `json:"misogyny"`
        Bullying                int    `json:"bullying"`
        Swearing                int    `json:"swearing"`
        RaceEthnicityOrReligion int    `json:"race_ethnicity_or_religion"`
        SexBasedTerms           int    `json:"sex_based_terms"`
}

// GetAutoModSettings gets the AutoMod settings for a channel.
// Requires: moderator:read:automod_settings scope.
func (c *Client) GetAutoModSettings(ctx context.Context, broadcasterID, moderatorID string) (*AutoModSettings, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("moderator_id", moderatorID)

        var resp Response[AutoModSettings]
        if err := c.get(ctx, "/moderation/automod/settings", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// UpdateAutoModSettingsParams contains parameters for UpdateAutoModSettings.
type UpdateAutoModSettingsParams struct {
        BroadcasterID           string `json:"-"`
        ModeratorID             string `json:"-"`
        OverallLevel            *int   `json:"overall_level,omitempty"`
        Disability              *int   `json:"disability,omitempty"`
        Aggression              *int   `json:"aggression,omitempty"`
        SexualitySexOrGender    *int   `json:"sexuality_sex_or_gender,omitempty"`
        Misogyny                *int   `json:"misogyny,omitempty"`
        Bullying                *int   `json:"bullying,omitempty"`
        Swearing                *int   `json:"swearing,omitempty"`
        RaceEthnicityOrReligion *int   `json:"race_ethnicity_or_religion,omitempty"`
        SexBasedTerms           *int   `json:"sex_based_terms,omitempty"`
}

// UpdateAutoModSettings updates the AutoMod settings for a channel.
// Requires: moderator:manage:automod_settings scope.
func (c *Client) UpdateAutoModSettings(ctx context.Context, params *UpdateAutoModSettingsParams) (*AutoModSettings, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)

        var resp Response[AutoModSettings]
        if err := c.put(ctx, "/moderation/automod/settings", q, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// UnbanRequest represents an unban request.
type UnbanRequest struct {
        ID               string `json:"id"`
        BroadcasterID    string `json:"broadcaster_id"`
        BroadcasterLogin string `json:"broadcaster_login"`
        BroadcasterName  string `json:"broadcaster_name"`
        ModeratorID      string `json:"moderator_id,omitempty"`
        ModeratorLogin   string `json:"moderator_login,omitempty"`
        ModeratorName    string `json:"moderator_name,omitempty"`
        UserID           string `json:"user_id"`
        UserLogin        string `json:"user_login"`
        UserName         string `json:"user_name"`
        Text             string `json:"text"`
        Status           string `json:"status"` // pending, approved, denied, acknowledged, canceled
        CreatedAt        string `json:"created_at"`
        ResolvedAt       string `json:"resolved_at,omitempty"`
        ResolutionText   string `json:"resolution_text,omitempty"`
}

// GetUnbanRequestsParams contains parameters for GetUnbanRequests.
type GetUnbanRequestsParams struct {
        BroadcasterID string
        ModeratorID   string
        Status        string // pending, approved, denied, acknowledged, canceled
        UserID        string // Filter by user
        *PaginationParams
}

// GetUnbanRequests gets unban requests for a channel.
// Requires: moderator:read:unban_requests scope.
func (c *Client) GetUnbanRequests(ctx context.Context, params *GetUnbanRequestsParams) (*Response[UnbanRequest], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)
        if params.Status != "" </span><span class="cov0" title="0">{
                q.Set("status", params.Status)
        }</span>
        <span class="cov0" title="0">if params.UserID != "" </span><span class="cov0" title="0">{
                q.Set("user_id", params.UserID)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[UnbanRequest]
        if err := c.get(ctx, "/moderation/unban_requests", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// ResolveUnbanRequestParams contains parameters for ResolveUnbanRequest.
type ResolveUnbanRequestParams struct {
        BroadcasterID  string `json:"-"`
        ModeratorID    string `json:"-"`
        UnbanRequestID string `json:"-"`
        Status         string `json:"status"` // approved or denied
        ResolutionText string `json:"resolution_text,omitempty"`
}

// ResolveUnbanRequest resolves an unban request.
// Requires: moderator:manage:unban_requests scope.
func (c *Client) ResolveUnbanRequest(ctx context.Context, params *ResolveUnbanRequestParams) (*UnbanRequest, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("moderator_id", params.ModeratorID)
        q.Set("unban_request_id", params.UnbanRequestID)
        q.Set("status", params.Status)
        if params.ResolutionText != "" </span><span class="cov0" title="0">{
                q.Set("resolution_text", params.ResolutionText)
        }</span>

        <span class="cov0" title="0">var resp Response[UnbanRequest]
        if err := c.patch(ctx, "/moderation/unban_requests", q, nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// ModeratedChannel represents a channel where the user is a moderator.
type ModeratedChannel struct {
        BroadcasterID    string `json:"broadcaster_id"`
        BroadcasterLogin string `json:"broadcaster_login"`
        BroadcasterName  string `json:"broadcaster_name"`
}

// GetModeratedChannelsParams contains parameters for GetModeratedChannels.
type GetModeratedChannelsParams struct {
        UserID string
        *PaginationParams
}

// GetModeratedChannels gets channels where the user is a moderator.
// Requires: user:read:moderated_channels scope.
func (c *Client) GetModeratedChannels(ctx context.Context, params *GetModeratedChannelsParams) (*Response[ModeratedChannel], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("user_id", params.UserID)
        addPaginationParams(q, params.PaginationParams)

        var resp Response[ModeratedChannel]
        if err := c.get(ctx, "/moderation/channels", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// Poll represents a channel poll.
type Poll struct {
        ID                         string       `json:"id"`
        BroadcasterID              string       `json:"broadcaster_id"`
        BroadcasterName            string       `json:"broadcaster_name"`
        BroadcasterLogin           string       `json:"broadcaster_login"`
        Title                      string       `json:"title"`
        Choices                    []PollChoice `json:"choices"`
        BitsVotingEnabled          bool         `json:"bits_voting_enabled"`
        BitsPerVote                int          `json:"bits_per_vote"`
        ChannelPointsVotingEnabled bool         `json:"channel_points_voting_enabled"`
        ChannelPointsPerVote       int          `json:"channel_points_per_vote"`
        Status                     string       `json:"status"` // ACTIVE, COMPLETED, TERMINATED, ARCHIVED, MODERATED, INVALID
        Duration                   int          `json:"duration"`
        StartedAt                  time.Time    `json:"started_at"`
        EndedAt                    time.Time    `json:"ended_at,omitempty"`
}

// PollChoice represents a choice in a poll.
type PollChoice struct {
        ID                 string `json:"id"`
        Title              string `json:"title"`
        Votes              int    `json:"votes"`
        ChannelPointsVotes int    `json:"channel_points_votes"`
        BitsVotes          int    `json:"bits_votes"`
}

// GetPollsParams contains parameters for GetPolls.
type GetPollsParams struct {
        BroadcasterID string
        IDs           []string // Poll IDs (max 100)
        *PaginationParams
}

// GetPolls gets polls for a channel.
// Requires: channel:read:polls scope.
func (c *Client) GetPolls(ctx context.Context, params *GetPollsParams) (*Response[Poll], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        for _, id := range params.IDs </span><span class="cov0" title="0">{
                q.Add("id", id)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[Poll]
        if err := c.get(ctx, "/polls", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// CreatePollParams contains parameters for CreatePoll.
type CreatePollParams struct {
        BroadcasterID              string             `json:"broadcaster_id"`
        Title                      string             `json:"title"`
        Choices                    []CreatePollChoice `json:"choices"`
        Duration                   int                `json:"duration"` // 15-1800 seconds
        ChannelPointsVotingEnabled bool               `json:"channel_points_voting_enabled,omitempty"`
        ChannelPointsPerVote       int                `json:"channel_points_per_vote,omitempty"`
}

// CreatePollChoice represents a choice when creating a poll.
type CreatePollChoice struct {
        Title string `json:"title"`
}

// CreatePoll creates a poll on a channel.
// Requires: channel:manage:polls scope.
func (c *Client) CreatePoll(ctx context.Context, params *CreatePollParams) (*Poll, error) <span class="cov0" title="0">{
        var resp Response[Poll]
        if err := c.post(ctx, "/polls", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// EndPollParams contains parameters for EndPoll.
type EndPollParams struct {
        BroadcasterID string `json:"broadcaster_id"`
        ID            string `json:"id"`
        Status        string `json:"status"` // TERMINATED or ARCHIVED
}

// EndPoll ends a poll.
// Requires: channel:manage:polls scope.
func (c *Client) EndPoll(ctx context.Context, params *EndPollParams) (*Poll, error) <span class="cov0" title="0">{
        var resp Response[Poll]
        if err := c.patch(ctx, "/polls", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// Prediction represents a channel prediction.
type Prediction struct {
        ID               string              `json:"id"`
        BroadcasterID    string              `json:"broadcaster_id"`
        BroadcasterName  string              `json:"broadcaster_name"`
        BroadcasterLogin string              `json:"broadcaster_login"`
        Title            string              `json:"title"`
        WinningOutcomeID string              `json:"winning_outcome_id,omitempty"`
        Outcomes         []PredictionOutcome `json:"outcomes"`
        PredictionWindow int                 `json:"prediction_window"`
        Status           string              `json:"status"` // ACTIVE, CANCELED, LOCKED, RESOLVED
        CreatedAt        time.Time           `json:"created_at"`
        EndedAt          time.Time           `json:"ended_at,omitempty"`
        LockedAt         time.Time           `json:"locked_at,omitempty"`
}

// PredictionOutcome represents an outcome of a prediction.
type PredictionOutcome struct {
        ID            string                `json:"id"`
        Title         string                `json:"title"`
        Users         int                   `json:"users"`
        ChannelPoints int                   `json:"channel_points"`
        TopPredictors []PredictionPredictor `json:"top_predictors,omitempty"`
        Color         string                `json:"color"`
}

// PredictionPredictor represents a top predictor.
type PredictionPredictor struct {
        UserID            string `json:"user_id"`
        UserLogin         string `json:"user_login"`
        UserName          string `json:"user_name"`
        ChannelPointsUsed int    `json:"channel_points_used"`
        ChannelPointsWon  int    `json:"channel_points_won"`
}

// GetPredictionsParams contains parameters for GetPredictions.
type GetPredictionsParams struct {
        BroadcasterID string
        IDs           []string // Prediction IDs (max 100)
        *PaginationParams
}

// GetPredictions gets predictions for a channel.
// Requires: channel:read:predictions scope.
func (c *Client) GetPredictions(ctx context.Context, params *GetPredictionsParams) (*Response[Prediction], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        for _, id := range params.IDs </span><span class="cov0" title="0">{
                q.Add("id", id)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[Prediction]
        if err := c.get(ctx, "/predictions", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// CreatePredictionParams contains parameters for CreatePrediction.
type CreatePredictionParams struct {
        BroadcasterID    string                    `json:"broadcaster_id"`
        Title            string                    `json:"title"`
        Outcomes         []CreatePredictionOutcome `json:"outcomes"`          // 2-10 outcomes
        PredictionWindow int                       `json:"prediction_window"` // 30-1800 seconds
}

// CreatePredictionOutcome represents an outcome when creating a prediction.
type CreatePredictionOutcome struct {
        Title string `json:"title"`
}

// CreatePrediction creates a prediction on a channel.
// Requires: channel:manage:predictions scope.
func (c *Client) CreatePrediction(ctx context.Context, params *CreatePredictionParams) (*Prediction, error) <span class="cov0" title="0">{
        var resp Response[Prediction]
        if err := c.post(ctx, "/predictions", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// EndPredictionParams contains parameters for EndPrediction.
type EndPredictionParams struct {
        BroadcasterID    string `json:"broadcaster_id"`
        ID               string `json:"id"`
        Status           string `json:"status"`                       // RESOLVED, CANCELED, or LOCKED
        WinningOutcomeID string `json:"winning_outcome_id,omitempty"` // Required if status is RESOLVED
}

// EndPrediction ends a prediction.
// Requires: channel:manage:predictions scope.
func (c *Client) EndPrediction(ctx context.Context, params *EndPredictionParams) (*Prediction, error) <span class="cov0" title="0">{
        var resp Response[Prediction]
        if err := c.patch(ctx, "/predictions", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// Raid represents a raid.
type Raid struct {
        CreatedAt time.Time `json:"created_at"`
        IsMature  bool      `json:"is_mature"`
}

// StartRaidParams contains parameters for StartRaid.
type StartRaidParams struct {
        FromBroadcasterID string // The broadcaster initiating the raid
        ToBroadcasterID   string // The broadcaster being raided
}

// StartRaid starts a raid on another channel.
// Requires: channel:manage:raids scope.
func (c *Client) StartRaid(ctx context.Context, params *StartRaidParams) (*Raid, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("from_broadcaster_id", params.FromBroadcasterID)
        q.Set("to_broadcaster_id", params.ToBroadcasterID)

        var resp Response[Raid]
        if err := c.post(ctx, "/raids", q, nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// CancelRaid cancels a pending raid.
// Requires: channel:manage:raids scope.
func (c *Client) CancelRaid(ctx context.Context, broadcasterID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        return c.delete(ctx, "/raids", q, nil)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// Schedule represents a channel's stream schedule.
type Schedule struct {
        Segments         []ScheduleSegment `json:"segments"`
        BroadcasterID    string            `json:"broadcaster_id"`
        BroadcasterName  string            `json:"broadcaster_name"`
        BroadcasterLogin string            `json:"broadcaster_login"`
        Vacation         *Vacation         `json:"vacation,omitempty"`
}

// ScheduleSegment represents a segment in a schedule.
type ScheduleSegment struct {
        ID            string     `json:"id"`
        StartTime     time.Time  `json:"start_time"`
        EndTime       time.Time  `json:"end_time"`
        Title         string     `json:"title"`
        CanceledUntil *time.Time `json:"canceled_until,omitempty"`
        Category      *Category  `json:"category,omitempty"`
        IsRecurring   bool       `json:"is_recurring"`
}

// Category represents a category/game.
type Category struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

// Vacation represents a vacation period.
type Vacation struct {
        StartTime time.Time `json:"start_time"`
        EndTime   time.Time `json:"end_time"`
}

// GetChannelStreamScheduleParams contains parameters for GetChannelStreamSchedule.
type GetChannelStreamScheduleParams struct {
        BroadcasterID string
        IDs           []string // Segment IDs
        StartTime     time.Time
        UTCOffset     string // e.g., "-04:00"
        *PaginationParams
}

// ScheduleResponse represents the response from GetChannelStreamSchedule.
type ScheduleResponse struct {
        Data       Schedule    `json:"data"`
        Pagination *Pagination `json:"pagination,omitempty"`
}

// GetChannelStreamSchedule gets a channel's stream schedule.
func (c *Client) GetChannelStreamSchedule(ctx context.Context, params *GetChannelStreamScheduleParams) (*ScheduleResponse, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        for _, id := range params.IDs </span><span class="cov0" title="0">{
                q.Add("id", id)
        }</span>
        <span class="cov0" title="0">if !params.StartTime.IsZero() </span><span class="cov0" title="0">{
                q.Set("start_time", params.StartTime.Format(time.RFC3339))
        }</span>
        <span class="cov0" title="0">if params.UTCOffset != "" </span><span class="cov0" title="0">{
                q.Set("utc_offset", params.UTCOffset)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp ScheduleResponse
        if err := c.get(ctx, "/schedule", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetChannelICalendar gets a channel's stream schedule as iCalendar.
func (c *Client) GetChannelICalendar(ctx context.Context, broadcasterID string) (string, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        req := &amp;Request{
                Method:   "GET",
                Endpoint: "/schedule/icalendar",
                Query:    q,
        }

        // Build URL
        url := c.baseURL + req.Endpoint + "?" + req.Query.Encode()

        httpReq, err := c.httpClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = httpReq.Body.Close() }</span>()

        <span class="cov0" title="0">body := make([]byte, 0)
        if _, err := httpReq.Body.Read(body); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(body), nil</span>
}

// UpdateChannelStreamScheduleParams contains parameters for UpdateChannelStreamSchedule.
type UpdateChannelStreamScheduleParams struct {
        BroadcasterID     string     `json:"-"`
        IsVacationEnabled *bool      `json:"is_vacation_enabled,omitempty"`
        VacationStartTime *time.Time `json:"vacation_start_time,omitempty"`
        VacationEndTime   *time.Time `json:"vacation_end_time,omitempty"`
        Timezone          string     `json:"timezone,omitempty"`
}

// UpdateChannelStreamSchedule updates a channel's stream schedule settings.
// Requires: channel:manage:schedule scope.
func (c *Client) UpdateChannelStreamSchedule(ctx context.Context, params *UpdateChannelStreamScheduleParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        if params.IsVacationEnabled != nil </span><span class="cov0" title="0">{
                if *params.IsVacationEnabled </span><span class="cov0" title="0">{
                        q.Set("is_vacation_enabled", "true")
                }</span> else<span class="cov0" title="0"> {
                        q.Set("is_vacation_enabled", "false")
                }</span>
        }
        <span class="cov0" title="0">if params.VacationStartTime != nil </span><span class="cov0" title="0">{
                q.Set("vacation_start_time", params.VacationStartTime.Format(time.RFC3339))
        }</span>
        <span class="cov0" title="0">if params.VacationEndTime != nil </span><span class="cov0" title="0">{
                q.Set("vacation_end_time", params.VacationEndTime.Format(time.RFC3339))
        }</span>
        <span class="cov0" title="0">if params.Timezone != "" </span><span class="cov0" title="0">{
                q.Set("timezone", params.Timezone)
        }</span>

        <span class="cov0" title="0">return c.patch(ctx, "/schedule/settings", q, nil, nil)</span>
}

// CreateChannelStreamScheduleSegmentParams contains parameters for CreateChannelStreamScheduleSegment.
type CreateChannelStreamScheduleSegmentParams struct {
        BroadcasterID string    `json:"-"`
        StartTime     time.Time `json:"start_time"`
        Timezone      string    `json:"timezone"`
        Duration      int       `json:"duration"` // minutes (30-1380)
        IsRecurring   bool      `json:"is_recurring,omitempty"`
        CategoryID    string    `json:"category_id,omitempty"`
        Title         string    `json:"title,omitempty"`
}

// CreateChannelStreamScheduleSegment creates a new schedule segment.
// Requires: channel:manage:schedule scope.
func (c *Client) CreateChannelStreamScheduleSegment(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams) (*ScheduleSegment, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)

        var resp struct {
                Data struct {
                        Segments []ScheduleSegment `json:"segments"`
                } `json:"data"`
        }
        if err := c.post(ctx, "/schedule/segment", q, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data.Segments) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data.Segments[0], nil</span>
}

// UpdateChannelStreamScheduleSegmentParams contains parameters for UpdateChannelStreamScheduleSegment.
type UpdateChannelStreamScheduleSegmentParams struct {
        BroadcasterID string     `json:"-"`
        ID            string     `json:"-"`
        StartTime     *time.Time `json:"start_time,omitempty"`
        Duration      *int       `json:"duration,omitempty"`
        CategoryID    *string    `json:"category_id,omitempty"`
        Title         *string    `json:"title,omitempty"`
        IsCanceled    *bool      `json:"is_canceled,omitempty"`
        Timezone      string     `json:"timezone,omitempty"`
}

// UpdateChannelStreamScheduleSegment updates a schedule segment.
// Requires: channel:manage:schedule scope.
func (c *Client) UpdateChannelStreamScheduleSegment(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams) (*ScheduleSegment, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        q.Set("id", params.ID)

        var resp struct {
                Data struct {
                        Segments []ScheduleSegment `json:"segments"`
                } `json:"data"`
        }
        if err := c.patch(ctx, "/schedule/segment", q, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data.Segments) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data.Segments[0], nil</span>
}

// DeleteChannelStreamScheduleSegment deletes a schedule segment.
// Requires: channel:manage:schedule scope.
func (c *Client) DeleteChannelStreamScheduleSegment(ctx context.Context, broadcasterID, segmentID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("id", segmentID)

        return c.delete(ctx, "/schedule/segment", q, nil)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// SearchCategory represents a search result for categories.
type SearchCategory struct {
        ID        string `json:"id"`
        Name      string `json:"name"`
        BoxArtURL string `json:"box_art_url"`
}

// SearchCategoriesParams contains parameters for SearchCategories.
type SearchCategoriesParams struct {
        Query string
        *PaginationParams
}

// SearchCategories searches for categories/games.
func (c *Client) SearchCategories(ctx context.Context, params *SearchCategoriesParams) (*Response[SearchCategory], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("query", params.Query)
        addPaginationParams(q, params.PaginationParams)

        var resp Response[SearchCategory]
        if err := c.get(ctx, "/search/categories", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// SearchChannel represents a search result for channels.
type SearchChannel struct {
        BroadcasterLanguage string    `json:"broadcaster_language"`
        BroadcasterLogin    string    `json:"broadcaster_login"`
        DisplayName         string    `json:"display_name"`
        GameID              string    `json:"game_id"`
        GameName            string    `json:"game_name"`
        ID                  string    `json:"id"`
        IsLive              bool      `json:"is_live"`
        Tags                []string  `json:"tags"`
        ThumbnailURL        string    `json:"thumbnail_url"`
        Title               string    `json:"title"`
        StartedAt           time.Time `json:"started_at,omitempty"`
}

// SearchChannelsParams contains parameters for SearchChannels.
type SearchChannelsParams struct {
        Query    string
        LiveOnly bool
        *PaginationParams
}

// SearchChannels searches for channels.
func (c *Client) SearchChannels(ctx context.Context, params *SearchChannelsParams) (*Response[SearchChannel], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("query", params.Query)
        if params.LiveOnly </span><span class="cov0" title="0">{
                q.Set("live_only", "true")
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[SearchChannel]
        if err := c.get(ctx, "/search/channels", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// Stream represents a live stream.
type Stream struct {
        ID           string    `json:"id"`
        UserID       string    `json:"user_id"`
        UserLogin    string    `json:"user_login"`
        UserName     string    `json:"user_name"`
        GameID       string    `json:"game_id"`
        GameName     string    `json:"game_name"`
        Type         string    `json:"type"` // "live" or ""
        Title        string    `json:"title"`
        ViewerCount  int       `json:"viewer_count"`
        StartedAt    time.Time `json:"started_at"`
        Language     string    `json:"language"`
        ThumbnailURL string    `json:"thumbnail_url"`
        Tags         []string  `json:"tags"`
        IsMature     bool      `json:"is_mature"`
}

// GetStreamsParams contains parameters for GetStreams.
type GetStreamsParams struct {
        UserIDs    []string // Filter by user IDs (max 100)
        UserLogins []string // Filter by user logins (max 100)
        GameIDs    []string // Filter by game IDs (max 100)
        Type       string   // "all" or "live"
        Language   []string // Filter by language
        *PaginationParams
}

// GetStreams gets active streams.
func (c *Client) GetStreams(ctx context.Context, params *GetStreamsParams) (*Response[Stream], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil </span><span class="cov0" title="0">{
                for _, id := range params.UserIDs </span><span class="cov0" title="0">{
                        q.Add("user_id", id)
                }</span>
                <span class="cov0" title="0">for _, login := range params.UserLogins </span><span class="cov0" title="0">{
                        q.Add("user_login", login)
                }</span>
                <span class="cov0" title="0">for _, gameID := range params.GameIDs </span><span class="cov0" title="0">{
                        q.Add("game_id", gameID)
                }</span>
                <span class="cov0" title="0">for _, lang := range params.Language </span><span class="cov0" title="0">{
                        q.Add("language", lang)
                }</span>
                <span class="cov0" title="0">if params.Type != "" </span><span class="cov0" title="0">{
                        q.Set("type", params.Type)
                }</span>
                <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)</span>
        }

        <span class="cov0" title="0">var resp Response[Stream]
        if err := c.get(ctx, "/streams", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetFollowedStreamsParams contains parameters for GetFollowedStreams.
type GetFollowedStreamsParams struct {
        UserID string // Required: The user's ID
        *PaginationParams
}

// GetFollowedStreams gets streams from channels that the user follows.
// Requires: user:read:follows scope.
func (c *Client) GetFollowedStreams(ctx context.Context, params *GetFollowedStreamsParams) (*Response[Stream], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("user_id", params.UserID)
        addPaginationParams(q, params.PaginationParams)

        var resp Response[Stream]
        if err := c.get(ctx, "/streams/followed", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// StreamKey represents a stream key.
type StreamKey struct {
        StreamKey string `json:"stream_key"`
}

// GetStreamKey gets the stream key for a broadcaster.
// Requires: channel:read:stream_key scope.
func (c *Client) GetStreamKey(ctx context.Context, broadcasterID string) (*StreamKey, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[StreamKey]
        if err := c.get(ctx, "/streams/key", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// StreamMarker represents a stream marker.
type StreamMarker struct {
        ID              string    `json:"id"`
        CreatedAt       time.Time `json:"created_at"`
        Description     string    `json:"description"`
        PositionSeconds int       `json:"position_seconds"`
}

// CreateStreamMarkerParams contains parameters for CreateStreamMarker.
type CreateStreamMarkerParams struct {
        UserID      string `json:"user_id"`
        Description string `json:"description,omitempty"`
}

// CreateStreamMarker creates a marker in the stream.
// Requires: channel:manage:broadcast scope.
func (c *Client) CreateStreamMarker(ctx context.Context, params *CreateStreamMarkerParams) (*StreamMarker, error) <span class="cov0" title="0">{
        var resp Response[StreamMarker]
        if err := c.post(ctx, "/streams/markers", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// VideoStreamMarkers represents markers for a video.
type VideoStreamMarkers struct {
        UserID    string `json:"user_id"`
        UserLogin string `json:"user_login"`
        UserName  string `json:"user_name"`
        Videos    []struct {
                VideoID string         `json:"video_id"`
                Markers []StreamMarker `json:"markers"`
        } `json:"videos"`
}

// GetStreamMarkersParams contains parameters for GetStreamMarkers.
type GetStreamMarkersParams struct {
        UserID  string // Either UserID or VideoID is required
        VideoID string
        *PaginationParams
}

// GetStreamMarkers gets stream markers.
// Requires: user:read:broadcast scope.
func (c *Client) GetStreamMarkers(ctx context.Context, params *GetStreamMarkersParams) (*Response[VideoStreamMarkers], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params.UserID != "" </span><span class="cov0" title="0">{
                q.Set("user_id", params.UserID)
        }</span>
        <span class="cov0" title="0">if params.VideoID != "" </span><span class="cov0" title="0">{
                q.Set("video_id", params.VideoID)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[VideoStreamMarkers]
        if err := c.get(ctx, "/streams/markers", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package helix

import (
        "context"
        "net/url"
)

// Subscription represents a channel subscription.
type Subscription struct {
        BroadcasterID    string `json:"broadcaster_id"`
        BroadcasterLogin string `json:"broadcaster_login"`
        BroadcasterName  string `json:"broadcaster_name"`
        GifterID         string `json:"gifter_id,omitempty"`
        GifterLogin      string `json:"gifter_login,omitempty"`
        GifterName       string `json:"gifter_name,omitempty"`
        IsGift           bool   `json:"is_gift"`
        PlanName         string `json:"plan_name"`
        Tier             string `json:"tier"` // 1000, 2000, 3000
        UserID           string `json:"user_id"`
        UserLogin        string `json:"user_login"`
        UserName         string `json:"user_name"`
}

// GetBroadcasterSubscriptionsParams contains parameters for GetBroadcasterSubscriptions.
type GetBroadcasterSubscriptionsParams struct {
        BroadcasterID string
        UserIDs       []string // Filter by user IDs (max 100)
        *PaginationParams
}

// SubscriptionsResponse represents the response from GetBroadcasterSubscriptions.
type SubscriptionsResponse struct {
        Data       []Subscription `json:"data"`
        Pagination *Pagination    `json:"pagination,omitempty"`
        Total      int            `json:"total"`
        Points     int            `json:"points"` // Subscriber points (based on tiers)
}

// GetBroadcasterSubscriptions gets the list of subscribers for a channel.
// Requires: channel:read:subscriptions scope.
func (c *Client) GetBroadcasterSubscriptions(ctx context.Context, params *GetBroadcasterSubscriptionsParams) (*SubscriptionsResponse, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        for _, id := range params.UserIDs </span><span class="cov0" title="0">{
                q.Add("user_id", id)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp SubscriptionsResponse
        if err := c.get(ctx, "/subscriptions", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// UserSubscription represents a user's subscription to a channel.
type UserSubscription struct {
        BroadcasterID    string `json:"broadcaster_id"`
        BroadcasterLogin string `json:"broadcaster_login"`
        BroadcasterName  string `json:"broadcaster_name"`
        GifterID         string `json:"gifter_id,omitempty"`
        GifterLogin      string `json:"gifter_login,omitempty"`
        GifterName       string `json:"gifter_name,omitempty"`
        IsGift           bool   `json:"is_gift"`
        Tier             string `json:"tier"`
}

// CheckUserSubscription checks if a user is subscribed to a channel.
// Requires: user:read:subscriptions scope.
func (c *Client) CheckUserSubscription(ctx context.Context, broadcasterID, userID string) (*UserSubscription, error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)
        q.Set("user_id", userID)

        var resp Response[UserSubscription]
        if err := c.get(ctx, "/subscriptions/user", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// Team represents a Twitch team.
type Team struct {
        ID                 string     `json:"id"`
        TeamName           string     `json:"team_name"`
        TeamDisplayName    string     `json:"team_display_name"`
        Info               string     `json:"info"`
        ThumbnailURL       string     `json:"thumbnail_url"`
        BackgroundImageURL string     `json:"background_image_url"`
        Banner             string     `json:"banner"`
        CreatedAt          time.Time  `json:"created_at"`
        UpdatedAt          time.Time  `json:"updated_at"`
        Users              []TeamUser `json:"users,omitempty"`
}

// TeamUser represents a user in a team.
type TeamUser struct {
        UserID    string `json:"user_id"`
        UserLogin string `json:"user_login"`
        UserName  string `json:"user_name"`
}

// ChannelTeam represents a team that a channel belongs to.
type ChannelTeam struct {
        BroadcasterID      string    `json:"broadcaster_id"`
        BroadcasterLogin   string    `json:"broadcaster_login"`
        BroadcasterName    string    `json:"broadcaster_name"`
        BackgroundImageURL string    `json:"background_image_url"`
        Banner             string    `json:"banner"`
        CreatedAt          time.Time `json:"created_at"`
        UpdatedAt          time.Time `json:"updated_at"`
        Info               string    `json:"info"`
        ThumbnailURL       string    `json:"thumbnail_url"`
        TeamName           string    `json:"team_name"`
        TeamDisplayName    string    `json:"team_display_name"`
        ID                 string    `json:"id"`
}

// GetChannelTeams gets the teams a broadcaster belongs to.
func (c *Client) GetChannelTeams(ctx context.Context, broadcasterID string) (*Response[ChannelTeam], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", broadcasterID)

        var resp Response[ChannelTeam]
        if err := c.get(ctx, "/teams/channel", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetTeamsParams contains parameters for GetTeams.
type GetTeamsParams struct {
        Name string // Team name
        ID   string // Team ID
}

// GetTeams gets team information.
func (c *Client) GetTeams(ctx context.Context, params *GetTeamsParams) (*Response[Team], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params.Name != "" </span><span class="cov0" title="0">{
                q.Set("name", params.Name)
        }</span>
        <span class="cov0" title="0">if params.ID != "" </span><span class="cov0" title="0">{
                q.Set("id", params.ID)
        }</span>

        <span class="cov0" title="0">var resp Response[Team]
        if err := c.get(ctx, "/teams", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package helix

import (
        "context"
        "fmt"
        "net/url"
        "time"
)

// User represents a Twitch user.
type User struct {
        ID              string    `json:"id"`
        Login           string    `json:"login"`
        DisplayName     string    `json:"display_name"`
        Type            string    `json:"type"`
        BroadcasterType string    `json:"broadcaster_type"`
        Description     string    `json:"description"`
        ProfileImageURL string    `json:"profile_image_url"`
        OfflineImageURL string    `json:"offline_image_url"`
        ViewCount       int       `json:"view_count"` // Deprecated
        Email           string    `json:"email,omitempty"`
        CreatedAt       time.Time `json:"created_at"`
}

// GetUsersParams contains parameters for GetUsers.
type GetUsersParams struct {
        IDs    []string // User IDs (max 100)
        Logins []string // User login names (max 100)
}

// GetUsers gets information about one or more Twitch users.
// Requires: No scope for public data, user:read:email for email.
func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams) (*Response[User], error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil </span><span class="cov0" title="0">{
                for _, id := range params.IDs </span><span class="cov0" title="0">{
                        q.Add("id", id)
                }</span>
                <span class="cov0" title="0">for _, login := range params.Logins </span><span class="cov0" title="0">{
                        q.Add("login", login)
                }</span>
        }

        <span class="cov0" title="0">var resp Response[User]
        if err := c.get(ctx, "/users", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// GetCurrentUser gets information about the authenticated user.
func (c *Client) GetCurrentUser(ctx context.Context) (*User, error) <span class="cov0" title="0">{
        resp, err := c.GetUsers(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// UpdateUserParams contains parameters for UpdateUser.
type UpdateUserParams struct {
        Description string `json:"description,omitempty"`
}

// UpdateUser updates the authenticated user's information.
// Requires: user:edit scope.
func (c *Client) UpdateUser(ctx context.Context, params *UpdateUserParams) (*User, error) <span class="cov0" title="0">{
        q := url.Values{}
        if params != nil &amp;&amp; params.Description != "" </span><span class="cov0" title="0">{
                q.Set("description", params.Description)
        }</span>

        <span class="cov0" title="0">var resp Response[User]
        if err := c.put(ctx, "/users", q, nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(resp.Data) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data[0], nil</span>
}

// BlockedUser represents a blocked user.
type BlockedUser struct {
        UserID      string `json:"user_id"`
        UserLogin   string `json:"user_login"`
        DisplayName string `json:"display_name"`
}

// GetUserBlockListParams contains parameters for GetUserBlockList.
type GetUserBlockListParams struct {
        BroadcasterID string
        *PaginationParams
}

// GetUserBlockList gets the authenticated user's block list.
// Requires: user:read:blocked_users scope.
func (c *Client) GetUserBlockList(ctx context.Context, params *GetUserBlockListParams) (*Response[BlockedUser], error) <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("broadcaster_id", params.BroadcasterID)
        addPaginationParams(q, params.PaginationParams)

        var resp Response[BlockedUser]
        if err := c.get(ctx, "/users/blocks", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// BlockUserParams contains parameters for BlockUser.
type BlockUserParams struct {
        TargetUserID  string
        SourceContext string // "chat" or "whisper"
        Reason        string // "spam", "harassment", or "other"
}

// BlockUser blocks a user.
// Requires: user:manage:blocked_users scope.
func (c *Client) BlockUser(ctx context.Context, params *BlockUserParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("target_user_id", params.TargetUserID)
        if params.SourceContext != "" </span><span class="cov0" title="0">{
                q.Set("source_context", params.SourceContext)
        }</span>
        <span class="cov0" title="0">if params.Reason != "" </span><span class="cov0" title="0">{
                q.Set("reason", params.Reason)
        }</span>

        <span class="cov0" title="0">return c.put(ctx, "/users/blocks", q, nil, nil)</span>
}

// UnblockUser unblocks a user.
// Requires: user:manage:blocked_users scope.
func (c *Client) UnblockUser(ctx context.Context, targetUserID string) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("target_user_id", targetUserID)

        return c.delete(ctx, "/users/blocks", q, nil)
}</span>

// UserExtension represents a user's extension.
type UserExtension struct {
        ID          string   `json:"id"`
        Version     string   `json:"version"`
        Name        string   `json:"name"`
        CanActivate bool     `json:"can_activate"`
        Type        []string `json:"type"`
}

// GetUserExtensions gets extensions installed by the authenticated user.
// Requires: user:read:broadcast scope.
func (c *Client) GetUserExtensions(ctx context.Context) (*Response[UserExtension], error) <span class="cov0" title="0">{
        var resp Response[UserExtension]
        if err := c.get(ctx, "/users/extensions/list", nil, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// UserActiveExtensions represents a user's active extensions.
type UserActiveExtensions struct {
        Panel     map[string]ActiveExtension `json:"panel"`
        Overlay   map[string]ActiveExtension `json:"overlay"`
        Component map[string]ActiveExtension `json:"component"`
}

// ActiveExtension represents an active extension in a slot.
type ActiveExtension struct {
        Active  bool   `json:"active"`
        ID      string `json:"id,omitempty"`
        Version string `json:"version,omitempty"`
        Name    string `json:"name,omitempty"`
        X       int    `json:"x,omitempty"`
        Y       int    `json:"y,omitempty"`
}

// GetUserActiveExtensions gets the active extensions for a user.
// Requires: user:read:broadcast or user:edit:broadcast scope.
func (c *Client) GetUserActiveExtensions(ctx context.Context, userID string) (*UserActiveExtensions, error) <span class="cov0" title="0">{
        q := url.Values{}
        if userID != "" </span><span class="cov0" title="0">{
                q.Set("user_id", userID)
        }</span>

        <span class="cov0" title="0">var resp struct {
                Data UserActiveExtensions `json:"data"`
        }
        if err := c.get(ctx, "/users/extensions", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data, nil</span>
}

// UpdateUserExtensionsParams contains parameters for UpdateUserExtensions.
type UpdateUserExtensionsParams struct {
        Data UserActiveExtensions `json:"data"`
}

// UpdateUserExtensions updates the active extensions for the authenticated user.
// Requires: user:edit:broadcast scope.
func (c *Client) UpdateUserExtensions(ctx context.Context, params *UpdateUserExtensionsParams) (*UserActiveExtensions, error) <span class="cov0" title="0">{
        var resp struct {
                Data UserActiveExtensions `json:"data"`
        }
        if err := c.put(ctx, "/users/extensions", nil, params, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp.Data, nil</span>
}

// UserAuthorization represents the authorization scopes granted by a user.
type UserAuthorization struct {
        ClientID string   `json:"client_id"`
        UserID   string   `json:"user_id"`
        Login    string   `json:"login"`
        Scopes   []string `json:"scopes"`
}

// GetAuthorizationByUserParams contains parameters for GetAuthorizationByUser.
type GetAuthorizationByUserParams struct {
        UserID string // Required: The ID of a user that granted the application OAuth permissions
}

// GetAuthorizationByUser gets the authorization scopes that the specified user has granted the application.
// Requires: App access token.
func (c *Client) GetAuthorizationByUser(ctx context.Context, params *GetAuthorizationByUserParams) (*Response[UserAuthorization], error) <span class="cov0" title="0">{
        if params == nil || params.UserID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user_id is required")
        }</span>

        <span class="cov0" title="0">q := url.Values{}
        q.Set("user_id", params.UserID)

        var resp Response[UserAuthorization]
        if err := c.get(ctx, "/users/authorization", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package helix

import (
        "context"
        "net/url"
        "time"
)

// Video represents a Twitch video (VOD, highlight, or upload).
type Video struct {
        ID            string         `json:"id"`
        StreamID      string         `json:"stream_id,omitempty"`
        UserID        string         `json:"user_id"`
        UserLogin     string         `json:"user_login"`
        UserName      string         `json:"user_name"`
        Title         string         `json:"title"`
        Description   string         `json:"description"`
        CreatedAt     time.Time      `json:"created_at"`
        PublishedAt   time.Time      `json:"published_at"`
        URL           string         `json:"url"`
        ThumbnailURL  string         `json:"thumbnail_url"`
        Viewable      string         `json:"viewable"`
        ViewCount     int            `json:"view_count"`
        Language      string         `json:"language"`
        Type          string         `json:"type"` // archive, highlight, upload
        Duration      string         `json:"duration"`
        MutedSegments []MutedSegment `json:"muted_segments,omitempty"`
}

// MutedSegment represents a muted segment in a video.
type MutedSegment struct {
        Duration int `json:"duration"`
        Offset   int `json:"offset"`
}

// GetVideosParams contains parameters for GetVideos.
type GetVideosParams struct {
        IDs      []string // Video IDs (max 100)
        UserID   string
        GameID   string
        Language string
        Period   string // all, day, week, month
        Sort     string // time, trending, views
        Type     string // all, archive, highlight, upload
        *PaginationParams
}

// GetVideos gets videos.
func (c *Client) GetVideos(ctx context.Context, params *GetVideosParams) (*Response[Video], error) <span class="cov0" title="0">{
        q := url.Values{}
        for _, id := range params.IDs </span><span class="cov0" title="0">{
                q.Add("id", id)
        }</span>
        <span class="cov0" title="0">if params.UserID != "" </span><span class="cov0" title="0">{
                q.Set("user_id", params.UserID)
        }</span>
        <span class="cov0" title="0">if params.GameID != "" </span><span class="cov0" title="0">{
                q.Set("game_id", params.GameID)
        }</span>
        <span class="cov0" title="0">if params.Language != "" </span><span class="cov0" title="0">{
                q.Set("language", params.Language)
        }</span>
        <span class="cov0" title="0">if params.Period != "" </span><span class="cov0" title="0">{
                q.Set("period", params.Period)
        }</span>
        <span class="cov0" title="0">if params.Sort != "" </span><span class="cov0" title="0">{
                q.Set("sort", params.Sort)
        }</span>
        <span class="cov0" title="0">if params.Type != "" </span><span class="cov0" title="0">{
                q.Set("type", params.Type)
        }</span>
        <span class="cov0" title="0">addPaginationParams(q, params.PaginationParams)

        var resp Response[Video]
        if err := c.get(ctx, "/videos", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// DeleteVideosResponse represents the response from DeleteVideos.
type DeleteVideosResponse []string

// DeleteVideos deletes one or more videos.
// Requires: channel:manage:videos scope.
func (c *Client) DeleteVideos(ctx context.Context, videoIDs []string) ([]string, error) <span class="cov0" title="0">{
        q := url.Values{}
        for _, id := range videoIDs </span><span class="cov0" title="0">{
                q.Add("id", id)
        }</span>

        <span class="cov0" title="0">var resp struct {
                Data []string `json:"data"`
        }
        if err := c.delete(ctx, "/videos", q, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package helix

import (
        "context"
        "net/url"
)

// SendWhisperParams contains parameters for SendWhisper.
type SendWhisperParams struct {
        FromUserID string `json:"-"`
        ToUserID   string `json:"-"`
        Message    string `json:"message"`
}

// SendWhisper sends a whisper message to another user.
// Requires: user:manage:whispers scope.
func (c *Client) SendWhisper(ctx context.Context, params *SendWhisperParams) error <span class="cov0" title="0">{
        q := url.Values{}
        q.Set("from_user_id", params.FromUserID)
        q.Set("to_user_id", params.ToUserID)

        return c.post(ctx, "/whispers", q, params, nil)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
