name: Promote Release

on:
  workflow_dispatch:
    inputs:
      action:
        description: "promote (test -> main) or archive (tag current main)"
        required: true
        default: promote
        type: choice
        options: [promote, archive]
      release_type:
        description: "Version bump type (auto-increments from latest tag)"
        required: false
        default: patch
        type: choice
        options:
          - patch    # v0.3.1 -> v0.3.2 (bug fixes)
          - minor    # v0.3.1 -> v0.4.0 (new features)
          - major    # v0.3.1 -> v1.0.0 (breaking changes)
          - custom   # Use tag_name input instead
      tag_name:
        description: "Custom tag (only used when release_type is 'custom')"
        required: false
        type: string
      auto_merge:
        description: "Auto-merge PR and create release tag"
        required: false
        default: false
        type: boolean
      archive_tag:
        description: "Tag name when archiving (e.g., v1-archive)"
        required: false
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  promote:
    if: ${{ github.event.inputs.action == 'promote' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          ref: test
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: '1.23'

      - name: Run tests
        run: go test -v ./...

      - name: Calculate next version
        id: version
        env:
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}
          CUSTOM_TAG: ${{ github.event.inputs.tag_name }}
        run: |
          set -euo pipefail

          # Get latest tag
          LATEST_TAG=$(git tag --sort=-v:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -1 || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          if [ "$RELEASE_TYPE" = "custom" ]; then
            if [ -z "${CUSTOM_TAG:-}" ]; then
              echo "Error: tag_name is required when release_type is 'custom'"
              exit 1
            fi
            NEXT_TAG="$CUSTOM_TAG"
          else
            # Parse version components
            VERSION="${LATEST_TAG#v}"
            MAJOR=$(echo "$VERSION" | cut -d. -f1)
            MINOR=$(echo "$VERSION" | cut -d. -f2)
            PATCH=$(echo "$VERSION" | cut -d. -f3)

            case "$RELEASE_TYPE" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac

            NEXT_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "Next tag: $NEXT_TAG"
          echo "tag=$NEXT_TAG" >> $GITHUB_OUTPUT

      - name: Update CHANGELOG version
        id: changelog
        env:
          TAG_NAME: ${{ steps.version.outputs.tag }}
        run: |
          set -euo pipefail
          VERSION="${TAG_NAME#v}"
          TODAY=$(date +%Y-%m-%d)
          if grep -qE "^## \[${VERSION}\]" CHANGELOG.md; then
            echo "‚úÖ CHANGELOG.md already contains entry for version ${VERSION}"
            echo "updated=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          UNRELEASED_CONTENT=$(sed -n '/^## \[Unreleased\]/,/^## \[/p' CHANGELOG.md | grep -E '^- ' || true)
          if [ -z "$UNRELEASED_CONTENT" ]; then
            echo "‚ùå CHANGELOG.md has no unreleased changes to release"
            echo "Please add changelog entries under [Unreleased] before releasing"
            exit 1
          fi
          echo "üìù Updating CHANGELOG.md: [Unreleased] -> [${VERSION}] - ${TODAY}"
          printf '## [Unreleased]\n\n### Added\n\n### Changed\n\n### Fixed\n\n' > /tmp/unreleased.txt
          sed -i "s/^## \[Unreleased\]$/## [${VERSION}] - ${TODAY}/" CHANGELOG.md
          sed -i "/^## \[${VERSION}\]/e cat /tmp/unreleased.txt" CHANGELOG.md
          rm -f /tmp/unreleased.txt
          echo "‚úÖ CHANGELOG.md updated with version ${VERSION}"
          echo "Changes being released:"
          echo "$UNRELEASED_CONTENT"
          echo "updated=true" >> $GITHUB_OUTPUT

      - name: Commit CHANGELOG update
        if: steps.changelog.outputs.updated == 'true'
        env:
          TAG_NAME: ${{ steps.version.outputs.tag }}
        run: |
          set -euo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "Release ${TAG_NAME}: Update CHANGELOG version"
          git push origin test
          echo "‚úÖ CHANGELOG update committed to test branch"

      - name: Create promotion PR
        id: pr
        env:
          TAG_NAME: ${{ steps.version.outputs.tag }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          # Check if PR already exists
          EXISTING_PR=$(gh pr list --base main --head test --json number --jq '.[0].number' || echo "")

          if [ -n "$EXISTING_PR" ]; then
            echo "PR #$EXISTING_PR already exists for test -> main"
            echo "URL: https://github.com/${{ github.repository }}/pull/$EXISTING_PR"
            echo "number=$EXISTING_PR" >> $GITHUB_OUTPUT
            echo "created=false" >> $GITHUB_OUTPUT
          else
            # Create PR to merge test into main
            PR_TITLE="Release ${TAG_NAME}: Promote test to main"

            PR_URL=$(gh pr create \
              --base main \
              --head test \
              --title "$PR_TITLE" \
              --body "## Summary

          Automated promotion of test branch to main.

          **Version:** ${TAG_NAME}
          **Release type:** ${RELEASE_TYPE}

          ## Test plan

          - [x] All tests pass on test branch
          - [ ] Review changes before merging

          ü§ñ Generated with GitHub Actions")

            # Extract PR number from URL
            PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
            echo "Created PR: $PR_URL"
            echo "number=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "created=true" >> $GITHUB_OUTPUT
          fi

      - name: Add PR link to CHANGELOG
        if: steps.pr.outputs.created == 'true'
        env:
          TAG_NAME: ${{ steps.version.outputs.tag }}
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          VERSION="${TAG_NAME#v}"
          REPO="${{ github.repository }}"
          PR_LINK="([#${PR_NUMBER}](https://github.com/${REPO}/pull/${PR_NUMBER}))"

          # Check if PR link already exists in changelog
          if grep -qE "^## \[${VERSION}\].*#${PR_NUMBER}" CHANGELOG.md; then
            echo "PR link already exists in CHANGELOG.md"
            exit 0
          fi

          # Add PR link to the version line (use | delimiter to avoid conflicts with URLs)
          sed -i "s|^## \[${VERSION}\] - \([0-9-]*\)$|## [${VERSION}] - \1 ${PR_LINK}|" CHANGELOG.md

          # Commit and push the change
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "Add PR #${PR_NUMBER} link to CHANGELOG for ${TAG_NAME}"
          git push origin test

          echo "‚úÖ Added PR #${PR_NUMBER} link to CHANGELOG.md"

      - name: Auto-merge PR and create tag
        if: ${{ github.event.inputs.auto_merge == 'true' }}
        env:
          TAG_NAME: ${{ steps.version.outputs.tag }}
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          echo "üîÑ Merging PR #${PR_NUMBER}..."

          # Wait for any status checks to complete
          sleep 5

          # Merge the PR
          gh pr merge "$PR_NUMBER" --merge --delete-branch=false

          echo "‚úÖ PR #${PR_NUMBER} merged to main"

          # Fetch latest main
          git fetch origin main

          # Create and push tag on main
          echo "üè∑Ô∏è  Creating tag ${TAG_NAME} on main..."
          git tag "$TAG_NAME" origin/main
          git push origin "$TAG_NAME"

          echo "‚úÖ Tag ${TAG_NAME} created and pushed"
          echo "üöÄ Release workflow will be triggered automatically"

  archive:
    if: ${{ github.event.inputs.action == 'archive' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Archive current main
        env:
          ARCHIVE_TAG: ${{ github.event.inputs.archive_tag }}
        run: |
          set -euo pipefail
          git fetch origin

          # Tag the current main for archive
          if [ -z "${ARCHIVE_TAG:-}" ]; then
            echo "Error: archive_tag is required"
            exit 1
          fi

          git tag -f "$ARCHIVE_TAG" origin/main
          git push origin "$ARCHIVE_TAG" --force
